#16-11-30

TeaOutpost: 
  type: version 
  name: Outpost by Tea
  id: 117
  description: Outpost by Tea
  version: 16-11-16b1

TeaOutpost_PlayerCommand:
    type: command
    debug: true
    name: outpost
    description: Outpost by Tea
    usage: /outpost
    default constants:
      colourlist: Dark_Green|Dark_Aqua|Dark_Red|Dark_Purple|Gold|Gray|Dark_Gray|Blue|Green|Aqua|Red|Light_Purple|Yellow|White
      mcmmolist: Acrobatics|Alchemy|Archery|Axes|Excavation|Fishing|Herbalism|Mining|Repair|Swords|Taming|Unarmed|Woodcutting
      spelllist: Bad_Luck|Blindness|Fire_Resistance|Glowing|Haste|Hunger|Invisibility|Jump_Boost|Luck|Mining_Fatigue|Nausea|Night_Vision|Poison|Regeneration|Resistance|Saturation|Slowness|Speed|Strength|Water_Breathing|Weakness
      targetlist: ALL|TEAM|ENEMY|NONE
    script:
      - choose <context.args.first||default>:
   ## HERE ---
        - case here:
          - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.cuboids>]||false> == true || <player.location.town||null> != null {
            - foreach <player.location.cuboids||li@> {
              - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
                - define CuboidName <def[value].replace[cu@].with[]>
                - foreach stop
                }
                else {
                  - define CuboidName Next
                  }
              }
            - if %CuboidName% == null {
              - define CuboidName Next
              }
            - announce "<player.name> found CuboidName %CuboidName%" to_flagged:DreamListener
            - if %CuboidName% == Next && <player.location.town||null> != null {
              - define TownsName <player.location.town.replace[town@].with[]||null>
            #  - define ShortestDistance 99999
              - foreach <server.flag[%TownsName%OutpostList]||li@> {
                - define ValueCenter <cu@%value%.center>
                - define DistanceToValue <player.location.distance[<def[ValueCenter]>]>
                - if <def[DistanceToValue]> < <def[ShortestDistance]||99999> {
                  - define ShortestDisance <def[DistanceToValue]>
                  - define NearestOutpost %value%
                  }
                }
              - define CuboidName <def[NearestOutpost]||Next>
              }
            - announce "<player.name> found CuboidName %CuboidName%" to_flagged:DreamListener
            - if %CuboidName% == Next {
              - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Sorry, no Outpost here! <proc[msgCommand].context[<aqua>View Outpost List?|outpost list|<aqua>This will show you a list of all Outposts.]>" targets:<player>
              }
              else {
                - if <server.flag[%Cuboidname%TownName]||null> != null {
                  - define InfluenceName <server.flag[%CuboidName%TownName]>
               #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
                  }
                  else {
                    - define InfluenceName %CuboidName%
                 #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
                    }
                - define ManageName %CuboidName%
                - define TrainingTime <server.flag[%ManageName%Facing].replace[north].with[Noon].replace[south].with[Midnight].replace[East].with[Dawn].replace[West].with[Dusk].first||None>
                - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
                - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
                - define TownOwnerStuff <server.flag[TownOwnerof%InfluenceName%].to_titlecase||Gray>
                - define TownOwnerStuffSecondary <server.flag[TownOwnerof%InfluenceName%Secondary].to_titlecase||Gray>
                - if %OwnerStuff% == <player.flag[RaceColour]||Gray> {
                 # - define ManageName %CuboidName%
                 # - define TrainingTime <server.flag[%ManageName%Facing].replace[north].with[Noon].replace[south].with[Midnight].replace[East].with[Dawn].replace[West].with[Dusk].first||None>
                 # - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
                 # - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
                  - ^narrate "" targets:<player>
                  - ^narrate "<gold><&lb>OUTPOST<&rb> ID<&co> <gray><def[ManageName].to_uppercase>" targets:<player>
                  - if <player.flag[TeaOutpostKingPass]||false> != true && <player.flag[TeaOutpostBypass]||false> != true && <player.flag[Tea%ManageName%Pass]||false> != true {
                    - ^narrate "<proc[msgCommand].context[<dark_aqua> <&gt> Current Town Owner<&co> <%TownOwnerStuff%><server.flag[%TownOwnerStuff%DisplayName]||Wild> (<server.flag[%InfluenceName%InfluencePoints%TownOwnerStuff%].round||00> IP)|outpost influence %InfluenceName%|<%TownOwnerStuff%><server.flag[%TownOwnerStuff%DisplayName]||Wild><gray> is the current owner.<&nl><%TownOwnerStuff%>%TownOwnerStuff% <gray>is their Team Colour.<&nl><%TownOwnerStuffSecondary%>%TownOwnerStuffSecondary%<gray> is a Personal Colour.]> " targets:<player>
                    - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> Current Influencer<&co> <white><server.flag[%OwnerStuff%DisplayName]||Wild> / <%OwnerStuff%>%OwnerStuff% <white>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary%|<%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild><gray> is the current owner.<&nl><%OwnerStuff%>%OwnerStuff% <gray>is their Team Colour.<&nl><%OwnerStuffSecondary%>%OwnerStuffSecondary%<gray> is a Personal Colour.]> " targets:<player>
                    - ^narrate "<proc[msgHover].context[<gray> <&gt> Training Time<&co> <white>%TrainingTime%|<gray>Visit this Outpost at %TrainingTime% for<&co><&nl><dark_aqua>+1 Experience Level<&nl><gray>+1 <server.flag[%ManageName%TrainingFocus]||None> Level (if Minecraft Level 30)<&nl><dark_aqua>+20 minutes of <server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||Nothing> (if Minecraft Level 60)]>" targets:<player>

                    - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> Display Name<&co> <white><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>|<dark_red>Only Nation Kings can change this.]>" targets:<player>
                    - ^narrate "<proc[msgHover].context[<gray> <&gt> MCMMO Focus<&co> <white><server.flag[%ManageName%TrainingFocus]||None>|<dark_red>Only Nation Kings can change this.]>" targets:<player>
                    }
                    else {
                      - ^narrate "<proc[msgCommand].context[<dark_aqua> <&gt> Current Town Owner<&co> <%TownOwnerStuff%><server.flag[%TownOwnerStuff%DisplayName]||Wild> (<server.flag[%InfluenceName%InfluencePoints%TownOwnerStuff%].round||00> IP)|outpost influence %InfluenceName%|<%TownOwnerStuff%>Click to view influence board.]> " targets:<player>
                      - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> Current Influencer<&co> <white><server.flag[%OwnerStuff%DisplayName]||Wild> / <%OwnerStuff%>%OwnerStuff% <white>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary%|<%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild><gray> is the current owner.<&nl><%OwnerStuff%>%OwnerStuff% <gray>is their Team Colour.<&nl><%OwnerStuffSecondary%>%OwnerStuffSecondary%<gray> is a Personal Colour.]> " targets:<player>
                      - ^narrate "<proc[msgHover].context[<gray> <&gt> Training Time<&co> <white>%TrainingTime%|<gray>Visit this Outpost at %TrainingTime% for<&co><&nl><dark_aqua>+1 Experience Level<&nl><gray>+1 <server.flag[%ManageName%TrainingFocus]||None> Level (if Minecraft Level 30)<&nl><dark_aqua>+20 minutes of <server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||Nothing> (if Minecraft Level 60)]>" targets:<player>
                      - ^narrate "<proc[msgHint].context[<gold> <&gt> Display Name<&co> <white><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>|outpost rename %ManageName%<&sp>|<green>Only Nation Kings can change this.<&nl><dark_aqua>Click then type a new Name at the end of the command!]>" targets:<player>
                      - ^narrate "<proc[msgCommand].context[<gold> <&gt> MCMMO Focus<&co> <white><server.flag[%ManageName%TrainingFocus]||None>|outpost showmcmmo %ManageName%|<green>Only Nation Kings can change this.<&nl><gray>Click to pick an MCMMO Focus!]>" targets:<player>
                      }
                      #  - ^narrate "" targets:<player>
                  - ^narrate "<proc[msgHint].context[<gold> <&gt> Training Message<&co>|outpost setmessage %ManageName%<&sp>|<dark_aqua>Click then type a new Message at the end of the command!]>" targets:<player>
                  - ^narrate "<proc[msgHint].context[<gold> <&gt> <white><italic><server.flag[%ManageName%TrainingMessage]||None>|outpost setmessage %ManageName%<&sp>|<dark_aqua>Click then type a new Message at the end of the command!]>" targets:<player>
                #  - ^narrate "" targets:<player>
                  - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Effect<&co> <white><server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||None>|outpost spells %ManageName%|<gray>Click to pick a Spell Effect!]>" targets:<player>
                  - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Targets<&co> <white><server.flag[%ManageName%SpellTargets]||None>|outpost showtargets %ManageName%|<dark_aqua>Click to pick a Spell Target!]>" targets:<player>
                  - ^narrate "<proc[msgCommand].context[<gold> <&gt> Access Upgrades|outpost upgrades %ManageName%|<green>Click to buy and manage upgrades]>" targets:<player>
                  - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost|<gold>Back to Outpost Menu]>" targets:<player>
                  }
                  else {
                   # - define ManageName %CuboidName%
                   # - define TrainingTime <server.flag[%ManageName%Facing].replace[north].with[Noon].replace[south].with[Midnight].replace[East].with[Dawn].replace[West].with[Dusk].first||None>
                   # - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
                   # - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
                    - ^narrate "" targets:<player>
                    - ^narrate "<proc[msgHover].context[<gold><&lb>OUTPOST<&rb> ID<&co> <gray><def[ManageName].to_uppercase>|<gray>This is a permanent name.]>" targets:<player>
                    - ^narrate "<proc[msgCommand].context[<dark_aqua> <&gt> Current Town Owner<&co> <%TownOwnerStuff%><server.flag[%TownOwnerStuff%DisplayName]||Wild> (<server.flag[%InfluenceName%InfluencePoints%TownOwnerStuff%].round||00> IP)|outpost influence %InfluenceName%|<%TownOwnerStuff%>Click to view influence board.]> " targets:<player>
                    - ^narrate "<proc[msgHover].context[<dark_aqua> - Current Influencer<&co> <white><server.flag[%OwnerStuff%DisplayName]||Wild> / <%OwnerStuff%>%OwnerStuff% <white>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary%|<%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild><gray> is the current owner.<&nl><%OwnerStuff%>%OwnerStuff% <gray>is their Team Colour.<&nl><%OwnerStuffSecondary%>%OwnerStuffSecondary%<gray> is a Personal Colour.]> " targets:<player>
                    - ^narrate "<proc[msgHover].context[<gray> - Display Name<&co> <white><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>|<dark_red>Capture this Outpost to make changes.<&nl><gray>Only <%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild> <gray>can make changes to this Outpost.]>" targets:<player>
                  #  - ^narrate "" targets:<player>
                    - ^narrate "<proc[msgHover].context[<dark_aqua> - Training Time<&co> <white>%TrainingTime%|<dark_red>Capture this Outpost to make changes.<&nl><gray>Only <%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild> <gray>can make changes to this Outpost.]>" targets:<player>
                    - ^narrate "<proc[msgHover].context[<gray> - MCMMO Focus<&co> <white><server.flag[%ManageName%TrainingFocus]||None>|<dark_red>Capture this Outpost to make changes.<&nl><gray>Only <%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild> <gray>can make changes to this Outpost.]>" targets:<player>
                    - ^narrate "<proc[msgHover].context[<dark_aqua> - Training Message<&co>|<dark_red>Capture this Outpost to make changes.<&nl><gray>Only <%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild> <gray>can make changes to this Outpost.]>" targets:<player>
                    - ^narrate "<proc[msgHover].context[   <white><italic><server.flag[%ManageName%TrainingMessage]||None>|<dark_red>Capture this Outpost to make changes.<&nl><gray>Only <%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild> <gray>can make changes to this Outpost.]>" targets:<player>
               #     - ^narrate "" targets:<player>
                    - ^narrate "<proc[msgHover].context[<gray> - Spell Effect<&co> <white><server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||None>|<dark_red>Capture this Outpost to make changes.<&nl><gray>Only <%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild> <gray>can make changes to this Outpost.]>" targets:<player>
                    - ^narrate "<proc[msgHover].context[<dark_aqua> - Spell Targets<&co> <white><server.flag[%ManageName%SpellTargets]||None>|<dark_red>Capture this Outpost to make changes.<&nl><gray>Only <%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild> <gray>can make changes to this Outpost.]>" targets:<player>
                    - ^narrate "<proc[msgCommand].context[<gold> <&gt> Access Upgrades|outpost upgrades %ManageName%|<green>Buy and manage upgrades]>" targets:<player>
                    - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost|<gold>Back to Outpost Menu]>" targets:<player>
                    }

              #  - ^narrate "<gray> - <gold>Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
             #   - ^narrate "<proc[msgCommand].context[<dark_aqua><&lt><&lt> RETURN TO OUTPOST LIST|toutpost list|<dark_aqua>Return to Outpost List]>" targets:<player>
                }
            }
            else {
              - ^narrate "<dark_red><&lb>OUTPOST<&rb> Sorry, no Outpost here! <proc[msgCommand].context[<gold><&gt> View Outpost List?|outpost list|<gold>This will show you a list of all Outposts.]>" targets:<player>
              }
   ## INFLUENCE MENU ---
        - case influence:
          - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.cuboids>]||false> == true || <player.location.town||null> != null {
            - foreach <player.location.cuboids||li@> {
              - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
                - define CuboidName <def[value].replace[cu@].with[]>
                - foreach stop
                }
                else {
                  - define CuboidName Next
                  }
              }
            - if %CuboidName% == null {
              - define CuboidName Next
              }
            - announce "<player.name> found CuboidName %CuboidName%" to_flagged:DreamListener
            - if %CuboidName% == Next && <player.location.town||null> != null {
              - define TownsName <player.location.town.replace[town@].with[]||null>
            #  - define ShortestDistance 99999
              - foreach <server.flag[%TownsName%OutpostList]||li@> {
                - define ValueCenter <cu@%value%.center>
                - define DistanceToValue <player.location.distance[<def[ValueCenter]>]>
                - if <def[DistanceToValue]> < <def[ShortestDistance]||99999> {
                  - define ShortestDisance <def[DistanceToValue]>
                  - define NearestOutpost %value%
                  }
                }
              - define CuboidName <def[NearestOutpost]||Next>
              }
            - announce "<player.name> found CuboidName %CuboidName%" to_flagged:DreamListener
   # IF NO OUTPOST HAS BEEN FOUND { SORRY NO OUTPOST HERE! }
            - if %CuboidName% == Next {
              - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Sorry, no Outpost here! <proc[msgCommand].context[<aqua>View Outpost List?|outpost list|<aqua>This will show you a list of all Outposts.]>" targets:<player>
              }
     # ELSE (IF AN OUTPOST HAS BEEN FOUND) {
              else {
       # IF THERE IS A TOWN ASSOCIATED WITH THAT OUTPOST { DEFINE MANAGENAME AS THE TOWN NAME }
                - if <server.flag[%Cuboidname%TownName]||null> != null {
                  - define ManageName <server.flag[%CuboidName%TownName]>
                  - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
                  }
         # ELSE DEFINE MANAGENAME AS THE OUTPOST NAME
                  else {
                    - define ManageName %CuboidName%
                    - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
                    }
       # DEFINE A BUNCH OF STUFF WE'LL NEED LATER
                - define TrainingTime <server.flag[%ManageName%Facing].replace[north].with[Noon].replace[south].with[Midnight].replace[East].with[Dawn].replace[West].with[Dusk].first||None>
                - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
                - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
                - define LastDIBoostDate <player.flag[LastDIBoostDate]||00>
                - define CurrentDate <util.date.time.year><util.date.time.month.replace[regex:^(?!..)].with[0]><util.date.time.day.replace[regex:^(?!..)].with[0]>
                - define CurrentTime <util.date.time.hour><util.date.time.minute.replace[regex:^(?!..)].with[0]>
                - ^narrate "<gold><&lb>OUTPOST<&rb> INFLUENCE BOARD<&co> <gray><def[ManageName].to_uppercase>" targets:<player>
       # IF %MANAGENAME%INFLUENCELIST IS EMPTY, NARRATE "NONE"
                - if <server.flag[%ManageName%InfluenceList].is_empty||true> {
                  - ^narrate "<gray>None" targets:<player>
                  }
         # ELSE (%MANAGENAME%INFLUENCELIST IS NOT EMPTY) {
                  else {
           # IF (THE PLAYER HAS ALREADY USED HIS DAILY INFLUENCE BOOST) {
                    - if <def[LastDIBoostDate]> == <def[CurrentDate]> {
                      - narrate "Next Boost in <el@24.sub[<util.date.time.hour>]> hours." targets:<player>
             # FOREACH (LIST OF ALL OUTPOSTS IN TOWN, OR JUST THE OUTPOST NAME) {
                      - define NoonLightList <server.flag[%ManageName%OutpostList].as_list||li@%ManageName%>
                      - if <def[NoonLightList].size> == 1 {
                        - define ManageNameDisplay <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>
                        }
                        else {
                          - define ManageNameDisplay %ManageName%
                          }
                    #  - define NoonLightOwnersList li@
                      - foreach <def[NoonLightList]> {
               # ADD %VALUE% TO THE NOONLIGHTOWNERSLIST IN THE FORMAT OWNEROF%VALUE%/%VALUE%LASTCAPTUREDATE
                        - if <def[NoonLightOwnersList]||null> == null {
                          - define NoonLightOwnersList li@<server.flag[Ownerof%value%]>/<server.flag[%value%LastCaptureDate]>/<server.flag[%value%LastCaptureTime]>/%value%
                          }
                          else {
                            - define NoonLightOwnersList <def[NoonLightOwnersList]>|<server.flag[Ownerof%value%]>/<server.flag[%value%LastCaptureDate]>/<server.flag[%value%LastCaptureTime]>/%value%

                            }
                        }
               ###       - announce <def[NoonLightOwnersList]>
               ###       - announce "<green><def[NoonLightOwnersList].get_sub_items[1]>"
                      - foreach <def[NoonLightOwnersList].get_sub_items[1].deduplicate> {
                        - define %value%EstablishCount 0
                        }
             # FOREACH (%MANAGENAME%INFLUENCELIST) {
                      - foreach <server.flag[%ManageName%InfluenceList].as_list> {
                     #   - if %value% == <server.flag[Ownerof%ManageName%]> {
                ###        - announce "<green>%value%"
                        - define InfluenceTeam %value%
               # IF NOONLIGHTOWNERSLIST (OWNEROF%VALUE%/%VALUE%LASTCAPTUREDATE) CONTAINS %VALUE%
               # (( IF THE INFLUENCE LIST VALUE CAN BE FOUND ON THE LIST OF OWNERS FOR THIS INFLUENCEPOST ))
               # ((( IF A TEAM OWNS A CONTROL ZONE WITH THIS INFLUENCEPOST )))
                        - if <def[NoonLightOwnersList].get_sub_items[1].contains[%InfluenceTeam%]> {
                          - define RelevantValuePositions <def[NoonLightOwnersList].as_list.find_all_partial[%InfluenceTeam%]>
                ###          - announce "<green>Def: <def[RelevantValuePositions]>"
                ###          - announce "<green>RelevantValues: <def[NoonLightOwnersList].get[%RelevantValuePositions%]>"
                          - define RelevantValues <def[NoonLightOwnersList].get[%RelevantValuePositions%]>
         #                 - foreach <def[NoonLightOwnersList].get_sub_items[1]> {
         #                   - define %value%EstablishCount 0
         #                   }
                          - foreach <def[RelevantValues].as_list> {
                            - define CaptureTeam <def[value].as_list.get_sub_items[1].first>
                            - define CaptureDate <def[value].as_list.get_sub_items[2].first>
                            - define CaptureTime <def[value].as_list.get_sub_items[3].first>
                         #   - announce "<gold>%CaptureDate% / %CurrentDate%"
                   # IF OLDESTDATE IS NOT TODAY {
                            - if <def[CurrentDate]> != <def[CaptureDate]> {
                     # IF OLDESTDATE IS NOT YESTERDAY (MEANING IT'S AT LEAST THE DAY BEFORE YESTERDAY) {
                       # DEFINE ESTABLISHMENTCHECK TRUE
                              - if <def[CurrentDate]> != <def[CaptureDate].add[1]> {
                                - define Established true
                                - define %CaptureTeam%EstablishCount <def[%CaptureTeam%EstablishCount].add[1]>
                                }
                       # ELSE IF OLDESTDATE IS YESTERDAY AAAAND OLDESTTIME HAS ALREADY BEEN PASSED (MEANING ITS BEEN AT LEAST 24 HOURS) {
                         # DEFINE ESTABLISHMENTCHECK TRUE
                                else if <def[CurrentDate]> == <def[CaptureDate].add[1]> && <def[CurrentTime]> >= <def[CaptureTime]> {
                                  - define Established true
                                  - define %CaptureTeam%EstablishCount <def[%CaptureTeam%EstablishCount].add[1]>
                                  }
                                  else {
                                    - define Established false
                                  }
                              }
                              else {
                                - define Established false
                              }
                  ###          - announce "<gold>%CaptureDate% / %CurrentDate% %established%"
                       #     - define %CaptureTeam%EstablishCount <def[%CaptureTeam%EstablishCount].add[1]>
                            }
        #                  - foreach <def[NoonLightOwnersList].get_sub_items[1]> {
        #                    - announce "<gold><def[%value%EstablishCount]>"
        #                    }
      #                    - announce "<yellow>RelevantDates <def[RelevantValues].as_list.get_sub_items[2].numerical>"
      #                    - define RelevantDates <def[RelevantValues].as_list.get_sub_items[2].numerical>
      #                    - announce "<yellow>OldestDate <def[RelevantDates].first>"
      #                    - define OldestDate <def[RelevantDates].first>
      #                    - announce "<yellow>OldestDatePosition: <def[RelevantValues].as_list.find_all_partial[%OldestDate%]>"
      #                    - define OldestDatePositions <def[RelevantValues].as_list.find_all_partial[%OldestDate%]>
      #                    - announce "<yellow>OldestOutposts: <def[RelevantValues].as_list.get[%OldestDatePositions%]>"
      #                    - define OldestOutposts <def[RelevantValues].as_list.get[%OldestDatePositions%]>
      #                    - announce "<yellow>OldestTime: <def[OldestOutposts].as_list.get_sub_items[3].numerical.first>"
      #                    - define OldestTime <def[OldestOutposts].as_list.get_sub_items[3].numerical.first>
      #                    - announce "<yellow>OldestOutpostFinalPosition: <def[RelevantValues].as_list.find_all_partial[%OldestDate%/%OldestTime%]>"
      #                    - define OldestOutpostFinalPosition <def[RelevantValues].as_list.find_all_partial[%OldestDate%/%OldestTime%]>
      #                    - announce "<yellow>OldestOutpostFinal: <def[RelevantValues].as_list.get[%OldestOutpostFinalPosition%]>"
      #                    - announce ""
        #         # IF OLDESTDATE IS NOT TODAY {
        #                  - if <def[CurrentDate]> != <def[OldestDate]> {
        #           # IF OLDESTDATE IS NOT YESTERDAY (MEANING IT'S AT LEAST THE DAY BEFORE YESTERDAY) {
        #             # DEFINE ESTABLISHMENTCHECK TRUE
        #                    - if <def[CurrentDate]> != <def[OldestDate].add[1]> {
        #                      - define EstablishmentCheck true
        #                      }
        #             # ELSE IF OLDESTDATE IS YESTERDAY AAAAND OLDESTTIME HAS ALREADY BEEN PASSED (MEANING ITS BEEN AT LEAST 24 HOURS) {
        #               # DEFINE ESTABLISHMENTCHECK TRUE
        #                      else if <def[CurrentDate]> == <def[OldestDate].add[1]> && <def[CurrentTime]> >= <def[OldestTime]> {
        #                        - define EstablishmentCheck true
        #                        }
        #                        else {
        #                          - define EstablishmentCheck false
        #                        }
        #                    }
        #                    else {
        #                      - define EstablishmentCheck false
        #                    }
        #                  - announce "<yellow>%EstablishmentCheck%"
                          - define NoonLightCountforTeam%InfluenceTeam% <def[RelevantValues].as_list.size>
                          - define NoonLightCountAgainstTeam%InfluenceTeam% <def[NoonLightOwnersList].size.sub[<def[NoonLightCountforTeam%InfluenceTeam%]>]>
                  ###        - announce "<red>%InfluenceTeam% <def[NoonLightCountforTeam%InfluenceTeam%]> and <def[NoonLightCountAgainstTeam%InfluenceTeam%]>"
                          - define EstablishmentCount%InfluenceTeam% <server.flag[%InfluenceTeam%OutpostList].as_list.size||0>
                  ###        - announce "<red><def[EstablishmentCount%InfluenceTeam%]>"
                  ###        - announce "<red>List<server.flag[%InfluenceTeam%OutpostList].as_list>"


            #              - if <def[CurrentDate]> != <def[OldestDate]> {
            #                - if <def[CurrentDate]> != <def[OldestDate].add[1]> && <def[CurrentTime]> >= <def[OldestTime]> {
            #                  - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) a+<server.flag[%value%OutpostList].as_list.size.add[1]||1> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb> <def[CurrentDate]> != <server.flag[%ManageName%LastCaptureDate]||0> && <def[CurrentTime]> >= <server.flag[%ManageName%LastCaptureTime]||0>"
            #                  }
            #                }
          #                  else {
          #                    - define NoonLightCountforTeam <def[NoonLightOwnersList].count[%value%]>
          #                    - define NoonLightCountAgainstTeam <def[NoonLightOwnersList].size.sub[<def[NoonLightCountforTeam]>]>
          #                    - define NetGainforTeam <def[NoonLightCountforTeam].sub[<def[NoonLightCountAgainstTeam]>].abs>
          #                    - if <def[NoonLightCountAgainstTeam]> > <def[NoonLightCountforTeam]> {
          #                      - define NetGainforTeam -<def[NetGainforTeam].round>
          #                      }
          #                      else {
          #                      - define NetGainforTeam +<def[NetGainforTeam].round>
          #                        }
          #                    - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) <def[NetGainforTeam]> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>"
          #                    }
                #          - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) +<def[NoonLightCountforTeam]||0> -<def[NoonLightCountAgainstTeam]> +<def[EstablishmentCount]> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>"
#should be adjusted to establishmentcount x number of established 'posts
                #          - foreach <def[NoonLightOwnersList].get_sub_items[1].deduplicate> {
                #            - announce "<gold><def[%value%EstablishCount]> %value%"
                #            }
                          }
                # ELSE (THE TEAM DOES NOT OWN ANY CONTROL ZONES AT THIS INFLUENCE POST)
                #          else {
                #            - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) -<def[NoonLightOwnersList].size> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>"
                #            }
                        }
              ###        - foreach <def[NoonLightOwnersList].get_sub_items[1].deduplicate> {
              ###          - announce "<aqua>%value%: Est(<def[%value%EstablishCount]>x<def[EstablishmentCount%value%]>= <def[%value%EstablishCount].mul[<def[EstablishmentCount%value%]>]>) CountFor(+<def[NoonLightCountforTeam%value%]>) CountAgainst(-<def[NoonLightCountAgainstTeam%value%]>) = <def[%value%EstablishCount].mul[<def[EstablishmentCount%value%]>].add[<def[NoonLightCountforTeam%value%]>].sub[<def[NoonLightCountAgainstTeam%value%]>]>"
              ###         # - announce "<aqua>%value%: Est() CountFor(+<def[NoonLightCountforTeam%value%]>) CountAgainst(-<def[NoonLightCountAgainstTeam%value%]>) "
              ###          }
                        
#==============================================================================================================
                        
             # FOREACH (%MANAGENAME%INFLUENCELIST) {
                      - foreach <server.flag[%ManageName%InfluenceList].as_list> {
                     #   - if %value% == <server.flag[Ownerof%ManageName%]> {
                      #  - announce "<light_purple>%value%"
               # IF NOONLIGHTOWNERSLIST (OWNEROF%VALUE%/%VALUE%LASTCAPTUREDATE) CONTAINS %VALUE%
               # (( IF THE INFLUENCE LIST VALUE CAN BE FOUND ON THE LIST OF OWNERS FOR THIS INFLUENCEPOST ))
               # ((( IF A TEAM OWNS A CONTROL ZONE WITH THIS INFLUENCEPOST )))
                        - if <def[NoonLightOwnersList].get_sub_items[1].contains[%value%]> {
                          - define NetInfluence <def[%value%EstablishCount].mul[<def[EstablishmentCount%value%]>].add[<def[NoonLightCountforTeam%value%]>].sub[<def[NoonLightCountAgainstTeam%value%]>]>
                          - if <def[NetInfluence]> >= 0 {
                            - define NetInfluenceDisplay +<def[NetInfluence]>
                            - define NetInfluenceColour green
                            - define NetInfluenceWord gain
                            }
                            else {
                              - define NetInfluenceDisplay <def[NetInfluence]>
                              - define NetInfluenceColour dark_red
                              - define NetInfluenceWord lose
                            }
                          - if <def[NoonLightCountforTeam]> > 0 {
                           # - define NetInfluenceDisplay +<def[NetInfluence]>
                            - define NLCFTColour green
                           # - define NetInfluenceWord gain
                            }
                            else {
                          #    - define NetInfluenceDisplay <def[NetInfluence]>
                              - define NLCFTColour dark_red
                            #  - define NetInfluenceWord lose
                            }
                          - define HoverLine1 <%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&sp>(<def[value].replace[_].with[<&sp>]>)<&sp><&sp><&sp>-<&sp><&sp><&sp><server.flag[%ManageName%InfluencePoints%value%].first.round><&sp>Influence<&sp>Points
                          - define HoverLine2 <%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><gold><&sp>will<&sp><def[NetInfluenceWord]><&sp><%NetInfluenceColour%><def[NetInfluenceDisplay]><gold><&sp>IP<&sp>every<&sp>Minecraft<&sp>day.
                          - define HoverLine3 <%NLCFTColour%><&sp><&sp>+<def[NoonLightCountforTeam%value%]><&sp><gold><&co><&sp><%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&sp><gold>has<&sp><red>captured<&sp><%NLCFTColour%><def[NoonLightCountforTeam%value%]><&sp><gold>Control<&sp>Zones<&sp>at<&sp><def[ManageNameDisplay]>
                          - define HoverLineEst1 <green><&sp><&sp>+<def[%value%EstablishCount].mul[<def[EstablishmentCount%value%]>]><&sp><gold><&co><&sp><%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&sp><gold>has<&sp><dark_green>established<&sp><%NLCFTColour%><def[%value%EstablishCount]><&sp><gold>of<&sp>its<&sp><gold>Control<&sp>Zones<&sp>
                          - define HoverLineEst2 <green><&sp><&sp><&sp><&sp><&sp><&sp><gold><&co><&sp>Every<&sp>Established<&sp>Control<&sp>Zone<&sp>is<&sp>granting<&sp><green>+<def[EstablishmentCount%value%]><&sp><gold>IP
                          - define HoverLine4 <dark_red><&sp><&sp>-<def[NoonLightCountAgainstTeam%value%]><&sp><gold><&co><&sp><gold>There<&sp>are<&sp><dark_red><def[NoonLightCountAgainstTeam%value%]><&sp><gold>Enemy<&sp>Control<&sp>Zones<&sp>at<&sp><def[ManageNameDisplay]>
                          - define HoverLine5 <%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><gold><&sp>is<&sp>estimated<&sp>to<&sp><def[NetInfluenceWord]><&sp><%NetInfluenceColour%><def[NetInfluence].mul[72].abs.round><gold><&sp>IP<&sp>every<&sp>24<&sp>hours.
                          - if <def[%value%EstablishCount]> > 0 {
                            - define HoverText <def[HoverLine1]><&nl><&nl><def[HoverLine2]><&nl><&nl><def[HoverLine3]><&nl><def[HoverLineEst1]><&nl><def[HoverLineEst2]><&nl><&nl><def[HoverLine4]><&nl><&nl><def[HoverLine5]>
                            }
                            else {
                              - define HoverText <def[HoverLine1]><&nl><&nl><def[HoverLine2]><&nl><&nl><def[HoverLine3]><&nl><&nl><def[HoverLine4]><&nl><&nl><def[HoverLine5]>
                              }
                         ### - announce "<aqua>%value%: Est(<def[%value%EstablishCount]>x<def[EstablishmentCount%value%]>= <def[%value%EstablishCount].mul[<def[EstablishmentCount%value%]>]>) CountFor(+<def[NoonLightCountforTeam%value%]>) CountAgainst(-<def[NoonLightCountAgainstTeam%value%]>) = <def[%value%EstablishCount].mul[<def[EstablishmentCount%value%]>].add[<def[NoonLightCountforTeam%value%]>].sub[<def[NoonLightCountAgainstTeam%value%]>]>"
                          - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]><proc[msgHover].context[<%value%>) <def[NetInfluenceDisplay]> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>|<def[HoverText]>]>"

#                          - announce "<def[NoonLightOwnersList].get_sub_items[1]>"
#                          - define RelevantValuePositions <def[NoonLightOwnersList].as_list.find_all_partial[%value%]>
#                          - announce "Def: <def[RelevantValuePositions]>"
#                          - announce "RelevantValues<def[NoonLightOwnersList].get[%RelevantValuePositions%]>"
#                          - define RelevantValues <def[NoonLightOwnersList].get[%RelevantValuePositions%]>
#         #                 - foreach <def[NoonLightOwnersList].get_sub_items[1]> {
#         #                   - define %value%EstablishCount 0
#         #                   }
#                          - foreach <def[RelevantValues].as_list> {
#                            - define CaptureTeam <def[value].as_list.get_sub_items[1].first>
#                            - define CaptureDate <def[value].as_list.get_sub_items[2].first>
#                            - define CaptureTime <def[value].as_list.get_sub_items[3].first>
#                         #   - announce "<gold>%CaptureDate% / %CurrentDate%"
#                   # IF OLDESTDATE IS NOT TODAY {
#                            - if <def[CurrentDate]> != <def[CaptureDate]> {
#                     # IF OLDESTDATE IS NOT YESTERDAY (MEANING IT'S AT LEAST THE DAY BEFORE YESTERDAY) {
#                       # DEFINE ESTABLISHMENTCHECK TRUE
#                              - if <def[CurrentDate]> != <def[CaptureDate].add[1]> {
#                                - define Established true
#                                - define %CaptureTeam%EstablishCount <def[%CaptureTeam%EstablishCount].add[1]>
#                                }
#                       # ELSE IF OLDESTDATE IS YESTERDAY AAAAND OLDESTTIME HAS ALREADY BEEN PASSED (MEANING ITS BEEN AT LEAST 24 HOURS) {
#                         # DEFINE ESTABLISHMENTCHECK TRUE
#                                else if <def[CurrentDate]> == <def[CaptureDate].add[1]> && <def[CurrentTime]> >= <def[CaptureTime]> {
#                                  - define Established true
#                                  - define %CaptureTeam%EstablishCount <def[%CaptureTeam%EstablishCount].add[1]>
#                                  }
#                                  else {
#                                    - define Established false
#                                  }
#                              }
#                              else {
#                                - define Established false
#                              }
#                            - announce "<gold>%CaptureDate% / %CurrentDate% %established%"
#                       #     - define %CaptureTeam%EstablishCount <def[%CaptureTeam%EstablishCount].add[1]>
#                            }
#        #                  - foreach <def[NoonLightOwnersList].get_sub_items[1]> {
#        #                    - announce "<gold><def[%value%EstablishCount]>"
#        #                    }
#                          - announce "RelevantDates <def[RelevantValues].as_list.get_sub_items[2].numerical>"
#                          - define RelevantDates <def[RelevantValues].as_list.get_sub_items[2].numerical>
#                          - announce "OldestDate <def[RelevantDates].first>"
#                          - define OldestDate <def[RelevantDates].first>
#                          - announce "OldestDatePosition: <def[RelevantValues].as_list.find_all_partial[%OldestDate%]>"
#                          - define OldestDatePositions <def[RelevantValues].as_list.find_all_partial[%OldestDate%]>
#                          - announce "OldestOutposts: <def[RelevantValues].as_list.get[%OldestDatePositions%]>"
#                          - define OldestOutposts <def[RelevantValues].as_list.get[%OldestDatePositions%]>
#                          - announce "OldestTime: <def[OldestOutposts].as_list.get_sub_items[3].numerical.first>"
#                          - define OldestTime <def[OldestOutposts].as_list.get_sub_items[3].numerical.first>
#                          - announce "OldestOutpostFinalPosition: <def[RelevantValues].as_list.find_all_partial[%OldestDate%/%OldestTime%]>"
#                          - define OldestOutpostFinalPosition <def[RelevantValues].as_list.find_all_partial[%OldestDate%/%OldestTime%]>
#                          - announce "OldestOutpostFinal: <def[RelevantValues].as_list.get[%OldestOutpostFinalPosition%]>"
#                          - announce ""
#                 # IF OLDESTDATE IS NOT TODAY {
#                          - if <def[CurrentDate]> != <def[OldestDate]> {
#                   # IF OLDESTDATE IS NOT YESTERDAY (MEANING IT'S AT LEAST THE DAY BEFORE YESTERDAY) {
#                     # DEFINE ESTABLISHMENTCHECK TRUE
#                            - if <def[CurrentDate]> != <def[OldestDate].add[1]> {
#                              - define EstablishmentCheck true
#                              }
#                     # ELSE IF OLDESTDATE IS YESTERDAY AAAAND OLDESTTIME HAS ALREADY BEEN PASSED (MEANING ITS BEEN AT LEAST 24 HOURS) {
#                       # DEFINE ESTABLISHMENTCHECK TRUE
#                              else if <def[CurrentDate]> == <def[OldestDate].add[1]> && <def[CurrentTime]> >= <def[OldestTime]> {
#                                - define EstablishmentCheck true
#                                }
#                                else {
#                                  - define EstablishmentCheck false
#                                }
#                            }
#                            else {
#                              - define EstablishmentCheck false
#                            }
#                          - announce "<red>%EstablishmentCheck%"
#                          - define NoonLightCountforTeam <def[RelevantValues].as_list.size>
#                          - define NoonLightCountAgainstTeam <def[NoonLightOwnersList].size.sub[<def[NoonLightCountforTeam]>]>
#                          - announce "<red>%NoonLightCountforTeam% and %NoonLightCountAgainstTeam%"
#                          - define EstablishmentCount <server.flag[%value%OutpostList].as_list.size||0>
#                          - announce "<red>%EstablishmentCount%"
#                          - announce "<red><server.flag[%value%OutpostList].as_list>"
#
#
#            #              - if <def[CurrentDate]> != <def[OldestDate]> {
#            #                - if <def[CurrentDate]> != <def[OldestDate].add[1]> && <def[CurrentTime]> >= <def[OldestTime]> {
#            #                  - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) a+<server.flag[%value%OutpostList].as_list.size.add[1]||1> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb> <def[CurrentDate]> != <server.flag[%ManageName%LastCaptureDate]||0> && <def[CurrentTime]> >= <server.flag[%ManageName%LastCaptureTime]||0>"
#            #                  }
#            #                }
#          #                  else {
#          #                    - define NoonLightCountforTeam <def[NoonLightOwnersList].count[%value%]>
#          #                    - define NoonLightCountAgainstTeam <def[NoonLightOwnersList].size.sub[<def[NoonLightCountforTeam]>]>
#          #                    - define NetGainforTeam <def[NoonLightCountforTeam].sub[<def[NoonLightCountAgainstTeam]>].abs>
#          #                    - if <def[NoonLightCountAgainstTeam]> > <def[NoonLightCountforTeam]> {
#          #                      - define NetGainforTeam -<def[NetGainforTeam].round>
#          #                      }
#          #                      else {
#          #                      - define NetGainforTeam +<def[NetGainforTeam].round>
#          #                        }
#          #                    - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) <def[NetGainforTeam]> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>"
#          #                    }
#                          - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) +<def[NoonLightCountforTeam]||0> -<def[NoonLightCountAgainstTeam]> +<def[EstablishmentCount]> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>"
##should be adjusted to establishmentcount x number of established 'posts
#                          - foreach <def[NoonLightOwnersList].get_sub_items[1].deduplicate> {
#                            - announce "<gold><def[%value%EstablishCount]> %value%"
#                            }
                          }
                          
                          
                          
                # ELSE (THE TEAM DOES NOT OWN ANY CONTROL ZONES AT THIS INFLUENCE POST)
                          else {
                            - define HoverLine1 <%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&sp>(<def[value].replace[_].with[<&sp>]>)<&sp><&sp><&sp>-<&sp><&sp><&sp><server.flag[%ManageName%InfluencePoints%value%].first.round><&sp>Influence<&sp>Points
                            - define HoverLine2 <%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><gold><&sp>will<&sp>lose<&sp><dark_red><def[NoonLightOwnersList].size><gold><&sp>IP<&sp>every<&sp>Minecraft<&sp>day.
                            - define HoverLine3 <dark_red><&sp><&sp>+0<&sp><gold><&co><&sp><%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&sp><gold>has<&sp>captured<&sp><dark_red>0<&sp><gold>Control<&sp>Zones<&sp>at<&sp><def[ManageNameDisplay]>
                            - define HoverLine4 <dark_red><&sp><&sp>-<def[NoonLightOwnersList].size><&sp><gold><&co><&sp><gold>There<&sp>are<&sp><dark_red><def[NoonLightOwnersList].size><&sp><gold>Enemy<&sp>Control<&sp>Zones<&sp>at<&sp><def[ManageNameDisplay]>
                            - define HoverLine5 <%value%><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><gold><&sp>is<&sp>estimated<&sp>to<&sp>lose<&sp><dark_red><def[NoonLightOwnersList].size.mul[72]><gold><&sp>IP<&sp>every<&sp>24<&sp>hours.
                            - define HoverText <def[HoverLine1]><&nl><&nl><def[HoverLine2]><&nl><&nl><def[HoverLine3]><&nl><def[HoverLine4]><&nl><&nl><def[HoverLine5]>
                            - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]><proc[msgHover].context[<%value%>) -<def[NoonLightOwnersList].size> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>|<def[HoverText]>]>"
                            }
                        }
#=======================================================================
                      }
             # ELSE (THE PLAYER HAS NOT YET USED HIS DAILY INFLUENCE BOOST) {
                      else {
                        - narrate "Boost available!" targets:<player>
                        - if !<server.flag[%ManageName%InfluenceList].contains[<player.flag[RaceColour]>]||false> {
                          - define PlayerTeam <player.flag[RaceColour]||Gray>
                          - narrate "<%PlayerTeam%><&lb><server.flag[%ManageName%InfluencePoints%PlayerTeam%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||000><&rb> <proc[msgCommand].context[<&lt>-|outpost boost subtract %ManageName% %PlayerTeam%|outpost boost subtract %ManageName% %PlayerTeam%]><%PlayerTeam%> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%PlayerTeam%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) <proc[msgCommand].context[+<&gt>|outpost boost add %ManageName% %PlayerTeam%|outpost boost add %ManageName% %PlayerTeam%]><%PlayerTeam%> <&lb><server.flag[%PlayerTeam%DisplayNameTag]||<server.flag[%PlayerTeam%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>"
                          }
                        - foreach <server.flag[%ManageName%InfluenceList].as_list> {
                          - narrate "<%value%><&lb><server.flag[%ManageName%InfluencePoints%value%].first.round.replace[regex:^(?!..)].with[0].replace[regex:^(?!...)].with[0]||0><&rb> <proc[msgCommand].context[<&lt>-|outpost boost subtract %ManageName% %value%|outpost boost subtract %ManageName% %value%]><%value%> (<proc[TeaOutpost_InfluenceBars].context[<server.flag[%ManageName%InfluencePoints%value%]||0>|<server.flag[%ManageName%MaxInfluence]||1000>]>) <proc[msgCommand].context[+<&gt>|outpost boost add %ManageName% %value%|outpost boost add %ManageName% %value%]><%value%> <&lb><server.flag[%value%DisplayNameTag]||<server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild>><&rb>"
                          }
                        }


                    }
                - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost here|<gold>Back to Outpost Here]>" targets:<player>

                }
            }
            else {
              - ^narrate "<dark_red><&lb>OUTPOST<&rb> Sorry, no Outpost here! <proc[msgCommand].context[<gold><&gt> View Outpost List?|outpost list|<gold>This will show you a list of all Outposts.]>" targets:<player>
              }
   ## BOOST ---
        - case boost:
          - define Confirmation <context.args.get[5]||No>
          - define BoostDirection <context.args.get[2]>
          - define OutpostID <context.args.get[3]>
          - define BoostTeam <context.args.get[4]>
          - define DailyInfluenceBoost <server.flag[TeaOutpost_DailyInfluenceBoost]||00>
          - define LastDIBoostDate <player.flag[LastDIBoostDate]||00>
          - define CurrentDate <util.date.time.year><util.date.time.month.replace[regex:^(?!..)].with[0]><util.date.time.day.replace[regex:^(?!..)].with[0]>
          - define CurrentTime <util.date.time.hour><util.date.time.minute.replace[regex:^(?!..)].with[0]>
          - if <def[Confirmation]> == No {
            - narrate "<proc[msgCommand].context[<&lb>Outpost<&rb> Click to confirm <%BoostTeam%><def[BoostDirection]> <def[DailyInfluenceBoost]> <def[BoostDirection].replace[add].with[to].replace[subtract].with[from]> <server.flag[%BoostTeam%DisplayName].first.replace[_].with[<&sp>]||Wild> in <def[OutpostID]>!|outpost boost %BoostDirection% %OutpostID% %BoostTeam% Confirmation|outpost boost %BoostDirection% %OutpostID% %BoostTeam% Confirmation]>" targets:<player>
            }
            else {
              - if <def[LastDIBoostDate]> == <def[CurrentDate]> {
                - narrate "<gold>Next Boost in <el@24.sub[<util.date.time.hour>]> hours." targets:<player>
                }
                else {
                  - flag <player> LastDIBoostDate:<util.date.time.year><util.date.time.month.replace[regex:^(?!..)].with[0]><util.date.time.day.replace[regex:^(?!..)].with[0]>
                  - if <def[BoostDirection]> == add {
                    - flag server %OutpostID%InfluencePoints%BoostTeam%:+:<def[DailyInfluenceBoost]>
                    - if !<server.flag[%OutpostID%InfluenceList].as_list.contains[%BoostTeam%]||false> {
                      - flag server %OutpostID%InfluenceList:->:%BoostTeam%
                      }
                    }
                    else if <def[BoostDirection]> == subtract {
                      - flag server %OutpostID%InfluencePoints%BoostTeam%:-:<def[DailyInfluenceBoost]>
                      }
                  - execute as_player "outpost influence"
                  }
            #  - narrate "<def[BoostDirection]> <def[OutpostID]> <def[BoostTeam]> <def[Confirmation]>" targets:<player>


              }
   ## REPORT ---
        - case report:
          - ^narrate "<gold><bold>[OUTPOST] REPORT" targets:<player>
        #  - ^narrate "<gray>- If you're having any kind of trouble with Outposts," targets:<player>
         # - ^narrate "" targets:<player>
          - ^narrate "<proc[msgUrl].context[<yellow> <&gt> Bug Reports and Other Issues|www.rcommunitymc.com/forum/m/37643997/viewthread/28877584-outpost-by-tea-bug-reports|<yellow> <&gt> Click to open <white>Bug Reports and Other Issues<yellow> link ]>" targets:<player>
         # - ^narrate "" targets:<player>
          - ^narrate "<proc[msgUrl].context[<gold> <&gt> Outpost Discussion Thread|www.rcommunitymc.com/forum/page/1/m/37643997/viewthread/28779448-outpost-by-tea-discussion|<gold> <&gt> Click to open <white>Outpost Discussion Thread<gold> link ]>" targets:<player>
        #  - ^narrate "" targets:<player>
          - ^narrate "<proc[msgUrl].context[<yellow> <&gt> Public Development Trello|trello.com/b/GR1p8CAR/public-development|<yellow> <&gt> Click to open <white>Public Development Trello<yellow> link ]>" targets:<player>
        #  - ^narrate "" targets:<player>
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost|<gold> <&lt><&lt> Back to Outpost Menu ]>" targets:<player>
          - ^narrate "" targets:<player>


   ## TEAM ---
        - case team:
          - define PlayerTeam <player.flag[RaceColour].to_titlecase||Gray>
          - define PlayerColour <player.flag[RaceColourSecondary].to_titlecase||Gray>
          - define TeamName <server.flag[%PlayerTeam%DisplayName]||Wild>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> <%PlayerTeam%><def[TeamName].to_uppercase> / <def[PlayerTeam].to_uppercase> <gold>TEAM INFO" targets:<player>
        #  - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable content!]><proc[msgHover].context[<gold>Nation Default|<dark_aqua>Switch back to your Nation (Free)<&nl><%PlayerTeam%>%TeamName% / %PlayerTeam%<%PlayerColour%> / %PlayerColour%]>" targets:<player>
          - if !<server.flag[%PlayerTeam%AllyList].is_empty||true> || <server.flag[%PlayerTeam%HasWildAlly]||false> {
            - ^narrate "<proc[msgHover].context[<gold> x |<gold>This line has clickable content!]><proc[msgCommand].context[<gold>Allies List<&co>|outpost teamally|<%PlayerTeam%> Click to add Ally Teams! ]>" targets:<player>
            - foreach <script.constant[colourlist]> {
              - if %PlayerTeam% == %value% {
                - foreach next
                }
              - if <server.flag[%PlayerTeam%AllyList].contains[%value%]> {
                - ^narrate "<gold> <&gt><%value%> <server.flag[%value%DisplayName]||Wild> / %value%  <proc[msgCommand].context[<%value%><bold>x|outpost removeteamally %PlayerTeam% %value%|<%value%>Click to remove <server.flag[%value%DisplayName]||Wild> as an ally.]>" targets:<player>
                }
                else {
                  - define WildsRandom %value%|<def[WildsRandom]||>
                  - foreach next
                  }
              }
            - if <server.flag[%PlayerTeam%HasWildAlly]||false> {
              - define WildsColour <def[WildsRandom].as_list.random||Gray>
              - ^narrate "<gold> <&gt><%WildsColour%> The Wilderness / All Colours  <proc[msgCommand].context[<%WildsColour%><bold>x|outpost removeteamally %PlayerTeam% wild|<%WildsColour%>Click to remove the Wilderness as an ally.]>" targets:<player>

              }
            - ^narrate "" targets:<player>
            }
            else {
              - ^narrate "<proc[msgHover].context[<gold> x |<gold>This line has clickable content!]><proc[msgCommand].context[<gold>Allies List<&co> <gray>None|outpost teamally|<%PlayerTeam%>Click to add Ally Teams!]>" targets:<player>
            }
            
          - if <server.flag[%PlayerTeam%WarTarget]||Empty> != Empty {
            - define WarTargetColour <server.flag[%PlayerTeam%WarTarget]||Gray>
            - define WarTargetDisplayName <server.flag[%WarTargetColour%DisplayName]||Wild>

            - ^narrate "<proc[msgHover].context[<gold> x |<gold>This line has clickable content!]><proc[msgCommand].context[<gold>War Target<&co>|outpost teamenemy|<%PlayerTeam%> Click to choose a War Target! ]>" targets:<player>
            - ^narrate "<gold> <&gt><%WarTargetColour%> %WarTargetDisplayName% / %WarTargetColour%  <proc[msgCommand].context[<%WarTargetColour%><bold>x|outpost removeteamenemy %PlayerTeam% %WarTargetColour%|<%WarTargetColour%>Click to remove <server.flag[%WarTargetColour%DisplayName]||Wild> as a War Target.]>" targets:<player>
            - ^narrate "" targets:<player>

            }
            else {
              - ^narrate "<proc[msgHover].context[<gold> x |<gold>This line has clickable content!]><proc[msgCommand].context[<gold>War Target<&co> <gray>None|outpost teamenemy|<%PlayerTeam%>Click to choose a War Target!]>" targets:<player>
            }

          - if !<server.flag[%PlayerTeam%SupporterList].is_empty||true> {
            - ^narrate "<proc[msgHover].context[<gray> <&gt> <gold>Supporter List<&co>|<gold>These Teams have declared you as an Ally!]>" targets:<player>
            - foreach <script.constant[colourlist]> {
              - if %PlayerTeam% == %value% {
                - foreach next
                }
              - if <server.flag[%PlayerTeam%SupporterList].contains[%value%]> {
                - ^narrate "<proc[msgHover].context[<%value%> <&gt> <server.flag[%value%DisplayName]||Wild> / %value%|<%value%><server.flag[%value%DisplayName]||Wild> has chosen you as an Ally!]>" targets:<player>
                }
                else {
                  - foreach next
                  }
              }

            }
            else {
              - ^narrate "<proc[msgHover].context[<gray> <&gt> <gold>Supporter List<&co> <gray>None|<gold>You have not been chosen as an Ally.]>" targets:<player>
            }

          - if !<server.flag[%PlayerTeam%EnemyList].is_empty||true> {
            - ^narrate "<proc[msgHover].context[<gray> <&gt> <gold>Opponent List<&co>|<gold>These Teams have declared you as their War Target!]>" targets:<player>
            - foreach <script.constant[colourlist]> {
              - if %PlayerTeam% == %value% {
                - foreach next
                }
              - if <server.flag[%PlayerTeam%EnemyList].contains[%value%]> {
                - ^narrate "<proc[msgHover].context[<%value%> <&gt> <server.flag[%value%DisplayName]||Wild> / %value%|<%value%><server.flag[%value%DisplayName]||Wild> has chosen you as their War Target!]>" targets:<player>
                }
                else {
                  - foreach next
                  }
              }

            }
            else {
              - ^narrate "<proc[msgHover].context[<gray> <&gt> <gold>Enemy List<&co> <gray>None|<gold>You have not been chosen as a War Target.]>" targets:<player>
            }
         # - ^narrate "" targets:<player>
          #  - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable content!]><proc[msgCommand].context[<gold>Team / Team Colour<&co> <%PlayerTeam%><bold>%TeamName% / %PlayerTeam%|outpost teamcolour|<%PlayerTeam%>You can capture Outposts for any Team!<&nl><%PlayerTeam%>Click to switch Teams!]>" targets:<player>
        #  - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable content!]><proc[msgCommand].context[<gold>Personal Colour<&co> <%PlayerColour%><bold>%PlayerColour%|outpost playercolour|<%PlayerColour%>Personal colours are decorative.<&nl><%PlayerColour%>They do not affect your Team.<&nl><%PlayerColour%>Click to switch Personal Colours!]>" targets:<player>
   #       - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable content!]><proc[msgCommand].context[<gold>War Target<&co> <%PlayerColour%><bold>%PlayerColour%|outpost playercolour|<%PlayerColour%>Personal colours are decorative.<&nl><%PlayerColour%>They do not affect your Team.<&nl><%PlayerColour%>Click to switch Personal Colours!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>MCMMO Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>|toutpost showmcmmo %ManageName%|<dark_aqua>Pick a new MCMMO Focus!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Training Message<&co>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Type a new Message at the end of the command!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <gray><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost showspells %ManageName%|<dark_aqua>Pick a new Spell Effect!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Pick a new Spell Target!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> Current Owner<&co> <gray><server.flag[%OwnerStuff%DisplayName]||%OwnerStuff%> / <%OwnerStuff%>%OwnerStuff% <gray>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
        #  - ^narrate "<gold> <&gt> Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost|<gold>Back to Outpost Menu]>" targets:<player>

   ## TEAM ALLY ---
        - case teamally:
          - define PlayerTeam <player.flag[RaceColour].to_titlecase||Gray>
          - define PlayerColour <player.flag[RaceColourSecondary].to_titlecase||Gray>
          - define TeamName <server.flag[%PlayerTeam%DisplayName]||Wild>
          - define CurrentColour <player.flag[RaceColour]||Gray>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> ADD AN ALLY" targets:<player>
        #  - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable content!]><proc[msgHover].context[<gold>Nation Default|<gold>Switch back to your Nation: Free<&nl><%PlayerTeam%>%TeamName% / %PlayerTeam%<%PlayerColour%> / %PlayerColour%]>" targets:<player>

          - foreach <script.constant[colourlist]> {
            - if %PlayerTeam% == %value% {
              - foreach next
              }
            - if <server.flag[%value%NationName]||Wild> == Wild {
            #  - define WildsNameList <%value%><server.flag[%value%DisplayName]||%value%><&sp><def[WildsNameList]||>
              - define WildsRandom %value%|<def[WildsRandom]||>
              - foreach next
              }
            - if <server.flag[%PlayerTeam%AllyList].contains[%value%]> {
              - foreach next
             # - ^narrate "<proc[msgCommand].context[<%value%><bold> <&gt> <server.flag[%value%DisplayName]||Wild> / %value% ALLY|outpost setteamcolour %value%|<%value%>Confirm <server.flag[%value%DisplayName]||Wild>]>" targets:<player>
              }
              else {
                - ^narrate "<proc[msgCommand].context[<%value%> <&gt> <server.flag[%value%DisplayName]||Wild> / %value%|outpost setteamally %PlayerTeam% %value%|<%value%>Click to add <server.flag[%value%DisplayName]||Wild> as an Ally!]>" targets:<player>
                }
            }
          - define WildsColour <def[WildsRandom].as_list.random||Gold>
          - ^narrate "<proc[msgCommand].context[<%WildsColour%> <&gt> The Wilderness / All Colours|outpost setteamally %PlayerTeam% Wild|<%WildsColour%>Click to add the Wilderness as an Ally!<&nl><&nl><%WildsColour%>THIS WILL ALLOW ALL OUTSIDERS INTO YOUR OUTPOSTS!<&nl><&nl><%WildsColour%>YOUR OUTPOSTS WILL TURN ALL OUTSIDER PERMS ON!]>" targets:<player>
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost team|<gold>Back to Player Options]>" targets:<player>
   ## TEAM ENEMY ---
        - case teamenemy:
          - define PlayerTeam <player.flag[RaceColour].to_titlecase||Gray>
          - define PlayerColour <player.flag[RaceColourSecondary].to_titlecase||Gray>
          - define TeamName <server.flag[%PlayerTeam%DisplayName]||Wild>
          - define CurrentColour <player.flag[RaceColour]||Gray>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> CHOOSE A WAR TARGET" targets:<player>
        #  - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable content!]><proc[msgHover].context[<gold>Nation Default|<gold>Switch back to your Nation: Free<&nl><%PlayerTeam%>%TeamName% / %PlayerTeam%<%PlayerColour%> / %PlayerColour%]>" targets:<player>

          - foreach <script.constant[colourlist]> {
            - if %PlayerTeam% == %value% {
              - foreach next
              }
            - if <server.flag[%PlayerTeam%WarTarget]> == %value% {
            #  - foreach next
              - ^narrate "<proc[msgCommand].context[<%value%><bold> <&gt> <server.flag[%value%DisplayName]||Wild> / %value% CURRENT WAR TARGET|outpost setteamenemy %PlayerTeam% %value%|<%value%>Confirm <server.flag[%value%DisplayName]||Wild>]>" targets:<player>
              }
              else {
                - ^narrate "<proc[msgCommand].context[<%value%> <&gt> <server.flag[%value%DisplayName]||Wild> / %value%|outpost setteamenemy %PlayerTeam% %value%|<%value%>Click to add <server.flag[%value%DisplayName]||Wild> as an War Target!]>" targets:<player>
                }
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost team|<gold>Back to Player Options]>" targets:<player>
   ## SET ALLY ---
        - case setteamally:
          - define AllyName <context.args.get[3].replace[cu@].with[]>
          - define AllyNationName nation@<server.flag[%AllyName%NationName]||Wild>
          - define TeamName <context.args.get[2].replace[cu@].with[]>
        #  - define SkillName <context.args.get[3]>
          - if <def[AllyNationName]> == nation@Wild {
            - flag server %TeamName%HasWildAlly:true
            }
            else {
              - flag server %TeamName%AllyList:->:%AllyName%
              - flag server %TeamName%AllyListAsNations:->:%AllyNationName%
              - flag server %AllyName%SupporterList:->:%TeamName%
              }


          - execute as_player "outpost team"
   ## REMOVE ALLY ---
        - case removeteamally:
          - define AllyName <context.args.get[3].replace[cu@].with[]>
          - define AllyNationName nation@<server.flag[%AllyName%NationName]||Wild>

          - define TeamName <context.args.get[2].replace[cu@].with[]>
          - if <def[AllyNationName]> == nation@Wild {
            - flag server %TeamName%HasWildAlly:false
            }
            else {
              - flag server %TeamName%AllyList:<-:%AllyName%
              - flag server %TeamName%AllyListAsNations:<-:%AllyNationName%
            
              - flag server %AllyName%SupporterList:<-:%TeamName%
              }
          - execute as_player "outpost team"
   ## SET ENEMY ---
        - case setteamenemy:
          - define EnemyName <context.args.get[3].replace[cu@].with[]>
          - define TeamName <context.args.get[2].replace[cu@].with[]>
        #  - define SkillName <context.args.get[3]>
          - flag server %TeamName%WarTarget:%EnemyName%
          - flag server %EnemyName%EnemyList:->:%TeamName%

          - execute as_player "outpost team"
   ## REMOVE ENEMY ---
        - case removeteamenemy:
          - define EnemyName <context.args.get[3].replace[cu@].with[]>
          - define TeamName <context.args.get[2].replace[cu@].with[]>
        #  - define SkillName <context.args.get[3]>
          - flag server %TeamName%WarTarget:!
          - flag server %EnemyName%EnemyList:<-:%TeamName%
          - execute as_player "outpost team"

   ## PLAYER ---
        - case player:
          - define PlayerTeam <player.flag[RaceColour].to_titlecase||Gray>
          - define PlayerColour <player.flag[RaceColourSecondary].to_titlecase||Gray>
          - define TeamName <server.flag[%PlayerTeam%DisplayName]||Wild>
         # - ^narrate "" targets:<player>
          - ^narrate "<gold><bold><&lb>OUTPOST<&rb> PLAYER: <player.name.to_uppercase>" targets:<player>
        #  - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable content!]><proc[msgHover].context[<gold>Nation Default|<dark_aqua>Switch back to your Nation (Free)<&nl><%PlayerTeam%>%TeamName% / %PlayerTeam%<%PlayerColour%> / %PlayerColour%]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<yellow> <&gt> Team / Team Colour<&co> <%PlayerTeam%><bold><def[TeamName].as_list.first.replace[_].with[<&sp>]> / <def[PlayerTeam].as_list.first.replace[_].with[<&sp>]>|outpost teamcolour|<yellow> <&gt> Click to switch Teams <&nl> <%PlayerTeam%><italic>You can capture Outposts for any Team! ]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Personal Colour<&co> <%PlayerColour%><bold><def[PlayerColour].as_list.first.replace[_].with[<&sp>]>|outpost playercolour|<gold> <&gt> Click to switch Personal Colours!<&nl><%PlayerColour%><italic> Personal colours are decorative. <&nl><%PlayerColour%><italic> They do not affect your Team. ]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>MCMMO Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>|toutpost showmcmmo %ManageName%|<dark_aqua>Pick a new MCMMO Focus!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Training Message<&co>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Type a new Message at the end of the command!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <gray><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost showspells %ManageName%|<dark_aqua>Pick a new Spell Effect!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Pick a new Spell Target!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> Current Owner<&co> <gray><server.flag[%OwnerStuff%DisplayName]||%OwnerStuff%> / <%OwnerStuff%>%OwnerStuff% <gray>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
        #  - ^narrate "<gold> <&gt> Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost|<gold> <&lt><&lt> Back to Outpost Menu ]>" targets:<player>
          - ^narrate "" targets:<player>


   ## UPGRADES ---
        - case upgrades:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define ManageDisplay <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>
          - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
          - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> '<%OwnerStuff%><def[ManageDisplay].to_uppercase><gold>' UPGRADES" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Display Name<&co> <gray><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>|toutpost rename %ManageName%<&sp>|rename]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Add Spells|outpost showspells %ManageName% fromupgrades|<gray>Buy a new Spell for this Outpost.<&nl><gray>- Spells are permanent upgrades.<&nl><gray>- Spells will be activated automatically.]>" targets:<player>
          - ^narrate "<proc[msgHover].context[<dark_gray> <&gt> Add Moles & Spies|<dark_aqua>Buy a Mole/Spy for this Outpost.<&nl><dark_aqua>- Moles/Spies give your Team information and control.<&nl><dark_aqua>- Moles/Spies can be removed by Enemy Teams.]>" targets:<player>
          - ^narrate "<proc[msgHover].context[<dark_gray> <&gt> Manage Moles & Spies|<gray>Manage your Teams Moles/Spies.<&nl><gray>- Moles log Outpost activity.<&nl><gray>- Spies let you manage Outposts from a distance.]>" targets:<player>
          - ^narrate "<proc[msgHover].context[<dark_gray> <&gt> Remove Enemy Moles & Spies|<dark_aqua>Check for Enemy Moles/Spies<&nl><dark_aqua>- Spy Checks can remove an Enemy Spy.<&nl><dark_aqua>- Mole Checks can remove both a Mole and a Spy.]>" targets:<player>
       #   - ^narrate "<proc[msgHover].context[<gold> <&gt> Mole Check|Mole Check (Free Spy Check)]>" targets:<player>
          - ^narrate "<proc[msgHover].context[<dark_gray> <&gt> Add Alarm Bells|<gray>Buy Alarm Bells for this Outpost.<&nl><gray>- Alarm Bells will alert you when your Outpost is under attack. (Infinite Range)<&nl><gray>- Alarm Bells are a permanent upgrade.<&nl><gray>- Alarm Bells can be sabotaged by Spies.]>" targets:<player>

   # (buyspells/moles/spies/checks/alarms)
        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>" targets:<player>
      #    - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Training Message<&co>|toutpost setmessage %ManageName%<&sp>|setmessage]>" targets:<player>
        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Message<&co>" targets:<player>
      #    - ^narrate "<gold> <&gt> <gray><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
      #    - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost showspells %ManageName%|toutpost showspells]>" targets:<player>
      #    - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|toutpost showtargets]>" targets:<player>

        #  - ^narrate "<gold> <&gt> Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>" targets:<player>
      #    - ^narrate "<gold> <&gt> Current Owner<&co> <gray><server.flag[%OwnerStuff%DisplayName]||None> / <%OwnerStuff%>%OwnerStuff% <gray>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
      #    - ^narrate "<gold> <&gt> Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
      #    - ^narrate "<proc[msgCommand].context[<dark_aqua><&lt><&lt> RETURN TO OUTPOST LIST|toutpost list|toutpost list]>" targets:<player>
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost here|<gold>Back to Outpost Here]>" targets:<player>

   ## SHOW TEAMCOLOUR ---
        - case teamcolour:
          - define PlayerTeam <player.flag[RaceColour].to_titlecase||Gray>
          - define PlayerColour <player.flag[RaceColourSecondary].to_titlecase||Gray>
          - define TeamName <server.flag[%PlayerTeam%DisplayName]||Wild>
          - define CurrentColour <player.flag[RaceColour]||Gray>
          - define NationName <player.nation.replace[nation@].with[]||Nationless>

       #   - ^narrate "" targets:<player>
          - ^narrate "<gold><bold><&lb>OUTPOST<&rb> CHOOSE A TEAM" targets:<player>
          - define LastTeamSwitch <player.flag[LastTeamSwitch]||0>
          - define CurrentTime <server.current_time_millis.div[50].as_int>
          - define LastTeamSwitchPlusWeek <def[LastTeamSwitch].add[12096000]>
          - define RemainingTime <def[LastTeamSwitchPlusWeek].sub[<def[CurrentTime]>]>
          - if <def[LastTeamSwitch].add[12096000]> <= <def[CurrentTime]> {
            - ^narrate "<aqua><italic>Weekly Free Team Switch Available!" targets:<player>
            - define SwitchCost One<&sp>Free<&sp>Switch!
            }
            else {
              - ^narrate "<aqua><italic>Next Free Team Switch: <d@%RemainingTime%t.as_duration.formatted>" targets:<player>
              - define SwitchCost 10<&sp>000<&sp>Gold
              }
        #  - if <def[NationName]> != Nationless {
          - define NationDefault <server.flag[TeaOutpost_%NationName%DefaultColour]||null>
         #   }
          - if <def[NationDefault]||null> != null {
            - ^narrate "<proc[msgCommand].context[<gold> <&gt> Nation Default<&co> <%NationDefault%>%NationName%|outpost setteamcolour %NationDefault%|<gold> <&gt> Switch back to your Nation: Always Free <&nl><%NationDefault%>%NationName% / %NationDefault%]>" targets:<player>
            }
            else {
              - ^narrate "<proc[msgHover].context[<gold> + Nation Default|<gold> Switch back to your Nation: Always Free <&nl><gray> No default colour has been set for<&co> %NationName% <&nl><dark_gray> Use /outpost report if this is an error. <&nl><dark_gray> Tea.Outpost.%NationName%.Default.Colour ]>" targets:<player>
              }
          - foreach <script.constant[colourlist]> {
            - if <server.flag[%value%NationName]||Wild> != Wild {
              - if %CurrentColour% == %value% {
                - ^narrate "<proc[msgCommand].context[<%value%><bold> <&gt> <server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild> / <def[value].as_list.first.replace[_].with[<&sp>]> <&lt>|outpost setteamcolour %value%|<%value%> <&gt> Confirm <server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild> ]>" targets:<player>
                }
                else {
                  - ^narrate "<proc[msgCommand].context[<%value%> <&gt> <server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild> / <def[value].as_list.first.replace[_].with[<&sp>]>|outpost setteamcolour %value%|<%value%> <&gt> Switch to <server.flag[%value%DisplayName].first.replace[_].with[<&sp>]||Wild><&co> <def[SwitchCost]> ]>" targets:<player>
                  }
              }
            }
          - foreach <script.constant[colourlist]> {
            - if <server.flag[%value%NationName]||Wild> == Wild {
              - if %CurrentColour% == %value% {
                - ^narrate "<proc[msgCommand].context[<%value%><bold> <&gt> <server.flag[%value%DisplayName]||Wild> / <def[value].as_list.first.replace[_].with[<&sp>]> <&lt>|outpost setteamcolour %value%|<%value%> <&gt> Confirm <server.flag[%value%DisplayName]||Wild> ]>" targets:<player>
                }
                else {
                  - ^narrate "<proc[msgCommand].context[<%value%> <&gt> <server.flag[%value%DisplayName]||Wild> / <def[value].as_list.first.replace[_].with[<&sp>]>|outpost setteamcolour %value%|<%value%> <&gt> Switch to <server.flag[%value%DisplayName]||Wild><&co> <def[SwitchCost]> ]>" targets:<player>
                  }
              }
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost player|<gold> <&lt><&lt> Back to Player Options ]>" targets:<player>
          - ^narrate "" targets:<player>

   ## SET COLOUR ---
        - case setteamcolour:
          - define ColourName <context.args.get[2].replace[cu@].with[]>
          - define LeavingColour <player.flag[RaceColour]||Gray>
          - define NationName <player.nation.replace[nation@].with[]||Nationless>
          - define NationDefault <server.flag[TeaOutpost_%NationName%DefaultColour]||null>
          - if <def[NationDefault]||null> != null && <def[ColourName]> == <def[NationDefault]> || <def[LeavingColour]> == <def[ColourName]> {
            - narrate "<gold>That's free!" targets:<player>
            - ^log "<player.name> %LeavingColour% to %ColourName% 0 NationDefault" file:plugins/Denizen/outpost/TEAMSWITCH_LOGS.yml

            }
            else {
              - if <player.flag[TeaOutpostBypass]||false> == true {
                - narrate "<gold>Bypass? That's free!" targets:<player>
                - ^log "<player.name> %LeavingColour% to %ColourName% 0 Bypass" file:plugins/Denizen/outpost/TEAMSWITCH_LOGS.yml

                }
                else {
                  - define LastTeamSwitch <player.flag[LastTeamSwitch]||0>
                  - define CurrentTime <server.current_time_millis.div[50].as_int>
                  - if <def[LastTeamSwitch].add[12096000]> <= <def[CurrentTime]> {
                    - narrate "<gold>Free week switch!" targets:<player>
                    - ^log "<player.name> %LeavingColour% to %ColourName% 0 FreeWeekly" file:plugins/Denizen/outpost/TEAMSWITCH_LOGS.yml

                    }
                    else {
                      - narrate "<gold>That'll cost you!" targets:<player>
                      - ^log "<player.name> %LeavingColour% to %ColourName% <server.flag[TeaOutpost_TeamSwitchCost]||00>" file:plugins/Denizen/outpost/TEAMSWITCH_LOGS.yml
                      }
                  }
              }
          - flag <player> LastTeamSwitch:<server.current_time_millis.div[50].as_int>
          - flag server %LeavingColour%PlayerList:<-:<player>
          - flag server %ColourName%PlayerList:->:<player>
        #  - define SkillName <context.args.get[3]>
          - flag <player> RaceColour:%ColourName%
          - execute as_player "outpost player"
   ## SHOW COLOUR ---
        - case playercolour:
          - define CurrentColour <player.flag[RaceColourSecondary]||Gray>
        #  - ^narrate "" targets:<player>
          - ^narrate "<gold><bold><&lb>OUTPOST<&rb> CHOOSE YOUR COLOUR" targets:<player>
          - foreach <script.constant[colourlist]> {
            - if %CurrentColour% == %value% {
              - ^narrate "<proc[msgCommand].context[<%value%><bold> <&gt> <def[value].as_list.first.replace[_].with[<&sp>]> <&lt>|outpost setplayercolour %value%|<%value%> <&gt> Confirm <def[value].as_list.first.replace[_].with[<&sp>]> ]>" targets:<player>
              }
              else {
                - ^narrate "<proc[msgCommand].context[<%value%> <&gt> <def[value].as_list.first.replace[_].with[<&sp>]>|outpost setplayercolour %value%|<%value%> <&gt> Select <def[value].as_list.first.replace[_].with[<&sp>]><&co> FREE ]>" targets:<player>
                }
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> Back|outpost player|<gold> <&lt><&lt> Back to Player Options ]>" targets:<player>
          - ^narrate "" targets:<player>

   ## SET COLOUR ---
        - case setplayercolour:
          - define ColourName <context.args.get[2].replace[cu@].with[]>
        #  - define SkillName <context.args.get[3]>
          - flag <player> RaceColourSecondary:%ColourName%
          - execute as_player "outpost player"

        - case confirm:
         # - announce "<player.flag[TeaOutpostGoodSpotCheck]>"
          - if <player.flag[OutpostCreationInProgress]||false> {
            - narrate "<dark_aqua><&lb>OUTPOST<&rb> Outpost in progress. Thank you for your patience." targets:<player>
            - queue clear
            }
          - if <player.flag[CreatingTeaOutpost]||false> == false {
            - ^narrate "<gold><&lb>OUTPOST<&rb> Starting location finder, please reconfirm." targets:<player>
           # - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Obsidian blocks must be on the surface." targets:<player>
            - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>/toutpost confirm]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>/toutpost cancel]> <dark_aqua>this location." targets:<player>
            - flag <player> CreatingTeaOutpost:true
            - run TeaOutpost_Task
            - queue clear
            }
     #     - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.cuboids>]||false> == true {
     #       - ^narrate "<gold><&lb>OUTPOST<&rb> There's already an outpost here!" targets:<player>
     #       - ^narrate "<gold><&lb>OUTPOST<&rb> Please choose a better location." targets:<player>
     #       - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>/toutpost confirm]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>/toutpost cancel]> <dark_aqua>this location." targets:<player>
     #       - queue clear
     #     }
          - if <player.flag[TeaOutpostGoodSpotCheck]||false> != true {
          #  - ^narrate "<gold><&lb>OUTPOST<&rb> Obsidian blocks must be on the surface." targets:<player>
            - ^narrate "<gold><&lb>OUTPOST<&rb> Please choose a better location." targets:<player>
            - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>/toutpost confirm]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>/toutpost cancel]> <dark_aqua>this location." targets:<player>
            - queue clear
          }
        #  - if <player.location.cuboids.contains_any[<server.flag[TeaOutpostList].as_list>]> == true {

          - flag <player> OutpostCreationInProgress:true
          - narrate "<dark_aqua><&lb>OUTPOST<&rb> Creating outpost! Please stand by." targets:<player>
          - flag <player> CreatingTeaOutpost:false
          - run TeaOutpost_CreationTask
        - case start:
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Please choose a location." targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Obsidian blocks must be on the surface." targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>/toutpost confirm]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>/toutpost cancel]> <dark_aqua>this location." targets:<player>
          - if <player.flag[CreatingTeaOutpost]||false> == false {
            - flag <player> CreatingTeaOutpost:true
            - run TeaOutpost_Task
            }
   ## MANAGE ---
        - case manage:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
          - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> MANAGING '<gray><def[ManageName].to_uppercase><gold>'" targets:<player>
          - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Display Name<&co> <gray><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>|toutpost rename %ManageName%<&sp>|rename]>" targets:<player>
          - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>MCMMO Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>|toutpost showmcmmo %ManageName%|toutpost showmcmmo]>" targets:<player>

        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>" targets:<player>
          - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Training Message<&co>|toutpost setmessage %ManageName%<&sp>|setmessage]>" targets:<player>
        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Message<&co>" targets:<player>
          - ^narrate "<gold> <&gt> <gray><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
          - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost showspells %ManageName%|toutpost showspells]>" targets:<player>
          - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|toutpost showtargets]>" targets:<player>

        #  - ^narrate "<gold> <&gt> Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>" targets:<player>
          - ^narrate "<gold> <&gt> Current Owner<&co> <gray><server.flag[%OwnerStuff%DisplayName]||None> / <%OwnerStuff%>%OwnerStuff% <gray>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
          - ^narrate "<gold> <&gt> Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<dark_aqua><&lt><&lt> RETURN TO OUTPOST LIST|toutpost list|toutpost list]>" targets:<player>
          
   ## RENAME ---
        - case rename:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NewNameList <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list>
          - define NewNameSize <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list.size>
          - define repeatcount 3
          - define FlagName <context.args.get[3].replace[,].with[;].replace[$].with[S]||null>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<Dark_Red><&lb>OUTPOST<&rb> Capture this Outpost to make changes.|<gray>Only <%ManageColour%>%ManageDisplay% <gray>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - if <player.flag[TeaOutpostKingPass]||false> != true && <player.flag[TeaOutpostBypass]||false> != true && <player.flag[Tea%ManageName%Pass]||false> != true {
            - ^narrate "<proc[msgHover].context[<Dark_Red><&lb>OUTPOST<&rb> Only Nation Kings can do Name Changes.|<Dark_Red>Access Denied. Please contact Tea for support.<&nl><dark_gray>Tea.Outpost.Bypass<&nl><dark_gray>Tea.Outpost.King.Pass<&nl><dark_gray>Tea.%ManageName%.Pass]>" targets:<player>
            - queue clear
            }
          - if %FlagName% == null {
            - ^narrate "<Dark_Red><&lb>OUTPOST<&rb>Please type a name after the Outpost ID." targets:<player>
            - queue clear
            }

         # - flag server %ManageName%DisplayName:clear
          - repeat <def[NewNameSize].sub[1].as_int> {
            - define repeatcount <def[repeatcount].add[1].as_int>
            - define FlagName %FlagName%<&sp><context.args.get[%repeatcount%].replace[,].with[;].replace[$].with[S]>
          #  - define FlagName <def[FlagName]||>%NewName%<&sp>
           # - flag server %ManageName%DisplayName:%FlagName%<&sp>%value%
          }
          - flag server %ManageName%DisplayName:%FlagName%

         # - define NewName <%NewName%.replace[|].with[]>
        #  - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
        #  - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
     ##     - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <green>Renaming <dark_aqua>'<aqua>%ManageName%<dark_aqua>' to '<green>%FlagName%<dark_aqua>'." targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <proc[msgCommand].context[<aqua>Reopen Outpost List?|toutpost list|toutpost list]>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Display Name<&co> <aqua><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Training Focus<&co> <aqua><server.flag[%ManageName%TrainingFocus]||None>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Training Message<&co>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <aqua><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Spell Effect<&co> <aqua><server.flag[%ManageName%SpellEffect]||None>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Current Owner<&co> <aqua><server.flag[%OwnerStuff%DisplayName]||None> / <%OwnerStuff%>%OwnerStuff% / <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Set<&sp>Name|%FlagName%
          - execute as_player "outpost here"
        #  - execute as_player "outpost manage cu@%ManageName%"
         # - narrate "<dark_aqua>"
   ## SET MESSAGE --- 
        - case setmessage:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Capture this Outpost to make changes.|<gray>Only <%ManageColour%>%ManageDisplay% <gray>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - define NewMessageList <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list>
          - define NewMessageSize <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list.size>
          - define repeatcount 3
          - define FlagName <context.args.get[3].replace[,].with[;].replace[$].with[S]>
          - repeat <def[NewMessageSize].sub[1].as_int> {
            - define repeatcount <def[repeatcount].add[1].as_int>
            - define FlagName %FlagName%<&sp><context.args.get[%repeatcount%].replace[,].with[;].replace[$].with[S]>
          }
          - flag server %ManageName%TrainingMessage:%FlagName%
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Message|%FlagName%

          #- ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <green>Setting message of <dark_aqua>'<aqua>%ManageName%<dark_aqua>' to '<green>%FlagName%<dark_aqua>'." targets:<player>
          - execute as_player "outpost here"

   ## SHOW MCMMO ---
        - case showmcmmo:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Capture this Outpost to make changes.|<gray>Only <%ManageColour%>%ManageDisplay% <gray>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - if <player.flag[TeaOutpostKingPass]||false> != true && <player.flag[TeaOutpostBypass]||false> != true && <player.flag[Tea%ManageName%Pass]||false> != true {
            - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Only Nation Kings can change McMMO Focus.|<dark_aqua>Access Denied. Please contact Tea for support.<&nl><dark_gray>Tea.Outpost.Bypass<&nl><dark_gray>Tea.Outpost.King.Pass<&nl><dark_gray>Tea.%ManageName%.Pass]>" targets:<player>
            - queue clear
            }
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> '<%ManageColour%><server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST><gold>' MCMMO FOCUS" targets:<player>
          - define LineColour gray
          - foreach <script.constant[mcmmolist]> {
            - if <server.flag[%ManageName%TrainingFocus]> == %value% {
              - ^narrate "<proc[msgCommand].context[<green> <&gt> <bold>%value%|outpost setmcmmo %ManageName% %value%|<green>Confirm %value%]>" targets:<player>
              }
              else {
                - ^narrate "<proc[msgCommand].context[<%LineColour%> <&gt> %value%|outpost setmcmmo %ManageName% %value%|<%LineColour%>Select %value%]>" targets:<player>
                }
            - if <def[LineColour]||dark_aqua> == dark_aqua {
              - define LineColour gray
              }
              else {
                - define LineColour dark_aqua
         
                }
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost here|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>]>" targets:<player>

   ## SET MCMMO ---
        - case setmcmmo:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define SkillName <context.args.get[3]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<dark_aqua><&gt> Capture this Outpost to make changes.|<white>Only <%ManageColour%>%ManageDisplay% <white>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - if <player.flag[TeaOutpostKingPass]||false> != true && <player.flag[TeaOutpostBypass]||false> != true && <player.flag[Tea%ManageName%Pass]||false> != true {
            - ^narrate "<proc[msgHover].context[<dark_aqua><&gt> Only Nation Kings can do Name Changes.|<dark_aqua>Access Denied. Please contact Tea for support.<&nl><dark_gray>Tea.Outpost.Bypass<&nl><dark_gray>Tea.Outpost.King.Pass<&nl><dark_gray>Tea.%ManageName%.Pass]>" targets:<player>
            - queue clear
            }
          - flag server %ManageName%TrainingFocus:%SkillName%
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Set<&sp>McMMO|%SkillName%
          - execute as_player "outpost here"

   ## SHOW SPELLS ---
        - case showspells:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
         # - if %ManageColour% != <player.flag[RaceColour]||Gray> {
         #   - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
         #   - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Capture this Outpost to make changes.|<gray>Only <%ManageColour%>%ManageDisplay% <gray>can make changes to this Outpost.]>" targets:<player>
         #   - queue clear
         #   }
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> '<%ManageColour%><server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST><gold>' AVAILABLE SPELL LIST" targets:<player>
          - define SpellCount 1
          - define ColourSwitch gray
          - ^foreach <script.constant[spelllist]> {
            - ^if <server.flag[%ManageName%SpellsAdded].as_list.contains[%value%]||false> == true {
             # - ^narrate "<proc[msgHover].context[<dark_gray><&sp><&gt><&sp><bold><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|<dark_gray>Already added!]>" targets:<player>
              - ^define SpellCount <def[SpellCount].add[1].as_int>
              - ^foreach next
              }
              else {
             #   - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
             #   - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
             #   - define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]>
             #  - ^narrate "<proc[msgCentered].context[30|<%ColourSwitch%><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]><%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>" targets:<player>
             #  - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
             #  - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
               - ^define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><&sp><script.constant[spelllist].as_list.get[%SpellCount%].replace[_].with[<&sp>]||Error>|outpost<&sp>buyspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%].trim||Error>|<%ColourSwitch%>Buy<&sp>%value%<&co><&sp>10<&sp>000<&sp>Gold<&nl><%ColourSwitch%>Spells<&sp>will<&sp>activated<&sp>automatically.]>
             #  - ^define SpellTwo <proc[msgCommand].context[<%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>]>
               - ^narrate "%SpellOne%" targets:<player>
              # - ^narrate "<proc[msgCentered2].context[190|%SpellOne%]>|<proc[msgCentered3].context[190|%SpellTwo%]>" targets:<player>
                }
            - ^if %ColourSwitch% == dark_aqua {
              - ^define ColourSwitch gray
              }
              else {
                - ^define ColourSwitch dark_aqua
              }
            - ^define SpellCount <def[SpellCount].add[1].as_int>
            }
        #  - if <context.args.get[3]||Regular> == fromupgrades {
        #    - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost upgrades %ManageName%|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost> Upgrades]>" targets:<player>
        #    }
        #    else {
        #      - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost here|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>]>" targets:<player>
        #      }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost upgrades %ManageName%|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost> Upgrades]>" targets:<player>
   ## SET SPELLS ---
        - case buyspell:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define SpellName <context.args.get[3]>
          - inject TeaOutpost_LocationCheckTask
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
          #  - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
          #  - ^narrate "<proc[msgHover].context[<dark_aqua><&gt> Capture this Outpost to make changes.|<white>Only <%ManageColour%>%ManageDisplay% <white>can make changes to this Outpost.]>" targets:<player>
            - flag server %ManageName%SpellsAdded:->:%SpellName%
            - flag server %ManageName%SpellEffect:%SpellName%
            - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Buy<&sp>Spell|%SpellName%
            - execute as_player "outpost here"
            }
            else {
              - flag server %ManageName%SpellsAdded:->:%SpellName%
              - flag server %ManageName%SpellEffect:%SpellName%
              - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Buy<&sp>Spell|%SpellName%
            #  - execute as_player "outpost spells %ManageName%"
              - execute as_player "outpost here"
              }
        #  - flag server %ManageName%SpellsAdded:->:%SpellName%
        #  - flag server %ManageName%SpellEffect:%SpellName%
        #  - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Buy<&sp>Spell|%SpellName%
        #  - execute as_player "outpost spells %ManageName%"

   ## SPELLS ---
        - case spells:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Capture this Outpost to make changes.|<gray>Only <%ManageColour%>%ManageDisplay% <gray>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> '<%ManageColour%><server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST><gold>' SPELL EFFECT" targets:<player>
          - define SpellCount 1
          - define ColourSwitch gray
          - ^foreach <server.flag[%ManageName%SpellsAdded].as_list.deduplicate||Bad_Luck> {
            - ^if <server.flag[%ManageName%SpellEffect]> == %value% {
              - ^define SpellOne <proc[msgCommand].context[<green><&sp><&gt><&sp><bold><def[value].replace[_].with[<&sp>]>|outpost<&sp>setspell<&sp>%ManageName%<&sp>%value%|<green>Confirm<&sp>%value%]>
             # - ^define SpellTwo <proc[msgCommand].context[<%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>]>
              - ^narrate "%SpellOne%" targets:<player>
              }
                else {
               #   - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
               #   - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
               #   - define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]>
               #  - ^narrate "<proc[msgCentered].context[30|<%ColourSwitch%><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]><%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>" targets:<player>
               #  - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
               #  - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
                 - ^define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><&sp><def[value].replace[_].with[<&sp>]>|outpost<&sp>setspell<&sp>%ManageName%<&sp>%value%|<%ColourSwitch%>Select<&sp>%value%]>
               #  - ^define SpellTwo <proc[msgCommand].context[<%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>]>
                 - ^narrate "%SpellOne%" targets:<player>
                # - ^narrate "<proc[msgCentered2].context[190|%SpellOne%]>|<proc[msgCentered3].context[190|%SpellTwo%]>" targets:<player>
                  }
            - ^if %ColourSwitch% == dark_aqua {
              - ^define ColourSwitch gray
              }
              else {
                - ^define ColourSwitch dark_aqua
              }
            - ^define SpellCount <def[SpellCount].add[1].as_int>
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost here|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>]>" targets:<player>
   ## SET SPELLS ---
        - case setspell:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define SpellName <context.args.get[3]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<dark_aqua><&gt> Capture this Outpost to make changes.|<white>Only <%ManageColour%>%ManageDisplay% <white>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - flag server %ManageName%SpellEffect:%SpellName%
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Set<&sp>Spell|%SpellName%

          - execute as_player "outpost here"

   ## SHOW TARGETS ---
        - case showtargets:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Capture this Outpost to make changes.|<gray>Only <%ManageColour%>%ManageDisplay% <gray>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - define ColourSwitch gray
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>OUTPOST<&rb> '<%ManageColour%><server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST><gold>' SPELL TARGETS" targets:<player>
          - foreach <script.constant[targetlist]> {
            - if <server.flag[%ManageName%SpellTargets]||ALL> == %value% {
              - ^narrate "<green> <&gt> <proc[msgCommand].context[<green><bold>%value%|outpost settargets %ManageName% %value%|<green>Confirm %value%]>" targets:<player>
              }
              else {
                - ^narrate "<%ColourSwitch%> <&gt> <proc[msgCommand].context[<%ColourSwitch%>%value%|outpost settargets %ManageName% %value%|<%ColourSwitch%>Select %value%]>" targets:<player>
                }
            - ^if %ColourSwitch% == dark_aqua {
              - ^define ColourSwitch gray
              }
              else {
                - ^define ColourSwitch dark_aqua
              }
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost here|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>]>" targets:<player>

   ## SET TARGETS ---
        - case settargets:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define TargetName <context.args.get[3]>
          - define ManageColour <server.flag[Ownerof%ManageName%]||Gray>
          - inject TeaOutpost_LocationCheckTask
          - if %ManageColour% != <player.flag[RaceColour]||Gray> {
            - define ManageDisplay <server.flag[%ManageColour%DisplayName]||Wild>
            - ^narrate "<proc[msgHover].context[<dark_aqua><&gt> Capture this Outpost to make changes.|<white>Only <%ManageColour%>%ManageDisplay% <white>can make changes to this Outpost.]>" targets:<player>
            - queue clear
            }
          - flag server %ManageName%SpellTargets:%TargetName%
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Set<&sp>Targets|%TargetName%

          - execute as_player "outpost here"

    #    - case delete:
    #      - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Deleting <context.args.get[2]>" targets:<player>
    #      - run TeaOutpost_DeletionTask def:<context.args.get[2]>
    #    - case agree:
    #      - define AgreeKeyword <context.args.get[2]>
    #      - define AgreeKeywordColour <context.args.get[3]>
    #      - define AgreeCommand <context.args.get[4]>
    #      - define AgreeCommandVariable <context.args.get[5]>
    #      - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Please click here to <proc[msgCommand].context[<%AgreeKeywordColour%>CONFIRM|toutpost %AgreeCommand% %AgreeCommandVariable%|<green>/toutpost %AgreeCommand% %AgreeCommandVariable%]> <dark_aqua>%AgreeKeyword%." targets:<player>
    #    - case teleport:
    #      - define Destination <context.args.get[2]>
    #      - execute as_player "teleport <player.name> <%Destination%.center.x.as_int> <%Destination%.center.y.as_int> <%Destination%.center.z.as_int>"

   ## LIST ---
        - case list:
          - if <context.args.get[2].as_int||1> == <context.args.get[2]||1> && <context.args.get[2].as_int||1> > 0 {
            - define PageNumber <context.args.get[2]||1>
            }
            else {
              - define PageNumber 1
              }
          - define NextPage <def[PageNumber].add[1].as_int>
       #   - if <server.flag[TeaOutpostList].size> < <math.as_int:%NextPage%*10> {
       #     - define NextPage %PageNumber%
       #     }
          - define PreviousPage <def[PageNumber].sub[1].as_int>
          - define ListEndInt <def[PageNumber].mul[10].as_int>
          - if <server.flag[TeaOutpostList].size> < %ListEndInt% {
            - define ListEndInt <server.flag[TeaOutpostList].size>
            - define PageNumber <def[ListEndInt].div[10].round_down.add[1]||1>
            - define ListStartInt <def[PageNumber].sub[1].mul[10].add[1]>

            - define NextPage %PageNumber%
            - define PreviousPage <def[PageNumber].sub[1]>

            }
            
      #    - define ListFullCount <proc[TeaOutpost_get_edits].context[%OutpostID%|1|100]||li@>
      #    - if <def[ListFullCount].size> < %ListEndInt% {
      #      - define ListEndInt <def[ListFullCount].size>
      #      - define PageNumber <def[ListEndInt].div[10].round_down.add[1]||1>
      #      - define ListStartInt <def[PageNumber].sub[1].mul[10].add[1]>
      #      - define NextPage %PageNumber%
      #      - define PreviousPage <math.as_int:%PageNumber%-1>
      #
      #      - define ListEdits <proc[TeaOutpost_get_edits].context[%OutpostID%|%ListStartInt%|%ListEndInt%]||li@>
      #      }
            
            
            
          - define ListStartInt <math.as_int:((%PageNumber%-1)*10)+1>
          - if <def[ListStartInt]> < 1 {
            - define ListStartInt 1
            }
       #   - narrate "" targets:<player>
          - narrate "<gold><bold><&lb>OUTPOST<&rb> LIST: <green><bold><server.flag[TeaOutpostList].size><gold><bold> OUTPOSTS" targets:<player>
          - foreach <server.flag[TeaOutpostList].as_list.get[%ListStartInt%].to[%ListEndInt%]> {
            - define ActualName <def[value].replace[cu@].with[]>
            - define CuboidThing %value%
            - define Colour <server.flag[Ownerof<def[CuboidThing].replace[cu@].with[]>].replace[cu@].with[].first||Gray>
            - define ColourSecondary <server.flag[Ownerof<def[CuboidThing].replace[cu@].with[]>secondary].replace[cu@].with[].first||Gray>

           # - if <def[LineColour]||dark_aqua> == dark_aqua {
           #   - define LineColour aqua
           #   }
           #   else {
           #     - define LineColour dark_aqua
           #
           #     }
          # # - narrate "<%LineColour%><&lb><server.flag[TeaOutPostList].find[%value%]><&rb> <def[value].replace[cu@].with[]><&co><&sp><proc[msgCommand].context[<dark_green>Teleport|toutpost agree teleport green teleport %value%|<dark_green>/toutpost teleport %value%]><&sp><proc[msgCommand].context[<gold>Manage|toutpost manage %value%|<gold>/toutpost manage %value%]><&sp><proc[msgCommand].context[<dark_red>Delete|toutpost agree deletion dark_red delete %value%|<dark_red>/toutpost delete %value%]>" targets:<player>
            - narrate "<proc[msgHover].context[<%Colour%> <&gt> <%ColourSecondary%><&lb><%Colour%><server.flag[TeaOutPostList].find[%value%]><%ColourSecondary%><&rb> <%Colour%><server.flag[%ActualName%DisplayName]||The<&sp>Outpost> (<server.flag[%ActualName%TrainingFocus]||MCMMO>)<&sp><%ColourSecondary%>-<%Colour%><&sp><server.flag[%Colour%DisplayName]||Wild>|<%Colour%>OutpostID: <%ColourSecondary%>%ActualName%]> <proc[msgCommand].context[<%Colour%><&gt>MOLE|outpost lookup %ActualName% 1|<%Colour%>Mole]> <proc[msgCommand].context[<%Colour%><&gt>SPY|outpost lookup %ActualName% 1|<%Colour%>Spy]>" targets:<player>
            }
        #  - narrate "<dark_aqua><proc[msgCommand].context[<tern[<def[PageNumber].is[MORE].than[1]>]:<dark_aqua>||<gray>>PREVIOUS|toutpost list %PreviousPage%|toutpost list %PreviousPage%]>" targets:<player>
       #   - narrate "<tern[<def[PageNumber].is[MORE].than[1]>]:<proc[msgCommand].context[<dark_aqua><&lt><&lt> <dark_aqua>PREVIOUS|toutpost list %PreviousPage%|toutpost list %PreviousPage%]>||<proc[msgHover].context[<gold><&lb><dark_gray><&lt><gold><&rb>|<dark_gray>No previous page]>> <gold>- - - <tern[<def[PageNumber].is[==].to[%NextPage%]>]:<dark_gray>NEXT||<proc[msgCommand].context[<dark_aqua>NEXT|toutpost list %NextPage%|toutpost list %NextPage%]>> <dark_aqua><&gt><&gt>" targets:<player>
     #     - narrate "<tern[<def[PageNumber].is[MORE].than[1]>]:<proc[msgCommand].context[<dark_aqua><&lt><&lt> <dark_aqua>PREVIOUS|outpost list %PreviousPage%|toutpost list %PreviousPage%]>||<proc[msgHover].context[<gold><&lb><dark_gray><&lt><&lt><gold><&rb>|<dark_gray>No previous page]>> <gold>- - - - - <tern[<def[PageNumber].is[==].to[%NextPage%]>]:<proc[msgHover].context[<gold><&lb><dark_gray><&gt><&gt><gold><&rb>|<dark_gray>No next page]>||<proc[msgCommand].context[<dark_aqua>NEXT <dark_aqua><&gt><&gt>|outpost list %NextPage%|toutpost list %NextPage%]>>" targets:<player>
          - narrate "<tern[<def[PageNumber].is[MORE].than[1]>]:<proc[msgCommand].context[<gold><&lb><green><&lt><&lt>%PreviousPage%<gold><&rb>|outpost list %PreviousPage%|<green> Previous Page ]>||<proc[msgHover].context[<gold><&lb><dark_gray><&lt><&lt><gold><&rb>|<dark_gray> No previous page ]>> <gold>- - <proc[msgCommand].context[<gold><&lb><green>%PageNumber%<gold><&rb>|outpost list %PageNumber%|<green> <&gt> Refresh Page %PageNumber% ]><gold> - - <tern[<def[PageNumber].is[==].to[%NextPage%]>]:<proc[msgHover].context[<gold><&lb><dark_gray><&gt><&gt><gold><&rb>|<dark_gray> No next page ]>||<proc[msgCommand].context[<gold><&lb><green>%NextPage%<&gt><&gt><gold><&rb>|outpost list %NextPage%|<green> Next Page ]>>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost|<gold> <&lt><&lt> Back to Outpost Menu ]>" targets:<player>
          - narrate "" targets:<player>

   ## INFO ---
        - case info:
          - inject "TeaOutpost_InfoPageTask"
   ## LOOKUP ---
        - case lookup:
          - if <context.args.get[2]||null> == null && <context.args.get[3]||null> == null {
            - narrate "<dark_red><&lb>OUTPOST<&rb> /outpost lookup <&lb><&lt>outpostID<&gt><&rb> (<&lt>pagenumber<&gt>) " targets:<player>
            - queue clear
            }
          - define OutpostID <context.args.get[2]||None>
          - define Colour <server.flag[Ownerof%OutpostID%]||Gray>
          - define path "%OutpostID%"
          - if <context.args.get[3].as_int||1> == <context.args.get[3]||1> && <context.args.get[3].as_int||1> > 0 {
            - define PageNumber <context.args.get[3]||1>
            }
            else {
              - define PageNumber 1
              }
          - define NextPage <def[PageNumber].add[1].as_int>
       #   - if <server.flag[TeaOutpostList].size> < <math.as_int:%NextPage%*10> {
       #     - define NextPage %PageNumber%
       #     }
          - define PreviousPage <def[PageNumber].sub[1].as_int>
          - define ListEndInt <def[PageNumber].mul[10].as_int>
         # - if <server.flag[TeaOutpostList].size> < %ListEndInt% {
         #   - define ListEndInt <server.flag[TeaOutpostList].size>
         #   - define NextPage %PageNumber%
    
         #   }
          - define ListStartInt <math.as_int:((%PageNumber%-1)*10)+1>
          - if <def[ListStartInt]> < 1 {
            - define ListStartInt 1
            }
          - define ListFullCount <proc[TeaOutpost_get_edits].context[%OutpostID%|1|100]||li@>
          - if <def[ListFullCount].size> < %ListEndInt% {
            - define ListEndInt <def[ListFullCount].size>
            - define PageNumber <def[ListEndInt].div[10].round_down.add[1]||1>
            - define ListStartInt <def[PageNumber].sub[1].mul[10].add[1]>
            - define NextPage %PageNumber%
            - define PreviousPage <def[PageNumber].sub[1].as_int>

            - define ListEdits <proc[TeaOutpost_get_edits].context[%OutpostID%|%ListStartInt%|%ListEndInt%]||li@>
            }
            else {
            - define ListEdits <proc[TeaOutpost_get_edits].context[%OutpostID%|%ListStartInt%|%ListEndInt%]||li@>
            }
        #  - narrate "" targets:<player>
         # - narrate "<gold><&lb>OUTPOST<&rb> THERE ARE <server.flag[TeaOutpostList].size> OUTPOSTS" targets:<player>
         # - foreach <server.flag[TeaOutpostList].as_list.get[%ListStartInt%].to[%ListEndInt%]> {
          
          - if !<yaml.list.contains[TeaOutpost_%OutpostID%]> {
            - if !<server.has_file[/Outpost/<def[OutpostID]>_CHANGES.yml]> {
              - narrate "<dark_red><&lb>OUTPOST<&rb> THERE ARE NO LOGS FOR <%Colour%><server.flag[%OutpostID%DisplayName].to_uppercase||THE OUTPOST><dark_red>."
              - queue clear
              } else {
              - yaml "load:/Outpost/<def[OutpostID]>_CHANGES.yml" id:TeaOutpost_%OutpostID%
              }
            }
          - if "<yaml[TeaOutpost_%OutpostID%].contains[<def[path]>]>" {
            - define lookup_start <server.current_time_millis>
            - ^define ColourSwitch dark_aqua
            - narrate "" targets:<player>

           # - narrate "<&6>Found <green><yaml[TeaOutpost_%OutpostID%].list_keys[<def[path]>].size||0><&6> entries for this location. Showing most recent <green>%ListStartInt%%ListEndInt%<&6><&co>"
           # - narrate "<&6>Found <green><def[ListEdits].size||0><&6> entries for this location. Showing most recent <green>%ListStartInt%%ListEndInt%<&6><&co>"
            - define PageCount <def[ListFullCount].size.div[10].round_down.add[1]||0>
            - narrate "<&6><&lb>OUTPOST<&rb> THERE <tern[<def[PageCount].as_int.is[EQUALS].to[1]>]:IS <green><def[PageCount]><&6> PAGE||ARE <green><def[PageCount]><&6> PAGES> FOR <%Colour%><server.flag[%OutpostID%DisplayName].to_uppercase||THE OUTPOST><gold>."
            - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <util.date.time.year>-<util.date.time.month.replace[regex:^(?!..)].with[0]>-<util.date.time.day.replace[regex:^(?!..)].with[0]>|<dark_aqua><util.date.time.year>-<util.date.time.month.replace[regex:^(?!..)].with[0]>-<util.date.time.day.replace[regex:^(?!..)].with[0]> @ <util.date.time.hour><&co><util.date.time.minute.replace[regex:^(?!..)].with[0]>]><dark_aqua> TODAY @ RIGHT NOW"
            - foreach <proc[TeaOutpost_get_edits].context[%OutpostID%|%ListStartInt%|%ListEndInt%]||li@> {
              - ^if %ColourSwitch% == gray {
              - ^define ColourSwitch dark_aqua
              }
              else {
                - ^define ColourSwitch gray
              }
              - define entry <def[value].split[/]>
                #  - define entries <def[entries].include[%timestamp%/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Player]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.PlayerName]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.TeamColour]||none>]>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Change]||none>]>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Result]||none>]>
              - define DisplayColour <def[entry].get[4]>
           #   - narrate "<&6><def[entry].get[1].time.year>-<def[entry].get[1].time.month>-<def[entry].get[1].time.day> <def[entry].get[1].time.hour><&co><def[entry].get[1].time.minute><&co><def[entry].get[1].time.second><&co> <%DisplayColour%><def[entry].get[4]><&e> did <&b><def[entry].get[5]><&e> with result <&b><def[entry].get[6]><&e>."
             # - narrate "<%ColourSwitch%><def[entry].get[1].time.year>-<def[entry].get[1].time.month.replace[regex:^(?!..)].with[0]>-<def[entry].get[1].time.day.replace[regex:^(?!..)].with[0]> <def[entry].get[1].time.hour.replace[regex:^(?!..)].with[0]><&co><def[entry].get[1].time.minute.replace[regex:^(?!..)].with[0]> <%DisplayColour%><&pipe><&pipe> <def[entry].get[5]><&co> <def[entry].get[6]>"
              - narrate "<proc[msgHover].context[<%ColourSwitch%> <&gt> <def[entry].get[1].time.year>-<def[entry].get[1].time.month.replace[regex:^(?!..)].with[0]>-<def[entry].get[1].time.day.replace[regex:^(?!..)].with[0]>|<%ColourSwitch%><def[entry].get[1].time.year>-<def[entry].get[1].time.month.replace[regex:^(?!..)].with[0]>-<def[entry].get[1].time.day.replace[regex:^(?!..)].with[0]> @ <%ColourSwitch%><def[entry].get[1].time.hour><&co><def[entry].get[1].time.minute.replace[regex:^(?!..)].with[0]>]> <%DisplayColour%><def[entry].get[5]><&co> <def[entry].get[6]>"
              }
           # - narrate "<&c>Looked up results in <server.current_time_millis.sub[%lookup_start%].as_int>ms."
            - narrate "<tern[<def[PageNumber].is[MORE].than[1]>]:<proc[msgCommand].context[<gold><&lb><green><&lt><&lt>%PreviousPage%<gold><&rb>|outpost lookup %OutpostID% %PreviousPage%|<green>Previous Page]>||<proc[msgHover].context[<gold><&lb><dark_gray><&lt><&lt><gold><&rb>|<dark_gray>No previous page]>> <gold>- - <proc[msgCommand].context[<gold><&lb><green>%PageNumber%<gold><&rb>|outpost lookup %OutpostID% %PageNumber%|<green>Refresh Page %PageNumber%]><gold> - - <tern[<def[PageNumber].is[==].to[%NextPage%]>]:<proc[msgHover].context[<gold><&lb><dark_gray><&gt><&gt><gold><&rb>|<dark_gray>No next page]>||<proc[msgCommand].context[<gold><&lb><green>%NextPage%<&gt><&gt><gold><&rb>|outpost lookup %OutpostID% %NextPage%|<green>Next Page]>>" targets:<player>
            - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost list|<gold>Back to Outpost List]>" targets:<player>

            } else {
            - narrate "<&c>No logged info was found for this location."
            - queue clear
            }
   ## DEFAULT ---

        - default:
         # - ^narrate "" targets:<player>
          - ^narrate "<gold><bold><&lb>OUTPOST<&rb> Outpost by Tea" targets:<player>
          - ^narrate "<proc[msgHover].context[<aqua> + <italic>Mouse over any line with a <aqua>+<italic> symbol for more information.|<aqua> Click any line with a <gold><&gt><aqua> to navigate the menu! ]>" targets:<player>
         # - ^narrate "<aqua>The - symbol means the following text is hoverable! (Is not clickable?)" targets:<player>
         # - ^narrate "<aqua>No symbol means theres nothing!" targets:<player>
          #- ^narrate "<gold>HEADER(Unclickable)/Menu(Clickable)/FOOTER(Unclickable) <gray>Information(Unclickable) <dark_aqua>Secondary Information <green>Tertiary Information <dark_gray>No access <dark_red>Error" targets:<player>

          - ^narrate "<proc[msgCommand].context[<gold> <&gt> /outpost info|outpost info|<gold> <&gt> Click to learn more about Outposts ]><dark_aqua> - Learn about Outposts" targets:<player>
          - ^narrate "<proc[msgCommand].context[<yellow> <&gt> /outpost report|outpost report|<yellow> <&gt> Click to report an issue or an idea ]><gray> - Report an issue or an idea" targets:<player>
       #   - ^narrate "" targets:<player>

          - ^narrate "<proc[msgCommand].context[<gold> <&gt> /outpost here|outpost here|<gold> <&gt> Click to view or edit local outpost information ]><dark_aqua> - View or edit local outpost information" targets:<player>
      #    - ^narrate "" targets:<player>
          - ^narrate "<proc[msgCommand].context[<yellow> <&gt> /outpost list|outpost list|<yellow> <&gt> Click to view all outpost names and owners ]><gray> - View all outpost names and owners" targets:<player>
       #   - ^narrate "" targets:<player>

          - ^narrate "<proc[msgCommand].context[<gold> <&gt> /outpost player|outpost player|<gold> <&gt> Click to view or edit player information ]><dark_aqua> - View or edit player information" targets:<player>
          ### Uncomment below line when /outpost team command is finalized
    ###      - ^narrate "<proc[msgCommand].context[<yellow> <&gt> /outpost team|outpost team|<yellow> <&gt> Click to view or edit team information ]><gray> - View or edit team information" targets:<player>
          - if <player.flag[TeaOutpostBypass]||false> == true {
            - ^narrate "" targets:<player>
            - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> |<dark_aqua>This line has clickable text!]><proc[msgCommand].context[<dark_aqua>/toutpost|toutpost|<dark_aqua>Click!]><gray> - Open the Admin Bypass panel" targets:<player>
            }
          - ^narrate "" targets:<player>

          #- ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<aqua>START|toutpost start|<aqua>/Click this to start creating a new Outpost]> <dark_aqua>location finder." targets:<player>
    CheckLocation:
      - if <player.location.cuboids.as_list.contains[cu@%ManageName%]||false> != true {
      - ^narrate "<proc[msgHover].context[<dark_aqua><&gt> Stand inside this Outpost to make changes.|<white>Outposts cannot be managed from a distance.]>" targets:<player>
      - queue clear
      }


TeaOutpost_Command:
    type: command
    debug: false
    name: toutpost
    description: Tea Outpost
    usage: /toutpost
    default constants:
      colourlist: Dark_Green|Dark_Aqua|Dark_Red|Dark_Purple|Gold|Gray|Dark_Gray|Blue|Green|Aqua|Red|Light_Purple|Yellow|White
      mcmmolist: Acrobatics|Alchemy|Archery|Axes|Excavation|Fishing|Herbalism|Mining|Repair|Swords|Taming|Unarmed|Woodcutting
      spelllist: Bad_Luck|Blindness|Fire_Resistance|Glowing|Haste|Hunger|Invisibility|Jump_Boost|Luck|Mining_Fatigue|Nausea|Night_Vision|Poison|Regeneration|Resistance|Saturation|Slowness|Speed|Strength|Water_Breathing|Weakness
      targetlist: ALL|TEAM|ENEMY|NONE
    script:
      - if <player.flag[TeaOutpostBypass]||false> == false {
        - execute as_player "outpost"
        - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Please contact Tea for an Admin Bypass.|<dark_red>But only if youre actually supposed to have it lol<&nl><dark_gray>Access Denied<&co> Tea.Outpost.Bypass]>" targets:<player>
        - queue clear
        }
      - choose <context.args.first||default>:
   ## CANCEL ---
        - case cancel:
          - narrate "<dark_aqua><&lb>OUTPOST<&rb> Location finder cancelled." targets:<player>
          - flag <player> CreatingTeaOutpost:false
    ## CONFIRM ---
        - case confirm:
         # - announce "<player.flag[TeaOutpostGoodSpotCheck]>"
          - if <player.flag[OutpostCreationInProgress]||false> {
            - narrate "<dark_aqua><&lb>OUTPOST<&rb> Outpost in progress. Thank you for your patience." targets:<player>
            - queue clear
            }
          - if <player.flag[CreatingTeaOutpost]||false> == false {
            - ^narrate "<gold><&lb>OUTPOST<&rb> Starting location finder, please reconfirm." targets:<player>
           # - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Obsidian blocks must be on the surface." targets:<player>
            - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>/toutpost confirm]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>/toutpost cancel]> <dark_aqua>this location." targets:<player>
            - flag <player> CreatingTeaOutpost:true
            - run TeaOutpost_Task
            - queue clear
            }
     #     - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.cuboids>]||false> == true {
     #       - ^narrate "<gold><&lb>OUTPOST<&rb> There's already an outpost here!" targets:<player>
     #       - ^narrate "<gold><&lb>OUTPOST<&rb> Please choose a better location." targets:<player>
     #       - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>/toutpost confirm]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>/toutpost cancel]> <dark_aqua>this location." targets:<player>
     #       - queue clear
     #     }
          - if <player.flag[TeaOutpostGoodSpotCheck]||false> != true {
          #  - ^narrate "<gold><&lb>OUTPOST<&rb> Obsidian blocks must be on the surface." targets:<player>
            - ^narrate "<gold><&lb>OUTPOST<&rb> Please choose a better location." targets:<player>
            - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>/toutpost confirm]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>/toutpost cancel]> <dark_aqua>this location." targets:<player>
            - queue clear
          }
        #  - if <player.location.cuboids.contains_any[<server.flag[TeaOutpostList].as_list>]> == true {

          - flag <player> OutpostCreationInProgress:true
          - narrate "<dark_aqua><&lb>OUTPOST<&rb> Creating outpost! Please stand by." targets:<player>
          - flag <player> CreatingTeaOutpost:false
          - run TeaOutpost_CreationTask
   ## START ---
        - case start:
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Please choose a location." targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Obsidian blocks must be on the surface." targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<green>CONFIRM|toutpost confirm|<green>This will create a new Outpost!]> <dark_aqua>or <proc[msgCommand].context[<red>CANCEL|toutpost cancel|<red>This will turn off the location finder!]> <dark_aqua>this location." targets:<player>
          - if <player.flag[CreatingTeaOutpost]||false> == false {
            - flag <player> CreatingTeaOutpost:true
            - run TeaOutpost_Task
            }
   ## MANAGE ---
        - case manage:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
          - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>ADMIN<&rb> MANAGING '<gray><def[ManageName].to_uppercase><gold>'" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>MCMMO Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>|toutpost showmcmmo %ManageName%|<dark_aqua>Pick a new MCMMO Focus!]>" targets:<player>

        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Training Message<&co>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Type a new Message at the end of the command!]>" targets:<player>
        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Message<&co>" targets:<player>
        #  - ^narrate "<gold> <&gt> <gray><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost showspells %ManageName%|<dark_aqua>Pick a new Spell Effect!]>" targets:<player>
         # - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Pick a new Spell Target!]>" targets:<player>
    ###      - ^narrate "<proc[msgCommand].context[<gold> <&gt> Add Spells|toutpost showspells %ManageName%|<dark_aqua>Buy a new Spell Effect!]>" targets:<player>
       #   - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost spells %ManageName%|<dark_aqua>Pick a Spell Effect!]>" targets:<player>
       #   - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Pick a Spell Target!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>" targets:<player>
        ##  - ^narrate "<gold> <&gt> Current Owner<&co> <gray><server.flag[%OwnerStuff%DisplayName]||%OwnerStuff%> / <%OwnerStuff%>%OwnerStuff% <gray>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
        #  - ^narrate "<gold> <&gt> Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
       #   - ^narrate "<proc[msgCommand].context[<dark_aqua><&lt><&lt> RETURN TO OUTPOST LIST|toutpost list|<dark_aqua>Return to Outpost List]>" targets:<player>
          
          
          - define TrainingTime <server.flag[%ManageName%Facing].replace[north].with[Noon].replace[south].with[Midnight].replace[East].with[Dawn].replace[West].with[Dusk].first||None>
          - ^narrate "<proc[msgHover].context[<dark_aqua> - Current Owner<&co> <white><server.flag[%OwnerStuff%DisplayName]||Wild> / <%OwnerStuff%>%OwnerStuff% <white>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary%|<%OwnerStuff%><server.flag[%OwnerStuff%DisplayName]||Wild><gray> is the current owner.<&nl><%OwnerStuff%>%OwnerStuff% <gray>is their Team Colour.<&nl><%OwnerStuffSecondary%>%OwnerStuffSecondary%<gray> is a Personal Colour.]> " targets:<player>
          - ^narrate "<proc[msgHover].context[<gray> - Training Time<&co> <white>%TrainingTime% (<server.flag[%ManageName%Facing].to_titlecase||Error>)|<gray>Visit this Outpost at %TrainingTime% for<&co><&nl><dark_aqua>+1 Minecraft Level<&nl><gray>+1 <server.flag[%ManageName%TrainingFocus]||None> Level (if Minecraft Level 30)<&nl><dark_aqua>+20 minutes of <server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||Nothing> (if Minecraft Level 60)]>" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> Display Name<&co> <white><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>|toutpost rename %ManageName%<&sp>|<green>Only Nation Kings can change this.<&nl><dark_aqua>Click then type a new Name at the end of the command!]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> MCMMO Focus<&co> <white><server.flag[%ManageName%TrainingFocus]||None>|toutpost showmcmmo %ManageName%|<green>Only Nation Kings can change this.<&nl><gray>Click to pick an MCMMO Focus!]>" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> Training Message<&co>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Click then type a new Message at the end of the command!]>" targets:<player>
          - ^narrate "<proc[msgHint].context[   <white><italic><server.flag[%ManageName%TrainingMessage]||None>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Click then type a new Message at the end of the command!]>" targets:<player>
        #  - ^narrate "" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Effect<&co> <white><server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||None>|toutpost spells %ManageName%|<gray>Click to pick a Spell Effect!]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Targets<&co> <white><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Click to pick a Spell Target!]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Access Upgrades|outpost upgrades %ManageName%|<green>Click to buy and manage upgrades]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Change Log|toutpost lookup %ManageName%|<dark_aqua>Click to view Change Log]><gold> <&pipe> <proc[msgCommand].context[<gold>Visitor Log|toutpost lookup %ManageName%|<dark_aqua>Click to view Change Log]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Manage Towny|toutpost towny %ManageName%|<gray>Click to manage Towny Settings for this Outpost]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|toutpost list|<gold>Back to TOutpost List]>" targets:<player>
     
      #  - ^narrate "<gray> - <gold>Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
     #   - ^narrate "<proc[msgCommand].context[<dark_aqua><&lt><&lt> RETURN TO OUTPOST LIST|toutpost list|<dark_aqua>Return to Outpost List]>" targets:<player>
  #        }
  #    }
  #    else {
  #      - ^narrate "<dark_red><&lb>OUTPOST<&rb> Sorry, no Outpost here! <proc[msgCommand].context[<gold><&gt> View Outpost List?|outpost list|<gold>This will show you a list of all Outposts.]>" targets:<player>
  #      }
          
   ## TOWNY ---
        - case towny:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
          - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>ADMIN<&rb> MANAGING '<gray><def[ManageName].to_uppercase><gold>'" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>MCMMO Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>|toutpost showmcmmo %ManageName%|<dark_aqua>Pick a new MCMMO Focus!]>" targets:<player>

        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Focus<&co> <gray><server.flag[%ManageName%TrainingFocus]||None>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgHint].context[<gold>Training Message<&co>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Type a new Message at the end of the command!]>" targets:<player>
        #  - ^narrate "<gold><&lb>OUTPOST<&rb> Training Message<&co>" targets:<player>
        #  - ^narrate "<gold> <&gt> <gray><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
        #  - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost showspells %ManageName%|<dark_aqua>Pick a new Spell Effect!]>" targets:<player>
         # - ^narrate "<gold> <&gt> <proc[msgCommand].context[<gold>Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Pick a new Spell Target!]>" targets:<player>
    ###      - ^narrate "<proc[msgCommand].context[<gold> <&gt> Add Spells|toutpost showspells %ManageName%|<dark_aqua>Buy a new Spell Effect!]>" targets:<player>
       #   - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>|toutpost spells %ManageName%|<dark_aqua>Pick a Spell Effect!]>" targets:<player>
       #   - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Targets<&co> <gray><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Pick a Spell Target!]>" targets:<player>
        #  - ^narrate "<gold> <&gt> Spell Effect<&co> <gray><server.flag[%ManageName%SpellEffect]||None>" targets:<player>
        ##  - ^narrate "<gold> <&gt> Current Owner<&co> <gray><server.flag[%OwnerStuff%DisplayName]||%OwnerStuff%> / <%OwnerStuff%>%OwnerStuff% <gray>/ <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
        #  - ^narrate "<gold> <&gt> Facing<&co> <gray><server.flag[%ManageName%Facing]||None>" targets:<player>
       #   - ^narrate "<proc[msgCommand].context[<dark_aqua><&lt><&lt> RETURN TO OUTPOST LIST|toutpost list|<dark_aqua>Return to Outpost List]>" targets:<player>
          
          
          - define TrainingTime <server.flag[%ManageName%Facing].replace[north].with[Noon].replace[south].with[Midnight].replace[East].with[Dawn].replace[West].with[Dusk].first||None>
          - if <server.flag[%ManageName%scriptlist].contains[TeaOutpost_UpdateOutpostTownTask]||false> {
            - ^narrate "<proc[msgHover].context[<gray> <&gt> Towny Link<&co>|<dark_red>Please do not remove Towny Link unless you know what you're doing]><proc[msgHover].context[<green> ON |<green>Towny Link is currently ON.]><proc[msgCommand].context[<gray>/ OFF|toutpost townylinkoff %ManageName%|<dark_red>CLICK TO REMOVE TOWNY LINK]>" targets:<player>
            }
            else {
              - ^narrate "<proc[msgHover].context[<gray> <&gt> Towny Link<&co>|<dark_red>Please do not activate Towny Link until all the below is ready.]><proc[msgCommand].context[<gray> ON /|toutpost townylinkon %ManageName%|<dark_red>CLICK TO ACTIVATE TOWNY LINK]><proc[msgHover].context[<green> OFF|<green>Towny Link is currently OFF.]>" targets:<player>
              }
    #      - ^narrate "<proc[msgHover].context[<gray> - Nation Name<&co> <white>%TrainingTime% (<server.flag[%ManageName%Facing].to_titlecase||Error>)|<gray>Visit this Outpost at %TrainingTime% for<&co><&nl><dark_aqua>+1 Minecraft Level<&nl><gray>+1 <server.flag[%ManageName%TrainingFocus]||None> Level (if Minecraft Level 30)<&nl><dark_aqua>+20 minutes of <server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||Nothing> (if Minecraft Level 60)]>" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> Nation Name<&co> <white><server.flag[%ManageName%NationName]||<dark_red>None>|toutpost setnation %ManageName%<&sp>|<dark_aqua>Click then type the Nation Name at the end of the command!]>" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> Town Name<&co> <white><server.flag[%ManageName%TownName]||<dark_red>None>|toutpost settown %ManageName%<&sp>|<dark_aqua>Click then type the Town Name at the end of the command!]>" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> NPC Name<&co> <white><server.flag[%ManageName%NPCName]||<dark_red>None>|toutpost setnpc %ManageName%<&sp>|<dark_aqua>Click then type the NPC Name at the end of the command!]>" targets:<player>
          - ^if <server.flag[%ManageName%TownName]||null> != null {
            - ^define TownName <server.flag[%ManageName%TownName]>
            - ^narrate "<proc[msgHover].context[<gray> - %TownName% Outpost List<&co>|<dark_aqua>Outpost List]>" targets:<player>
            - foreach <server.flag[%TownName%OutpostList].as_list> {
              - ^narrate "<proc[msgCommand].context[<gray> - %value%|toutpost manage %value%|<dark_aqua>Click for shortcut to manage]>" targets:<player>
              }
            }
    #      - ^narrate "<proc[msgHint].context[<gold> <&gt> Town NPC Name<&co> <white><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>|toutpost rename %ManageName%<&sp>|<dark_aqua>Click then type a new Name at the end of the command!]>" targets:<player>
    #      - ^narrate "<proc[msgCommand].context[<gold> <&gt> MCMMO Focus<&co> <white><server.flag[%ManageName%TrainingFocus]||None>|toutpost showmcmmo %ManageName%|<green>Only Nation Kings can change this.<&nl><gray>Click to pick an MCMMO Focus!]>" targets:<player>
    #      - ^narrate "<proc[msgHint].context[<gold> <&gt> Training Message<&co>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Click then type a new Message at the end of the command!]>" targets:<player>
    #      - ^narrate "<proc[msgHint].context[   <white><italic><server.flag[%ManageName%TrainingMessage]||None>|toutpost setmessage %ManageName%<&sp>|<dark_aqua>Click then type a new Message at the end of the command!]>" targets:<player>
    #    #  - ^narrate "" targets:<player>
    #      - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Effect<&co> <white><server.flag[%ManageName%SpellEffect].first.replace[_].with[<&sp>]||None>|toutpost spells %ManageName%|<gray>Click to pick a Spell Effect!]>" targets:<player>
    #      - ^narrate "<proc[msgCommand].context[<gold> <&gt> Spell Targets<&co> <white><server.flag[%ManageName%SpellTargets]||None>|toutpost showtargets %ManageName%|<dark_aqua>Click to pick a Spell Target!]>" targets:<player>
    #      - ^narrate "<proc[msgCommand].context[<gold> <&gt> Access Upgrades|outpost upgrades %ManageName%|<green>Click to buy and manage upgrades]>" targets:<player>
    #      - ^narrate "<proc[msgCommand].context[<gold> <&gt> Change Log|toutpost lookup %ManageName%|<dark_aqua>Click to view Change Log]><gold> <&pipe> <proc[msgCommand].context[<gold>Visitor Log|toutpost lookup %ManageName%|<dark_aqua>Click to view Change Log]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|toutpost manage %ManageName%|<gold>Back to TOutpost Manage]>" targets:<player>
          
   ## TOWNYLINKON
        - case townylinkon:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - flag server %ManageName%scriptlist:->:TeaOutpost_UpdateOutpostTownTask
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|TownyLink|ON
          - execute as_player "toutpost towny %ManageName%"
   ## TOWNYLINKOFF
        - case townylinkoff:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - flag server %ManageName%scriptlist:<-:TeaOutpost_UpdateOutpostTownTask
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|TownyLink|OFF
          - execute as_player "toutpost towny %ManageName%"
   ## NATION NAME
        - case setnation:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NationName <context.args.get[3]||null>
          - if %NationName% == null {
            - ^narrate "<Dark_Red><&lb>OUTPOST<&rb>Please type a nation name after the Outpost ID." targets:<player>
            - queue clear
            }
          - flag server %ManageName%NationName:%NationName%
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Set<&sp>Nation|%NationName%
          - execute as_player "toutpost towny %ManageName%"
   ## TOWN NAME
        - case settown:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define TownName <context.args.get[3]||null>
          - define OldTownName <server.flag[%ManageName%TownName]||null>
          - if %TownName% == null {
            - ^narrate "<Dark_Red><&lb>OUTPOST<&rb>Please type a Town name after the Outpost ID." targets:<player>
            - queue clear
            }
          - flag server %ManageName%TownName:%TownName%
          - if !<server.flag[%TownName%OutpostList].contains[%ManageName%]||false> {
            - flag server %TownName%OutpostList:->:%ManageName%
            }
          - if %TownName% != %OldTownName% {
            - flag server %OldTownName%OutpostList:<-:%ManageName%
            }
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Set<&sp>Town|%TownName%
          - execute as_player "toutpost towny %ManageName%"
   ## NPC NAME
        - case setnpc:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NPCName <context.args.get[3]||null>
          - if %NPCName% == null {
            - ^narrate "<Dark_Red><&lb>OUTPOST<&rb>Please type an NPC name after the Outpost ID." targets:<player>
            - queue clear
            }
          - flag server %ManageName%NPCName:%NPCName%
          - run TeaOutpost_Write_Data def:%ManageName%|<player>|<player.name>|<player.flag[RaceColour]||Gray>|Set<&sp>NPC|%NPCName%
          - execute as_player "toutpost towny %ManageName%"

   ## LIST TEAMS ---
        - case listteams:
          - define CurrentColour <player.flag[RaceColourSecondary]||Gray>
          - ^narrate "" targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> THERE ARE <script.constant[colourlist].as_list.size> TEAMS." targets:<player>
          - foreach <script.constant[colourlist]> {
            - define DisplayName <server.flag[%value%DisplayName]||Wild>
            - define NationName <server.flag[%value%NationName]||Nationless>
            - define PlayerCount <server.flag[%value%PlayerList].size||0>
            - define OutpostCount <server.flag[%value%OutpostList].size||0>
            - ^narrate "<proc[msgCommand].context[<%value%> <&gt> %DisplayName% / %NationName% / %value% - %PlayerCount%/%OutpostCount% |toutpost manageteam %value%|<%value%>Click to view %value% info]>" targets:<player>
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> Back|toutpost|<gold>Back to Outpost Admin Menu]>" targets:<player>
          
   ## MANAGE ---
        - case manageteam:
          - define ManageName <context.args.get[2]>
          - define ManageNationName <server.flag[%ManageName%NationName]||None>
          - define ManageDisplayName <server.flag[%ManageName%DisplayName]||Wild>
          - define ManageDisplayTag <server.flag[%ManageName%DisplayNameTag]||WLD>
          - ^narrate "" targets:<player>
          - ^narrate "<gold><&lb>ADMIN<&rb> MANAGING '<%ManageName%><def[ManageName].to_uppercase><gold>' TEAM" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> Display Name<&co> <%ManageName%>%ManageDisplayName%|toutpost teamsetname %ManageName%<&sp>|<dark_aqua>Click then type a new Name at the end of the command!]>" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> Display Name Tag<&co> <%ManageName%>%ManageDisplayTag%|toutpost teamsetnametag %ManageName%<&sp>|<dark_aqua>Click then type a new Name tag at the end of the command!]>" targets:<player>
          - ^narrate "<proc[msgHint].context[<gold> <&gt> Nation Name<&co> <%ManageName%>%ManageNationName%|toutpost teamsetnation %ManageName%<&sp>|<dark_aqua>Click then type a new Name at the end of the command!]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Player Count<&co> <%ManageName%><server.flag[%ManageName%PlayerList].size||0>|toutpost showmcmmo %ManageName%|<green>Only Nation Kings can change this.<&nl><gray>Click to pick an MCMMO Focus!]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold> <&gt> Outpost Count<&co> <%ManageName%><server.flag[%ManageName%OutpostList].size||0>|toutpost showmcmmo %ManageName%|<green>Only Nation Kings can change this.<&nl><gray>Click to pick an MCMMO Focus!]>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|toutpost listteams|<gold>Back to Outpost Admin Team List]>" targets:<player>

   ## TEAM SET NAME ---
        - case teamsetname:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NewName <context.args.get[3]>
          - flag server %ManageName%DisplayName:%NewName%
          - execute as_player "toutpost manageteam %ManageName%"
          
   ## TEAM SET NAME TAG---
        - case teamsetnametag:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NewNameTag <context.args.get[3]>
          - flag server %ManageName%DisplayNameTag:%NewNameTag%
          - execute as_player "toutpost manageteam %ManageName%"

   ## TEAM SET NATION ---
        - case teamsetnation:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NewNation <context.args.get[3]>
          - flag server %ManageName%NationName:%NewNation%
          - execute as_player "toutpost manageteam %ManageName%"

   ## RENAME
        - case rename:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NewNameList <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list>
          - define NewNameSize <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list.size>
          - define repeatcount 3
          - define FlagName <context.args.get[3]>

         # - flag server %ManageName%DisplayName:clear
          - repeat <def[NewNameSize].sub[1].as_int> {
            - define repeatcount <def[repeatcount].add[1]>
            - define FlagName %FlagName%<&sp><context.args.get[%repeatcount%]>
          #  - define FlagName <def[FlagName]||>%NewName%<&sp>
           # - flag server %ManageName%DisplayName:%FlagName%<&sp>%value%
          }
          - flag server %ManageName%DisplayName:%FlagName%

         # - define NewName <%NewName%.replace[|].with[]>
        #  - define OwnerStuff <server.flag[Ownerof%ManageName%].to_titlecase||Gray>
        #  - define OwnerStuffSecondary <server.flag[Ownerof%ManageName%Secondary].to_titlecase||Gray>
     ##     - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <green>Renaming <dark_aqua>'<aqua>%ManageName%<dark_aqua>' to '<green>%FlagName%<dark_aqua>'." targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <proc[msgCommand].context[<aqua>Reopen Outpost List?|toutpost list|toutpost list]>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Display Name<&co> <aqua><server.flag[%ManageName%DisplayName]||The<&sp>Outpost>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Training Focus<&co> <aqua><server.flag[%ManageName%TrainingFocus]||None>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Training Message<&co>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <aqua><italic><server.flag[%ManageName%TrainingMessage]||None>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Spell Effect<&co> <aqua><server.flag[%ManageName%SpellEffect]||None>" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Current Owner<&co> <aqua><server.flag[%OwnerStuff%DisplayName]||None> / <%OwnerStuff%>%OwnerStuff% / <%OwnerStuffSecondary%>%OwnerStuffSecondary% " targets:<player>
          - execute as_player "toutpost manage cu@%ManageName%"
         # - narrate "<dark_aqua>"

   ## SET MESSAGE
        - case setmessage:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define NewMessageList <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list>
          - define NewMessageSize <context.args.exclude[<context.args.get[1]>|<context.args.get[2]>].as_list.size>
          - define repeatcount 3
          - define FlagName <context.args.get[3]>
          - repeat <def[NewMessageSize].sub[1].as_int> {
            - define repeatcount <def[repeatcount].add[1].as_int>
            - define FlagName %FlagName%<&sp><context.args.get[%repeatcount%]>
          }
          - flag server %ManageName%TrainingMessage:%FlagName%
          #- ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <green>Setting message of <dark_aqua>'<aqua>%ManageName%<dark_aqua>' to '<green>%FlagName%<dark_aqua>'." targets:<player>
          - execute as_player "toutpost manage cu@%ManageName%"

   ## SHOW MCMMO ---
        - case showmcmmo:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - ^narrate "" targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST> MCMMO FOCUS" targets:<player>
          - define LineColour gray
          - foreach <script.constant[mcmmolist]> {
            - if <server.flag[%ManageName%TrainingFocus]> == %value% {
              - ^narrate "<proc[msgCommand].context[<green> <&gt> <bold>%value%|toutpost setmcmmo %ManageName% %value%|<green>Confirm %value%]>" targets:<player>
              }
              else {
                - ^narrate "<proc[msgCommand].context[<%LineColour%> <&gt> %value%|toutpost setmcmmo %ManageName% %value%|<%LineColour%>Select %value%]>" targets:<player>
                }
            - if <def[LineColour]||dark_aqua> == dark_aqua {
              - define LineColour gray
              }
              else {
                - define LineColour dark_aqua
         
                }
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> RETURN TO MANAGE PAGE|toutpost manage cu@%ManageName%|<gold>/toutpost manage cu@%ManageName%]>" targets:<player>

   ## SET MCMMO ---
        - case setmcmmo:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define SkillName <context.args.get[3]>
          - flag server %ManageName%TrainingFocus:%SkillName%
          - execute as_player "toutpost manage cu@%ManageName%"

   ## SHOW SPELLS ---
        - case showspells:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - ^narrate "" targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST> AVAILABLE SPELL LIST" targets:<player>
          - define SpellCount 1
          - define ColourSwitch gray
          - ^foreach <script.constant[spelllist]> {
            - ^if <server.flag[%ManageName%SpellsAdded].contains[%value%]||false> == true {
              - ^narrate "<proc[msgHover].context[<green><&sp><&gt><&sp><bold><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|<green>Already added!]>" targets:<player>
            #  - ^foreach next
              }
              else {
             #   - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
             #   - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
             #   - define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]>
             #  - ^narrate "<proc[msgCentered].context[30|<%ColourSwitch%><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]><%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>" targets:<player>
             #  - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
             #  - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
               - ^define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>buyspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%].trim||Error>|<%ColourSwitch%>Buy<&sp>%value%<&co><&sp>10<&sp>000<&sp>Gold<&sp>(Admin<&sp>Bypass<&co><&sp>FREE)]>
             #  - ^define SpellTwo <proc[msgCommand].context[<%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>]>
               - ^narrate "%SpellOne%" targets:<player>
              # - ^narrate "<proc[msgCentered2].context[190|%SpellOne%]>|<proc[msgCentered3].context[190|%SpellTwo%]>" targets:<player>
                }
            - ^if %ColourSwitch% == dark_aqua {
              - ^define ColourSwitch gray
              }
              else {
                - ^define ColourSwitch dark_aqua
              }
            - ^define SpellCount <def[SpellCount].add[1].as_int>
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|toutpost manage cu@%ManageName%|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>]>" targets:<player>
   ## SET SPELLS ---
        - case buyspell:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define SpellName <context.args.get[3]>
          - flag server %ManageName%SpellsAdded:->:%SpellName%
          - flag server %ManageName%SpellEffect:%SpellName%
          - execute as_player "toutpost spells %ManageName%"
   ## SPELLS ---
        - case spells:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - ^narrate "" targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST> SPELL EFFECT" targets:<player>
          - define SpellCount 1
          - define ColourSwitch gray
          - ^foreach <server.flag[%ManageName%SpellsAdded].as_list||Bad_Luck> {
            - ^if <server.flag[%ManageName%SpellEffect]> == %value% {
              - ^define SpellOne <proc[msgCommand].context[<green><&sp><&gt><&sp><bold>%value%|outpost<&sp>setspell<&sp>%ManageName%<&sp>%value%|<green>Confirm<&sp>%value%]>
             # - ^define SpellTwo <proc[msgCommand].context[<%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>]>
              - ^narrate "%SpellOne%" targets:<player>
              }
                else {
               #   - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
               #   - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
               #   - define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]>
               #  - ^narrate "<proc[msgCentered].context[30|<%ColourSwitch%><script.constant[spelllist].as_list.get[%SpellCount%]||Error>]><%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>" targets:<player>
               #  - define pad '<el@val[%lineLen%].sub[<def[%value%].length>].as_int>'
               #  - determine '<def[string]><&6.pad_right[%pad%].with[<&sp>]><def[string2]>'
                 - ^define SpellOne <proc[msgCommand].context[<%ColourSwitch%><&sp><&gt><&sp>%value%|toutpost<&sp>setspell<&sp>%ManageName%<&sp>%value%|<%ColourSwitch%>Select<&sp>%value%]>
               #  - ^define SpellTwo <proc[msgCommand].context[<%ColourSwitch%><script.constant[spelllist2].as_list.get[%SpellCount%]||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>|toutpost<&sp>setspell<&sp>%ManageName%<&sp><script.constant[spelllist2].as_list.get[%SpellCount%].trim||Error>]>
                 - ^narrate "%SpellOne%" targets:<player>
                # - ^narrate "<proc[msgCentered2].context[190|%SpellOne%]>|<proc[msgCentered3].context[190|%SpellTwo%]>" targets:<player>
                  }
            - ^if %ColourSwitch% == dark_aqua {
              - ^define ColourSwitch gray
              }
              else {
                - ^define ColourSwitch dark_aqua
              }
            - ^define SpellCount <def[SpellCount].add[1].as_int>
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> BACK|toutpost manage cu@%ManageName%|<gold>Back to <server.flag[%ManageName%DisplayName]||The<&sp>Outpost>]>" targets:<player>
   ## SET SPELLS ---
        - case setspell:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define SpellName <context.args.get[3]>
          - flag server %ManageName%SpellEffect:%SpellName%
          - execute as_player "toutpost manage cu@%ManageName%"

   ## SHOW TARGETS ---
        - case showtargets:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - ^narrate "" targets:<player>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> <server.flag[%ManageName%DisplayName].to_uppercase||THE<&sp>OUTPOST> SPELL TARGETS" targets:<player>
          - foreach <script.constant[targetlist]> {
            - if <server.flag[%ManageName%SpellTargets]||ALL> == %value% {
              - ^narrate "<green> <&gt> <proc[msgCommand].context[<green><bold>%value%|toutpost settargets %ManageName% %value%|<green>Confirm %value%]>" targets:<player>
              }
              else {
                - ^narrate "<dark_aqua> <&gt> <proc[msgCommand].context[<dark_aqua>%value%|toutpost settargets %ManageName% %value%|<dark_aqua>Select %value%]>" targets:<player>
                }
            }
          - ^narrate "<dark_aqua><proc[msgCommand].context[<gold><&lt><&lt> RETURN TO MANAGE PAGE|toutpost manage cu@%ManageName%|<gold>/toutpost manage cu@%ManageName%]>" targets:<player>

   ## SET TARGETS ---
        - case settargets:
          - define ManageName <context.args.get[2].replace[cu@].with[]>
          - define TargetName <context.args.get[3]>
          - flag server %ManageName%SpellTargets:%TargetName%
          - execute as_player "toutpost manage cu@%ManageName%"

        - case delete:
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Deleting <context.args.get[2]>" targets:<player>
          - run TeaOutpost_DeletionTask def:<context.args.get[2]>

   ## AGREE ---
        - case agree:
          - define AgreeKeyword <context.args.get[2]>
          - define AgreeKeywordColour <context.args.get[3]>
          - define AgreeCommand <context.args.get[4]>
          - define AgreeCommandVariable <context.args.get[5]>
          - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Please click here to <proc[msgCommand].context[<%AgreeKeywordColour%>CONFIRM|toutpost %AgreeCommand% %AgreeCommandVariable%|<%AgreeKeywordColour%>There's no going back!]> <dark_aqua>%AgreeKeyword%." targets:<player>
        - case teleport:
          - define Destination <context.args.get[2]>
          - execute as_player "teleport <player.name> <%Destination%.center.x.as_int> <%Destination%.center.y.as_int> <%Destination%.center.z.as_int>"

   ## LIST ---
        - case list:
          - if <context.args.get[2].as_int||1> == <context.args.get[2]||1> && <context.args.get[2].as_int||1> > 0 {
            - define PageNumber <context.args.get[2]||1>
            }
            else {
              - define PageNumber 1
              }
          - define NextPage <def[PageNumber].add[1].as_int>
       #   - if <server.flag[TeaOutpostList].size> < <math.as_int:%NextPage%*10> {
       #     - define NextPage %PageNumber%
       #     }
          - define PreviousPage <def[PageNumber].sub[1].as_int>
          - define ListEndInt <def[PageNumber].mul[10]>
          - if <server.flag[TeaOutpostList].size> < %ListEndInt% {
            - define ListEndInt <server.flag[TeaOutpostList].size>
            - define NextPage %PageNumber%

            }
          - define ListStartInt <math.as_int:((%PageNumber%-1)*10)+1>
          - if <def[ListStartInt]> < 1 {
            - define ListStartInt 1
            }
          - narrate "" targets:<player>
          - narrate "<dark_aqua><&lb>ADMIN<&rb> THERE ARE <server.flag[TeaOutpostList].size> OUTPOSTS." targets:<player>
          - foreach <server.flag[TeaOutpostList].as_list.get[%ListStartInt%].to[%ListEndInt%]> {
         #   - if <def[LineColour]||dark_aqua> == dark_aqua {
         #     - define LineColour aqua
         #     }
         #     else {
         #       - define LineColour dark_aqua
         #
         #       }
            - define Colour <server.flag[Ownerof<def[value].replace[cu@].with[]>]||Gray>
            - define ColourSecondary <server.flag[Ownerof<def[value].replace[cu@].with[]>Secondary]||Gray>
           # - narrate "<%LineColour%><&lb><server.flag[TeaOutPostList].find[%value%]><&rb> <def[value].replace[cu@].with[]><&co><&sp><proc[msgCommand].context[<dark_green>Teleport|toutpost agree teleport green teleport %value%|<dark_green>/toutpost teleport %value%]><&sp><proc[msgCommand].context[<gold>Manage|toutpost manage %value%|<gold>/toutpost manage %value%]><&sp><proc[msgCommand].context[<dark_red>Delete|toutpost agree deletion dark_red delete %value%|<dark_red>/toutpost delete %value%]>" targets:<player>
            - narrate "<%ColourSecondary%><&lb><%Colour%><server.flag[TeaOutPostList].find[%value%]><%ColourSecondary%><&rb> <proc[msgHover].context[<%Colour%><server.flag[<def[value].replace[cu@].with[]>DisplayName]||The<&sp>Outpost><&co>|<%Colour%>OutpostID: <%ColourSecondary%><def[value].replace[cu@].with[]>]><&sp><proc[msgCommand].context[<dark_green>Teleport|toutpost agree teleport green teleport %value%|<dark_green>Teleport: <%ColourSecondary%><def[value].replace[cu@].with[]>]><&sp><proc[msgCommand].context[<gold>Manage|toutpost manage %value%|<gold>Manage: <%ColourSecondary%><def[value].replace[cu@].with[]>]><&sp><proc[msgCommand].context[<dark_red>Delete|toutpost agree deletion dark_red delete %value%|<dark_red>Delete: <%ColourSecondary%><def[value].replace[cu@].with[]>]>" targets:<player>
            }
        #  - narrate "<dark_aqua><proc[msgCommand].context[<tern[<def[PageNumber].is[MORE].than[1]>]:<dark_aqua>||<gray>>PREVIOUS|toutpost list %PreviousPage%|toutpost list %PreviousPage%]>" targets:<player>
          - narrate "<dark_aqua><&lt><&lt> <tern[<def[PageNumber].is[MORE].than[1]>]:<proc[msgCommand].context[<dark_aqua>PREVIOUS|toutpost list %PreviousPage%|toutpost list %PreviousPage%]>||<dark_gray>PREVIOUS> <dark_aqua>- - - <tern[<def[PageNumber].is[==].to[%NextPage%]>]:<dark_gray>NEXT||<proc[msgCommand].context[<dark_aqua>NEXT|toutpost list %NextPage%|toutpost list %NextPage%]>> <dark_aqua><&gt><&gt>" targets:<player>
          - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|toutpost|<gold>Back to Outpost Menu]>" targets:<player>

   ## LOOKUP ---
        - case lookup:
          - if <context.args.get[2]||null> == null && <context.args.get[3]||null> == null {
            - narrate "<dark_red><&lb>OUTPOST<&rb> /toutpost lookup <&lb><&lt>outpostID<&gt><&rb> (<&lt>pagenumber<&gt>) " targets:<player>
            - queue clear
            }
          - define OutpostID <context.args.get[2]||None>
          - define Colour <server.flag[Ownerof%OutpostID%]||Gray>
          - define path "%OutpostID%"
          - if <context.args.get[3].as_int||1> == <context.args.get[3]||1> && <context.args.get[3].as_int||1> > 0 {
            - define PageNumber <context.args.get[3]||1>
            }
            else {
              - define PageNumber 1
              }
          - define NextPage <def[PageNumber].add[1].as_int>
       #   - if <server.flag[TeaOutpostList].size> < <math.as_int:%NextPage%*10> {
       #     - define NextPage %PageNumber%
       #     }
          - define PreviousPage <def[PageNumber].sub[1].as_int>
          - define ListEndInt <def[PageNumber].mul[10].as_int>
         # - if <server.flag[TeaOutpostList].size> < %ListEndInt% {
         #   - define ListEndInt <server.flag[TeaOutpostList].size>
         #   - define NextPage %PageNumber%
    
         #   }
          - define ListStartInt <math.as_int:((%PageNumber%-1)*10)+1>
          - if <def[ListStartInt]> < 1 {
            - define ListStartInt 1
            }
          - define ListFullCount <proc[TeaOutpost_get_edits].context[%OutpostID%|1|100]||li@>
          - if <def[ListFullCount].size> < %ListEndInt% {
            - define ListEndInt <def[ListFullCount].size>
            - define PageNumber <def[ListEndInt].div[10].round_down.add[1]||1>
            - define ListStartInt <def[PageNumber].sub[1].mul[10].add[1]>
            - define NextPage %PageNumber%
            - define PreviousPage <def[PageNumber].sub[1].as_int>

            - define ListEdits <proc[TeaOutpost_get_edits].context[%OutpostID%|%ListStartInt%|%ListEndInt%]||li@>
            }
            else {
            - define ListEdits <proc[TeaOutpost_get_edits].context[%OutpostID%|%ListStartInt%|%ListEndInt%]||li@>
            }
        #  - narrate "" targets:<player>
         # - narrate "<gold><&lb>OUTPOST<&rb> THERE ARE <server.flag[TeaOutpostList].size> OUTPOSTS" targets:<player>
         # - foreach <server.flag[TeaOutpostList].as_list.get[%ListStartInt%].to[%ListEndInt%]> {
          
          - if !<yaml.list.contains[TeaOutpost_%OutpostID%]> {
            - if !<server.has_file[/Outpost/<def[OutpostID]>_CHANGES.yml]> {
              - narrate "<dark_red><&lb>OUTPOST<&rb> No logged info found."
              - queue clear
              } else {
              - yaml "load:/Outpost/<def[OutpostID]>_CHANGES.yml" id:TeaOutpost_%OutpostID%
              }
            }
          - if "<yaml[TeaOutpost_%OutpostID%].contains[<def[path]>]>" {
            - define lookup_start <server.current_time_millis>
            - ^define ColourSwitch dark_aqua
            - narrate "" targets:<player>

           # - narrate "<&6>Found <green><yaml[TeaOutpost_%OutpostID%].list_keys[<def[path]>].size||0><&6> entries for this location. Showing most recent <green>%ListStartInt%%ListEndInt%<&6><&co>"
           # - narrate "<&6>Found <green><def[ListEdits].size||0><&6> entries for this location. Showing most recent <green>%ListStartInt%%ListEndInt%<&6><&co>"
            - define PageCount <def[ListFullCount].size.div[10].round_down.add[1]||0>
            - narrate "<&6><&lb>OUTPOST<&rb> THERE <tern[<def[PageCount].as_int.is[EQUALS].to[1]>]:IS <green><def[PageCount]><&6> PAGE||ARE <green><def[PageCount]><&6> PAGES> FOR <%Colour%><server.flag[%OutpostID%DisplayName].to_uppercase||THE OUTPOST><gold>."
            - narrate "<dark_aqua><util.date.time.year>-<util.date.time.month.replace[regex:^(?!..)].with[0]>-<util.date.time.day.replace[regex:^(?!..)].with[0]> TODAY"
            - foreach <proc[TeaOutpost_get_edits].context[%OutpostID%|%ListStartInt%|%ListEndInt%]||li@> {
              - ^if %ColourSwitch% == gray {
              - ^define ColourSwitch dark_aqua
              }
              else {
                - ^define ColourSwitch gray
              }
              - define entry <def[value].split[/]>
                #  - define entries <def[entries].include[%timestamp%/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Player]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.PlayerName]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.TeamColour]||none>]>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Change]||none>]>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Result]||none>]>
              - define DisplayColour <def[entry].get[4]>
           #   - narrate "<&6><def[entry].get[1].time.year>-<def[entry].get[1].time.month>-<def[entry].get[1].time.day> <def[entry].get[1].time.hour><&co><def[entry].get[1].time.minute><&co><def[entry].get[1].time.second><&co> <%DisplayColour%><def[entry].get[4]><&e> did <&b><def[entry].get[5]><&e> with result <&b><def[entry].get[6]><&e>."
             # - narrate "<%ColourSwitch%><def[entry].get[1].time.year>-<def[entry].get[1].time.month.replace[regex:^(?!..)].with[0]>-<def[entry].get[1].time.day.replace[regex:^(?!..)].with[0]> <def[entry].get[1].time.hour.replace[regex:^(?!..)].with[0]><&co><def[entry].get[1].time.minute.replace[regex:^(?!..)].with[0]> <%DisplayColour%><&pipe><&pipe> <def[entry].get[5]><&co> <def[entry].get[6]>"
              - narrate "<proc[msgHover].context[<%ColourSwitch%><def[entry].get[1].time.year>-<def[entry].get[1].time.month.replace[regex:^(?!..)].with[0]>-<def[entry].get[1].time.day.replace[regex:^(?!..)].with[0]>|<%ColourSwitch%><def[entry].get[1].time.year>-<def[entry].get[1].time.month.replace[regex:^(?!..)].with[0]>-<def[entry].get[1].time.day.replace[regex:^(?!..)].with[0]> @ <%ColourSwitch%><def[entry].get[1].time.hour><&co><def[entry].get[1].time.minute.replace[regex:^(?!..)].with[0]>]> <%DisplayColour%><def[entry].get[3]> <&pipe> <def[entry].get[5]><&co> <def[entry].get[6]>"
              }
           # - narrate "<&c>Looked up results in <server.current_time_millis.sub[%lookup_start%].as_int>ms."
            - narrate "<tern[<def[PageNumber].is[MORE].than[1]>]:<proc[msgCommand].context[<gold><&lb><green><&lt><&lt>%PreviousPage%<gold><&rb>|toutpost lookup %OutpostID% %PreviousPage%|<green>Previous Page]>||<proc[msgHover].context[<gold><&lb><dark_gray><&lt><&lt><gold><&rb>|<dark_gray>No previous page]>> <gold>- - <proc[msgCommand].context[<gold><&lb><green>%PageNumber%<gold><&rb>|toutpost lookup %OutpostID% %PageNumber%|<green>Refresh Page %PageNumber%]><gold> - - <tern[<def[PageNumber].is[==].to[%NextPage%]>]:<proc[msgHover].context[<gold><&lb><dark_gray><&gt><&gt><gold><&rb>|<dark_gray>No next page]>||<proc[msgCommand].context[<gold><&lb><green>%NextPage%<&gt><&gt><gold><&rb>|toutpost lookup %OutpostID% %NextPage%|<green>Next Page]>>" targets:<player>
            - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|toutpost manage %OutpostID%|<gold>Back to Outpost Manage]>" targets:<player>

            } else {
            - narrate "<&c>No logged info was found for this location."
            - queue clear
            }
   ## DEFAULT
        - default:
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Outpost by Tea" targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Use this command to create a capturable outpost." targets:<player>
        #  - ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<aqua>START|toutpost start|<aqua>Click to start!]> <dark_aqua>location finder." targets:<player>
        #
          - ^narrate "" targets:<player>
          - ^narrate "<dark_aqua><&lb>ADMIN<&rb> Outpost by Tea" targets:<player>
         # - ^narrate "<gray>The <&gt> symbol means clickable text!" targets:<player>

          - ^narrate "<proc[msgHover].context[<gold> <&gt> |<gold>This line has clickable text!]><proc[msgCommand].context[<gold>/outpost|outpost|<gold>Click!]><gray> - Open the Player Panel" targets:<player>
          - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> |<dark_aqua>This line has clickable text!]><proc[msgCommand].context[<dark_aqua>/toutpost list|toutpost list|<dark_aqua>Click!]><gray> - View or manage all outposts" targets:<player>
          - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> |<dark_aqua>This line has clickable text!]><proc[msgCommand].context[<dark_aqua>/toutpost listteams|toutpost listteams|<dark_aqua>Click!]><gray> - View or manage all teams" targets:<player>
         # - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> |<dark_aqua>This line has clickable text!]><proc[msgCommand].context[<dark_aqua>outpost player|outpost player|<dark_aqua>Click!]><gray> - View or edit player information" targets:<player>
          - ^narrate "<proc[msgHover].context[<dark_aqua> <&gt> |<dark_aqua>This line has clickable text!]><proc[msgCommand].context[<dark_aqua>/toutpost start|toutpost start|<dark_aqua>Click!]><gray> - Create a capturable outpost" targets:<player>
          #- ^narrate "<dark_aqua><&lb>OUTPOST<&rb> Click to <proc[msgCommand].context[<aqua>START|toutpost start|<aqua>/Click this to start creating a new Outpost]> <dark_aqua>location finder." targets:<player>


TeaOutpost_CreationTask:
  type: task
  debug: false
  script:
    - flag <player> TeaOutpostCreationCount:++
    - define PlayerLocation l@<player.location.simple>
    - define PlayerFacing <player.location.direction>
    - define OutpostName outpost<player.name><player.flag[TeaOutpostCreationCount].as_int>
    - flag server TeaOutpostList:->:cu@outpost<player.name><player.flag[TeaOutpostCreationCount].as_int>
    - flag server CTPPointList:->:cu@%OutpostName%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Name<&co> cu@outpost<&dot><player.name><&dot><player.flag[TeaOutpostCreationCount].as_int>" target:<player>
    - flag server %OutpostName%DisplayName:<proc[OutpostAdjectiveProc]><proc[OutpostNameProc]>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Display Name<&co> <server.flag[%OutpostName%DisplayName]>" target:<player>
    - flag server "%OutpostName%TrainingMessage:You focus your mind and your body."
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Training Message<&co>" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> <italic><server.flag[%OutpostName%TrainingMessage]>" target:<player>
    - flag server %OutpostName%TrainingFocus:<proc[OutpostmcmmoProc]>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> McMMO Focus<&co> <server.flag[%OutpostName%TrainingFocus]>" target:<player>
    - flag server %OutpostName%SpellEffect:<proc[OutpostSpellProc]>
    - flag server %OutpostName%SpellTargets:ALL
    - flag server %OutpostName%SpellsAdded:->:<server.flag[%OutpostName%SpellEffect]>
    - define BonusSpell <proc[OutpostSpellProc]>
    - repeat 2 {
      - if %BonusSpell% == <server.flag[%OutpostName%SpellEffect]> {
        - define BonusSpell <proc[OutpostSpellProc]>
        }
        else {
          - repeat stop
          }
      }
    - flag server %OutpostName%SpellsAdded:->:%BonusSpell%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Spell Effect<&co> <server.flag[%OutpostName%SpellEffect]>" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Bonus Spell<&co> %BonusSpell%" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Spell Targets<&co> <server.flag[%OutpostName%SpellTargets]>" target:<player>
    - flag server %OutpostName%Location:%PlayerLocation%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Location<&co> <def[PlayerLocation].simple>" target:<player>
    - flag server %OutpostName%ObsidianLocations:<%PlayerLocation%.add[2,-1,2]>|<%PlayerLocation%.add[-2,-1,2]>|<%PlayerLocation%.add[2,-1,-2]>|<%PlayerLocation%.add[-2,-1,-2]>
    - flag server %OutpostName%Facing:%PlayerFacing%
    - choose "<player.location.direction>":
      - case "north":
        - flag server %OutpostName%Facing:north
        - flag server %OutpostName%TrainingTime:Noon
        - define FacingLocation <%PlayerLocation%.add[0,-1,-2]>
      - case "northeast":
        - flag server %OutpostName%Facing:north
        - flag server %OutpostName%TrainingTime:Noon
        - define FacingLocation <%PlayerLocation%.add[0,-1,-2]>
      - case "east":
        - flag server %OutpostName%Facing:east
        - flag server %OutpostName%TrainingTime:Dawn
        - define FacingLocation <%PlayerLocation%.add[2,-1,0]>
      - case "southeast":
        - flag server %OutpostName%Facing:east
        - flag server %OutpostName%TrainingTime:Dawn
        - define FacingLocation <%PlayerLocation%.add[0,-1,2]>
      - case "south":
        - flag server %OutpostName%Facing:south
        - flag server %OutpostName%TrainingTime:Midnight
        - define FacingLocation <%PlayerLocation%.add[0,-1,2]>
      - case "southwest":
        - flag server %OutpostName%Facing:south
        - flag server %OutpostName%TrainingTime:Midnight
        - define FacingLocation <%PlayerLocation%.add[0,-1,2]>
      - case "west":
        - flag server %OutpostName%Facing:west
        - flag server %OutpostName%TrainingTime:Dusk
        - define FacingLocation <%PlayerLocation%.add[-2,-1,0]>
      - case "northwest":z
        - flag server %OutpostName%Facing:west
        - flag server %OutpostName%TrainingTime:Dusk
        - define FacingLocation <%PlayerLocation%.add[2,-1,0]>
      - default:
        - flag server %OutpostName%Facing:north
        - define FacingLocation <%PlayerLocation%.add[0,-1,-2]>
    - flag server %OutpostName%ObsidianLocations:->:%FacingLocation%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Orientation<&co> <server.flag[%OutpostName%Facing]||Error>" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Training Time<&co> <server.flag[%OutpostName%TrainingTime]||Error>" target:<player>
    - modifyblock <server.flag[%OutpostName%ObsidianLocations].as_list> obsidian delayed
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Obsidian Locations<&co> saved" target:<player>
   # - note cu@<%PlayerLocation%.add[2,5,2]>|<%PlayerLocation%.add[-2,-5,-2]> as:%OutpostName%
   # - note cu@<%PlayerLocation%.add[10,10,10]>|<%PlayerLocation%.add[-10,-10,-10]> as:CTP%OutpostName%
    - note cu@<%PlayerLocation%.add[10,10,10]>|<%PlayerLocation%.add[-10,-10,-10]> as:%OutpostName%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Cuboid Perimeters<&co> saved" target:<player>
    - flag server CTPPointHealth%OutpostName%:1000
    - flag server CTPPointResetHealth%OutpostName%:1000
    - flag server %OutpostName%scriptlist:->:StandardCaptureTaskOutpost
    - flag server %OutpostName%scriptlist:->:TeaOutpost_SingleTrainingCuboidCheck
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Capture Format<&co> Standard Outpost" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Health Points<&co> Standard (<server.flag[CTPPointHealth%OutpostName%]||0>)" target:<player>
    - flag server %OutpostName%leavingscriptlist:->:TeaOutpost_Cooldown_Task
    - flag server %OutpostName%leavingscriptlist:->:TeaOutpost_Autoreset_Task
    - flag server %OutpostName%entryscriptlist:->:TeaOutpost_EntryAnnouncementTask
   # - flag server %OutpostName%entryscriptlist:->:TeaOutpost_SpellTask
    - flag server %OutpostName%entryscriptlist:->:TeaOutpost_TimeCheckTask
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Heal Speed<&co> Standard (3)" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> AutoReset Countdown<&co> Standard (5)" target:<player>
  #  - flag server OutpostObsidianBypassDamage:900
    - flag server OutpostObsidianDamage:100
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Obsidian Damage<&co> Standard (<server.flag[OutpostObsidianDamage]||0>)" target:<player>
    - wait 1s
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Prep Complete" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Ready for Activation" target:<player>
    - announce "<gray><bold>Outpost:<gray> Outpost Created: %OutpostName%" to_flagged:DreamListener

    - narrate "<dark_aqua><&lb>OUTPOST<&rb> MOVE <bold>FIRST<dark_aqua>, BREAK <bold>ONE<dark_aqua> OBBY, THEN LEAVE!" target:<player>
    - flag <player> OutpostCreationInProgress:false

TeaOutpost_DeletionTask:
  type: task
  debug: false
  script:
    - define OutpostName <def[1].replace[cu@].with[]>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Removing Outpost from List" target:<player>

    - flag server TeaOutpostList:<-:cu@%OutpostName%
    - flag server CTPPointList:<-:cu@%OutpostName%

    - narrate "<dark_gray><&lb>OUTPOST<&rb> Stopping NoonLight" target:<player>
    - ^flag global %OutpostName%containsplayers:false

    - wait 5s
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Removing Obsidian" target:<player>
    - modifyblock <server.flag[%OutpostName%ObsidianLocations].as_list> air delayed
    
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Deleting Cuboid Perimeters" target:<player>
    - note remove as:%OutpostName%
    
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Deleting All Flags" target:<player>
    - flag server %OutpostName%DisplayName:!
    - flag server %OutpostName%TrainingMessage:!
    - flag server %OutpostName%TrainingFocus:!
    - flag server %OutpostName%SpellEffect:!
    - flag server %OutpostName%SpellTargets:!
    - flag server %OutpostName%SpellsAdded:!

    - flag server %OutpostName%Location:!

    - flag server %OutpostName%Facing:!

    - flag server %OutpostName%ObsidianLocations:!
    - flag server %OutpostName%leavingscriptlist:!
    - flag server %OutpostName%entryscriptlist:!

    - flag server CTPPointHealth%OutpostName%:!
    - flag server CTPPointResetHealth%OutpostName%:!
    
    - ^flag global %OutpostName%containsplayers:!
    - flag server %OutpostName%obbyactivation:!
    
    - announce "<gray><bold>Outpost:<gray> Outpost Deleted: %OutpostName%" to_flagged:DreamListener

    - narrate "<dark_aqua><&lb>OUTPOST<&rb> Outpost Deletion Complete. <proc[msgCommand].context[<aqua>Reopen Outpost List?|toutpost list|toutpost list]>" target:<player>
   # - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Deletion Complete" target:<player>

TeaOutpost_LocationCheckTask:
  type: task
  debug: false
  script:
    - if <player.location.cuboids.as_list.contains[cu@%ManageName%]||false> != true {
      - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Stand inside this Outpost to make changes.|<gray>Outposts cannot be managed from a distance.]>" targets:<player>
      - queue clear
    }
TeaOutpost_InfoPageTask:
  type: task
  debug: false
  script:
    - define PageNumber <context.args.get[2]||1>
    - define PreviousPage <def[PageNumber].sub[1]>
    - define NextPage <def[PageNumber].add[1]>
    - narrate ""

    - choose <context.args.get[2]||1>:
      - case 1:
        - narrate "<gold><&lb>OUTPOST<&rb> INFO - INDEX"
        - ^narrate "<proc[msgHover].context[<aqua> <&gt> Mouse over any line with a <&gt> symbol.|<aqua> A <gold>gold <&gt><aqua> means that line is clickable!]>" targets:<player>
        - narrate ""
        - narrate "<white> - <dark_aqua>Outposts<white> are capturable land claims that"
        - narrate "<white> - provide benefits to their <dark_aqua>Owners<white>."
        - narrate ""
        - narrate "<gold> <&gt><white> Do <gold><proc[msgCommand].context[<gold>/outpost here|outpost here|<gold>/outpost here]> <white>to see information about your"
        - narrate "<white> - <dark_aqua>Outpost<white>, and its options and upgrades."
        - narrate ""
        - narrate "<proc[msgCommand].context[<gold> <&gt> <&lb> <green>1<gold> <&rb> Index|outpost info 1|<gold> Index<&co> <green>Outposts are capturable land claims ... ]>"
        - narrate "<proc[msgCommand].context[<gold> <&gt> <&lb>2<&rb> Capturing an Outpost|outpost info 2|<gold> Capturing an Outpost<&co> <green>Reduce the Outpost HP to zero ... ]>"
        - narrate "<proc[msgCommand].context[<gold> <&gt> <&lb>3<&rb> Teams and Personal Colours|outpost info 3| <gold>Teams and Personal Colours<&co> <green>Capture Outposts for any Colour ... ]>"
        - narrate "<proc[msgCommand].context[<gold> <&gt> <&lb>4<&rb> Training|outpost info 4|<gold> Training<&co> <green>Stand inside your Capture Zone at Training Time ... ]>"
        - narrate "<proc[msgCommand].context[<gold> <&gt> <&lb>5<&rb> Town Control|outpost info 5|<gold> Town Control<&co> <green>Each Outpost Town will ally with the Team ... ]>"
        - narrate ""
      - case 2:
        - narrate "<gold><&lb>OUTPOST<&rb> INFO - CAPTURING AN OUTPOST"
        - ^narrate "<proc[msgHover].context[<aqua> <&gt> Mouse over any line with a <&gt> symbol.|<aqua> A <gold>gold <&gt><aqua> means that line is clickable!]>" targets:<player>
        - narrate ""
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>To capture an <dark_aqua>Outpost|<dark_aqua>The <aqua>Outposts<dark_aqua> name will appear in <aqua>Chat<&nl><dark_aqua>and its <aqua>HP Bar<dark_aqua> will flash on your <aqua>HUD<dark_aqua>.]><white>,<proc[msgHover].context[<white> find its <dark_aqua>Capture Zone<white>.|<dark_aqua>The <aqua>Outposts<dark_aqua> name will appear in <aqua>Chat<&nl><dark_aqua>and its <aqua>HP Bar<dark_aqua> will flash on your <aqua>HUD<dark_aqua>.]>"
        - narrate ""
        - narrate "<white> - <white>Most <dark_aqua>Capture Zones<white> start with <dark_aqua>1000 HP<white>."
        - narrate ""
        - narrate "<green> - <bold>Reduce the Capture Zone HP to zero to capture it!"
        - narrate ""
        - narrate "<white> - <white>Stand inside the <dark_aqua>Capture Zone<white> to reduce its <dark_aqua>Health Points<white>."
        - narrate ""
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>Breaking an <dark_aqua>Obsidian block<white> will immediately deal <dark_aqua>100 damage|<aqua>Capture Zones<dark_aqua> have <aqua>5 Obsidian Blocks<dark_aqua> inside them.<&nl><dark_aqua>Breaking all <aqua>5 Obsidian Blocks<dark_aqua> will cut your capture time in half!]>"
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>to the <dark_aqua>Capture Zone<white>.|<aqua>Capture Zones<dark_aqua> have <aqua>5 Obsidian Blocks<dark_aqua> inside them.<&nl><dark_aqua>Breaking all <aqua>5 Obsidian Blocks<dark_aqua> will cut your capture time in half!]>"
        - narrate ""
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white><dark_aqua>Multiple Players<white> capture faster.|<dark_aqua>Two <aqua>Players<dark_aqua> capture twice as fast.<&nl><dark_aqua>Three <aqua>Players<dark_aqua> capture three times as fast. Etc.]>"
        - narrate ""
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white><dark_aqua>Defending Players<white> can slow or stop a capture.|<dark_aqua>Each <aqua>Defending Player<dark_aqua> cancels one <aqua>Attackers damage<dark_aqua>.]>"
        - narrate ""
      - case 3:
        - narrate "<gold><&lb>OUTPOST<&rb> INFO - TEAMS AND PERSONAL COLOURS"
       # - narrate "<proc[msgHover].context[<white> - To capture an Outpost|<dark_aqua>The Outposts name will appear in Chat<&nl><dark_aqua> and its HP bar will flash on your HUD.]><white>,<proc[msgHover].context[<white> find its <dark_aqua>Capture Zone<white>.|<dark_aqua>The Outposts name will appear in Chat<&nl><dark_aqua> and its HP bar will flash on your HUD.]>"
        - ^narrate "<proc[msgHover].context[<aqua> <&gt> Mouse over any line with a <&gt> symbol.|<aqua> A <gold>gold <&gt><aqua> means that line is clickable!]>" targets:<player>
        - narrate ""
        - narrate "<white> - You capture <dark_aqua>Outposts<white> for your <dark_aqua>Team<white>."
        - narrate "<white> - You can capture <dark_aqua>Outposts<white> for any <dark_aqua>Team<white>."
        - narrate ""
        - narrate "<white> - <dark_aqua>Personal Colours<white> are decorative."
        - narrate "<white> - They don't affect your <dark_aqua>Team<white>."
        - narrate ""
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt><white> Some <dark_aqua>Teams<white> are <dark_aqua>Nation Defaults<white>.|<dark_aqua>If you're Irish your <aqua>Nation Default<dark_aqua> is <dark_green>Dark Green<dark_aqua>.<&nl><dark_aqua>If you're English your <aqua>Nation Default<dark_aqua> is <blue>Blue<dark_aqua>. Etc.]>"
        - narrate ""
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt><white> Killing a <dark_aqua>Teammate<white> resets them back to their <dark_aqua>Nation Default<white>.|<dark_aqua>A <blue>Blue<dark_aqua> <aqua>Irishman<dark_aqua> and a <blue>Blue <aqua>Englishman <dark_aqua>both get killed by a <blue>Blue <aqua>Scotsman<dark_aqua>.<&nl><&nl><dark_aqua>The <aqua>Irishman<dark_aqua> gets reset to <dark_green>Dark Green.<&nl><dark_aqua>The <aqua>Englishman<dark_aqua> stays <blue>Blue<dark_aqua> because its his <aqua>Nation Default<dark_aqua>.<&nl><&nl><dark_aqua>If the <dark_green>Dark Green<aqua> Irishman<dark_aqua> now kills the <blue>Blue <aqua>Scotsman<&nl><dark_aqua>the <aqua>Scotsman<dark_aqua> would not reset because they are no longer <aqua>Teammates<dark_aqua>.]>"


     ##   - narrate "<proc[msgHover].context[<green> - <bold>Reduce the Outpost HP to zero to capture it!|<dark_aqua>Most Outposts start with 1000 HP.]>"
     #   - narrate "<proc[msgHover].context[<white> - <dark_aqua>Breaking an obsidian block<white> will immediately deal 100 damage|<dark_aqua>Capture Zones have 5 obsidian blocks inside them.]>"
     #   - narrate "<proc[msgHover].context[<white> - to the Outpost.|<dark_aqua>Capture Zones have 5 obsidian blocks inside them.]>"
        - narrate ""
      #  - narrate "<proc[msgHover].context[<white> - <dark_aqua>Multiple Players<white> capture faster.|<dark_aqua>Two Players capture twice as fast.<&nl><dark_aqua>Three Players capture three times as fast. Etc.]>"
      #  - narrate "<proc[msgHover].context[<white> - <dark_aqua>Defending Players<white> can slow or stop a capture.|<dark_aqua>Each Defending Player cancels one Attackers damage.]>"
      - case 4:
        - narrate "<gold><&lb>OUTPOST<&rb> INFO - TRAINING"
     #   - narrate "<proc[msgHover].context[<white> - To capture an Outpost|<dark_aqua>The Outposts name will appear in Chat<&nl><dark_aqua> and its HP bar will flash on your HUD.]><white>,<proc[msgHover].context[<white> find its <dark_aqua>Capture Zone<white>.|<dark_aqua>The Outposts name will appear in Chat<&nl><dark_aqua> and its HP bar will flash on your HUD.]>"
        - narrate "<white> - Stand inside your <dark_aqua>Outposts Capture Zone<white> at <dark_aqua>Training Time"
        - narrate "<white> - to receive a training buff:"
        
        - narrate ""
        - narrate "<white> - <dark_aqua>+1 Experience Level"
        - narrate "<white> - <dark_aqua>+1 McMMO Level <white>(if Minecraft Level 30)"
        - narrate "<white> - <dark_aqua>+20 minutes Outpost Spell Effect <white>(if Minecraft Level 60)"
        - narrate ""
        - narrate "<white> - You cannot train at <dark_aqua>Enemy Outposts."
        - narrate ""
        - narrate "<white> - You can only train once per <dark_aqua>Training Time."
        - narrate "<white> - (<dark_aqua>Dawn<white>, <dark_aqua>Noon<white>, <dark_aqua>Dusk<white>, <dark_aqua>Midnight<white>)"
        - narrate ""

      - case 5:
        - narrate "<gold><&lb>OUTPOST<&rb> INFO - TOWN CONTROL"
        - ^narrate "<proc[msgHover].context[<aqua> <&gt> Mouse over any line with a <&gt> symbol.|<aqua> A <gold>gold <&gt><aqua> means that line is clickable!]>" targets:<player>
        - narrate ""
        - narrate "<white> - Most <dark_aqua>Outposts<white> are attached to a <dark_aqua>Town<white>."
        - narrate " "

        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>Owning an <dark_aqua>Outpost Control Zone <white>will slowly increase|<dark_aqua>Your <aqua>Town Influence<dark_aqua> will either <green>increase<dark_aqua> or <red>decrease<dark_aqua> every <aqua>Training Time<dark_aqua>.<&nl><&nl><dark_aqua> - Your <aqua>Town Influence<dark_aqua> will <green>increase<dark_aqua> by <aqua>1<dark_aqua> for every <aqua>Outpost<dark_aqua> your <aqua>Team<dark_aqua> owns.<&nl><dark_aqua>   (<aqua>+3 TS<dark_aqua> when you own <aqua>3 Outposts<dark_aqua>)<&nl><&nl><dark_aqua> - Your <aqua>Town Influence<dark_aqua> will <red>decrease<dark_aqua> by <aqua>1<dark_aqua> if you don't own that <aqua>Outpost<dark_aqua>.]>"
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>your <dark_aqua>Town Influence <white>with that <dark_aqua>Outpost Town<white>.|<dark_aqua>Your <aqua>Town Influence<dark_aqua> will either <green>increase<dark_aqua> or <red>decrease<dark_aqua> every <aqua>Training Time<dark_aqua>.<&nl><&nl><dark_aqua> - Your <aqua>Town Influence<dark_aqua> will <green>increase<dark_aqua> by <aqua>1<dark_aqua> for every <aqua>Outpost<dark_aqua> your <aqua>Team<dark_aqua> owns.<&nl><dark_aqua>   (<aqua>+3 TS<dark_aqua> when you own <aqua>3 Outposts<dark_aqua>)<&nl><&nl><dark_aqua> - Your <aqua>Town Influence<dark_aqua> will <red>decrease<dark_aqua> by <aqua>1<dark_aqua> if you don't own that <aqua>Outpost<dark_aqua>.]>"
        
        - narrate " "
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>The <dark_aqua>Team<white> with the highest <dark_aqua>Town Influence<white> at each <dark_aqua>Town|<dark_aqua>If your <aqua>Team<dark_aqua> has the highest <aqua>Town Influence<dark_aqua> at an <aqua>Outpost Town<&nl><dark_aqua>the <aqua>Town<dark_aqua> will ally with the <aqua>Nation<dark_aqua> associated with your <aqua>Team.<&nl><&nl><dark_aqua>Your <aqua>Nation<dark_aqua> will have full access to that <aqua>Outpost Town<dark_aqua> (<green>Ally perms ON<dark_aqua>).<&nl><&nl><aqua>Wild Teams <dark_aqua>will switch <green>Outsider perms ON<dark_aqua> instead.]>"
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>will have <green>Full Build Perms<white> at that <dark_aqua>Town<white>.|<dark_aqua>If your <aqua>Team<dark_aqua> has the highest <aqua>Town Influence<dark_aqua> at an <aqua>Outpost Town<&nl><dark_aqua>the <aqua>Town<dark_aqua> will ally with the <aqua>Nation<dark_aqua> associated with your <aqua>Team.<&nl><&nl><dark_aqua>Your <aqua>Nation<dark_aqua> will have full access to that <aqua>Outpost Town<dark_aqua> (<green>Ally perms ON<dark_aqua>).<&nl><&nl><aqua>Wild Teams <dark_aqua>will switch <green>Outsider perms ON<dark_aqua> instead.]>"
     #   - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>Each <dark_aqua>Outpost Town<white> will ally with the <dark_aqua>Team <white>with|<dark_aqua>Your <aqua>Team<dark_aqua> will have full access to that <aqua>Outpost Town<dark_aqua> (<aqua>Ally perms ON<dark_aqua>).<&nl><aqua>Wild Teams <dark_aqua>will switch <aqua>Outsider perms ON<dark_aqua> instead.]>"
     #   - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>the highest <dark_aqua>Town Influence<white> with that <dark_aqua>Outpost Town<white>.|<dark_aqua>Your <aqua>Team<dark_aqua> will have full access to that <aqua>Outpost Town<dark_aqua> (<aqua>Ally perms ON<dark_aqua>).<&nl><aqua>Wild Teams <dark_aqua>will switch <aqua>Outsider perms ON<dark_aqua> instead.]>"
     #   - narrate " "
     #   - narrate "<white> - If your <dark_aqua>Team<white> is a <dark_aqua>Nation<white>, the <dark_aqua>Outpost Town<white> will add all"
     #   - narrate "<white> - your <dark_aqua>Nation Allies<white> to its <dark_aqua>Allies<white> list as well."
        - narrate " "

     #   - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <white>If your <dark_aqua>Team<white> is a <dark_aqua>Nation|<dark_aqua>When you capture a <aqua>Control Zone<dark_aqua> at a <aqua>Town<dark_aqua> that your <aqua>War Target<dark_aqua> controls<&nl><dark_aqua>your own <aqua>Town Influence<dark_aqua> will not increase.<&nl><&nl><dark_aqua>Your <aqua>War Targets Town Influence<dark_aqua> will <red>decrease<dark_aqua> instead.<&nl><dark_aqua>(<aqua>-3 TS<dark_aqua> if you own <aqua>3 Outposts<dark_aqua>.)]><white>, <proc[msgHover].context[your first <dark_aqua>Nation Enemy <white>is|<dark_aqua>When you capture a <aqua>Control Zone<dark_aqua> at a <aqua>Town<dark_aqua> that your <aqua>War Target<dark_aqua> controls<&nl><dark_aqua>your own <aqua>Town Influence<dark_aqua> will not increase.<&nl><&nl><dark_aqua>Your <aqua>War Targets Town Influence<dark_aqua> will <red>decrease<dark_aqua> instead.<&nl><dark_aqua>(<aqua>-3 TS<dark_aqua> if you own <aqua>3 Outposts<dark_aqua>.)]>"
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <dark_aqua>Team Leaders<white> (<dark_aqua>Kings<white>) can add <dark_aqua>Ally Teams<white>.|<aqua>Ally Teams<dark_aqua> will also have access to your <aqua>Outpost Towns<dark_aqua>.<&nl><aqua>Ally Teams<dark_aqua> will have the exact same permissions that you do.]>"
        - narrate " "
        - narrate "<proc[msgHover].context[<dark_aqua> <&gt> <dark_aqua>Team Leaders<white> (<dark_aqua>Kings<white>) can choose a <dark_aqua>War Target<white>.|<dark_aqua>When you capture a <aqua>Control Zone<dark_aqua> at a <aqua>Town<dark_aqua> that your <aqua>War Target<dark_aqua> controls<&nl><dark_aqua>your own <aqua>Town Influence<dark_aqua> will not increase.<&nl><&nl><dark_aqua>Your <aqua>War Targets Town Influence<dark_aqua> will <red>decrease<dark_aqua> instead.<&nl><dark_aqua>(<aqua>-3 TS<dark_aqua> if you own <aqua>3 Outposts<dark_aqua>.)]>"
        - narrate ""

      - default:
        - narrate "<gold><&lb>OUTPOST<&rb> INFO"
    - choose <context.args.get[2]||1>:
      - case 1:
        - narrate "<proc[msgCommand].context[ <gold><&gt> <gold><&lb> <green>1 <gold><&rb>|outpost info 1|<green>Page 1 - Index]><gold><proc[msgCommand].context[ <green><&gt><&gt> <gold><&lb><gold>2<gold><&rb> |outpost info 2|<gold>Page 2 - Capturing an Outpost]><proc[msgCommand].context[<gold><&lb><gold>3<gold><&rb> |outpost info 3|<gold>Page 3 - Teams and Personal Colours]><proc[msgCommand].context[<gold><&lb><gold>4<gold><&rb> |outpost info 4|<gold>Page 4 - Training]><proc[msgCommand].context[<gold><&lb><gold>5<gold><&rb> <gold><&lt> |outpost info 5|<gold>Page 5 - Town Control]>" targets:<player>

      - case 2:
        - narrate "<proc[msgCommand].context[ <gold><&gt> <gold><&lb><gold>1<gold><&rb> <green><&lt><&lt> |outpost info 1|<gold>Page 1 - Index]><proc[msgCommand].context[<gold><&lb> <green>2 <gold><&rb>|outpost info 2|<green>Page 2 - Capturing an Outpost]><gold><proc[msgCommand].context[ <green><&gt><&gt> <gold><&lb><gold>3<gold><&rb> |outpost info 3|<gold>Page 3 - Teams and Personal Colours]><proc[msgCommand].context[<gold><&lb><gold>4<gold><&rb> |outpost info 4|<gold>Page 4 - Training]><proc[msgCommand].context[<gold><&lb><gold>5<gold><&rb> <gold><&lt> |outpost info 5|<gold>Page 5 - Town Control]>" targets:<player>

      - case 3:
        - narrate "<proc[msgCommand].context[ <gold><&gt> <gold><&lb><gold>1<gold><&rb>|outpost info 1|<gold>Page 1 - Index]><proc[msgCommand].context[ <gold><&lb><gold>2<gold><&rb> <green><&lt><&lt> |outpost info 2|<gold>Page 2 - Capturing an Outpost]><proc[msgCommand].context[<gold><&lb> <green>3 <gold><&rb>|outpost info 3|<green>Page 3 - Teams and Personal Colours]><gold><proc[msgCommand].context[ <green><&gt><&gt> <gold><&lb><gold>4<gold><&rb> |outpost info 4|<gold>Page 4 - Training]><proc[msgCommand].context[<gold><&lb><gold>5<gold><&rb> <gold><&lt> |outpost info 5|<gold>Page 5 - Town Control]>" targets:<player>

      - case 4:
        - narrate "<proc[msgCommand].context[ <gold><&gt> <gold><&lb><gold>1<gold><&rb>|outpost info 1|<gold>Page 1 - Index]><proc[msgCommand].context[ <gold><&lb><gold>2<gold><&rb>|outpost info 2|<gold>Page 2 - Capturing an Outpost]><proc[msgCommand].context[ <gold><&lb><gold>3<gold><&rb> <green><&lt><&lt> |outpost info 3|<gold>Page 3 - Teams and Personal Colours]><proc[msgCommand].context[<gold><&lb> <green>4 <gold><&rb>|outpost info 4|<green>Page 4 - Training]><gold><proc[msgCommand].context[ <green><&gt><&gt> <gold><&lb><gold>5<gold><&rb> <gold><&lt> |outpost info 5|<gold>Page 5 - Town Control]>" targets:<player>

      - case 5:
        - narrate "<proc[msgCommand].context[ <gold><&gt> <gold><&lb><gold>1<gold><&rb>|outpost info 1|<gold>Page 1 - Index]><proc[msgCommand].context[ <gold><&lb><gold>2<gold><&rb>|outpost info 2|<gold>Page 2 - Capturing an Outpost]><proc[msgCommand].context[ <gold><&lb><gold>3<gold><&rb>|outpost info 3|<gold>Page 3 - Teams and Personal Colours]><proc[msgCommand].context[ <gold><&lb><gold>4<gold><&rb> <green><&lt><&lt> |outpost info 4|<gold>Page 4 - Training]><proc[msgCommand].context[<gold><&lb> <green>5 <gold><&rb> <gold><&lt> |outpost info 5|<green>Page 5 - Town Control]><gold>" targets:<player>

      - default:
        - narrate "<proc[msgCommand].context[ <gold><&gt> <gold><&lb> <green>1 <gold><&rb>|outpost info 1|<green>Page 1 - Index]><gold><proc[msgCommand].context[ <green><&gt><&gt> <gold><&lb><gold>2<gold><&rb> |outpost info 2|<gold>Page 2 - Capturing an Outpost]><proc[msgCommand].context[<gold><&lb><gold>3<gold><&rb> |outpost info 3|<gold>Page 3 - Teams and Personal Colours]><proc[msgCommand].context[<gold><&lb><gold>4<gold><&rb> |outpost info 4|<gold>Page 4 - Training]><proc[msgCommand].context[<gold><&lb><gold>5<gold><&rb> <gold><&lt> |outpost info 5|<gold>Page 5 - Town Control]>" targets:<player>
    - ^narrate "<proc[msgCommand].context[<gold><&lt><&lt> BACK|outpost|<gold>Back to Outpost Menu]>" targets:<player>

TeaOutpost_Task:
  type: task
  debug: false
  script:
  #  - announce "yessir!"
    - while <player.flag[CreatingTeaOutpost]||false> :
      #- announce "nice!"
      - define GreenLocations <player.location.add[0,-10,0]>
      - define RedLocations <player.location.add[0,-10,0]>
      - choose "<player.location.direction>":
        - case "north":
          - define FacingTime Noon
          - define FacingLocation <player.location.add[0,-1,-2]>
        - case "northeast":
          - define FacingTime Noon
          - define FacingLocation <player.location.add[0,-1,-2]>
        - case "east":
          - define FacingTime Dawn
          - define FacingLocation <player.location.add[2,-1,0]>
        - case "southeast":
          - define FacingTime Dawn
          - define FacingLocation <player.location.add[0,-1,2]>
        - case "south":
          - define FacingTime Midnight
          - define FacingLocation <player.location.add[0,-1,2]>
        - case "southwest":
          - define FacingTime Midnight
          - define FacingLocation <player.location.add[0,-1,2]>
        - case "west":
          - define FacingTime Dusk
          - define FacingLocation <player.location.add[-2,-1,0]>
        - case "northwest":
          - define FacingTime Dusk
          - define FacingLocation <player.location.add[2,-1,0]>
        - default:
          - define FacingTime Noon
          - define FacingLocation <player.location.add[0,-1,-2]>
      
      ## ADD GREEN IF HIGHEST, RED IF NOT HIGHEST
      - if <player.location.add[0,-1,0].y> >= <player.location.add[0,-1,0].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-1,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-1,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-1,0]>
          }
      - if <player.location.add[2,-1,2].y> >= <player.location.add[2,-1,2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[2,-1,2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[2,-1,2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[2,-1,2]>
          }
      - if <player.location.add[-2,-1,2].y> >= <player.location.add[-2,-1,2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-2,-1,2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-2,-1,2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-2,-1,2]>
          }
      - if <player.location.add[2,-1,-2].y> >= <player.location.add[2,-1,-2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[2,-1,-2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[2,-1,-2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[2,-1,-2]>
          }
      - if <player.location.add[-2,-1,-2].y> >= <player.location.add[-2,-1,-2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-2,-1,-2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-2,-1,-2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-2,-1,-2]>
          }
      - if <def[FacingLocation].y> >= <def[FacingLocation].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<def[FacingLocation].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|%FacingLocation%
        }
        else {
          - define RedLocations %RedLocations%|%FacingLocation%
          }
      ## ALSO CHECK TOP
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,10,10]>
          }
      ## --
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,10,-10]>
          }
      ## ALSO CHECK MIDDLE
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-1,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-1,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-1,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-1,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-1,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-1,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-1,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-1,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-1,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-1,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-1,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-1,10]>
          }
      ## --
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-1,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-1,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-1,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-1,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-1,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-1,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-1,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-1,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-1,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-1,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-1,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-1,-10]>
          }
      ## ALSO CHECK MIDDLE
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-10,10]>
          }
      ## --
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-10,-10]>
          }
      ## SHOW FAKE IF RELEVANT
      - title subtitle:%FacingTime%
      - showfake lime_stained_glass %GreenLocations% players:<player.location.find.players.within[25].as_list> d:2s
      - showfake red_stained_glass %RedLocations% players:<player.location.find.players.within[25].as_list> d:2s
      - if %RedLocations% == <player.location.add[0,-10,0]> {
        - title subtitle:<green>%FacingTime%
        - flag <player> TeaOutpostGoodSpotCheck:true
        }
        else {
          - title subtitle:<dark_red>%FacingTime%
          - flag <player> TeaOutpostGoodSpotCheck:false
          }
      - wait 2s

CTPInitializeTask:
  type: task
  debug: false
  script:
    - ^if <server.flag[%CuboidName%IsSilent]||false> == false {
      - playsound <player> sound:note_piano volume:0.5 pitch:<math:0.5+0.1*<cu@%CuboidName%.list_players.size>>
      }
    - ^if <cu@%CuboidName%.list_players.size> == 1 || <server.flag[%CuboidName%obbyactivation]||false> == true {
      - flag server %CuboidName%obbyactivation:false
      - ^define CaptureColour <server.flag[CurrentCapturerof%CuboidName%]||<server.flag[Ownerof%CuboidName%Secondary]||Gray>>
      - ^define AttackColour <server.flag[CurrentCapturerof%CuboidName%]||Gray>
      - ^define AttackColourSecondary <server.flag[CurrentCapturerof%CuboidName%Secondary]||Dark_Gray>
      - ^define OwnerColour <server.flag[Ownerof%CuboidName%]||Gray>
      - ^define OwnerColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
      - ^define ActiveColour <tern[<server.flag[CurrentCapturerof%CuboidName%].is[==].to[Gray]||true>]:<def[OwnerColour]>||<def[AttackColour]>>
      - ^if <server.flag[%CuboidName%IsSilent]||false> == false {
        - ^adjust <player> action_bar:<%ActiveColour%><bold><math.as_int:<server.flag[CTPPointHealth%CuboidName%]||0>-<server.flag[%AttackColour%Captureof%CuboidName%].as_int||0>>
      }
      - wait 1t
      - ^if <server.flag[%CuboidName%containsplayers]||false> == false {
        - ^flag global %CuboidName%containsplayers:true
        - run CPCaptureTasktest def:%CuboidName%|cu@%CuboidName%|%CuboidName%containsplayers
      }
   #   - ^if <server.flag[%CuboidName%entryscriptlist].size||0> > 0 {
   #     - ^foreach <server.flag[%CuboidName%entryscriptlist].as_list> {
   #       - announce "<gray>Tea: Injecting entry script %value%" to_flagged:DreamListener
   #       - inject %value%
   #     }
   #   }
      else {
        - announce "<gray><bold>NoonLight<gray>: <yellow>Entry task list is empty! <gray>%CuboidName%.entry.script.list" to_flagged:NoonLightDiagnostic
      }
    }

CTPFinalizeTask:
  type: task
  debug: false
  script:
    - ^if <cu@%CuboidName%.list_players.size> == 0 {
      - ^flag global %CuboidName%containsplayers:false
      - ^if <server.flag[%CuboidName%leavingscriptlist].size||0> > 0 {
        - ^announce "<gray><bold>NoonLight<gray>: Leave-injecting <server.flag[%CuboidName%leavingscriptlist].replace[|].with[,<&sp>].replace[li@].with[]>: %CuboidName%.leaving.script.list" to_flagged:NoonLightDiagnostic
        - ^foreach <server.flag[%CuboidName%leavingscriptlist].as_list> {
          - inject %value%
        }
      }
      else {
        - announce "<gray><bold>NoonLight<gray>: <yellow>Leave task list is empty! <gray>%CuboidName%.leaving.script.list" to_flagged:NoonLightDiagnostic
      }
    }
 


TeaOutpost_World: 
  type: world
  debug: false
  events: 
    on server start:
    - wait 1m
    - run TeaOutpost_periodical_unload
    on player login:
    - wait 4s
    - define Colour <player.flag[RaceColour]||null>
    - define NationName <player.nation.replace[nation@].with[]||Nationless>
    - if <def[Colour]> != null {
      - announce "<gray>Returning Player! <player.name> is <%Colour%>%Colour%" to_flagged:DreamListener
      }
      else {
        - define NationDefault <server.flag[TeaOutpost_%NationName%DefaultColour]||null>
        - if <def[NationDefault]||null> != null {
          - flag <player> RaceColour:%NationDefault%
          - flag <player> RaceColourSecondary:White
          }
          else {
            - flag <player> RaceColour:White
            - flag <player> RaceColourSecondary:White
            }
        - define Colour <player.flag[RaceColour]||null>
        - announce "<gray>New Player! <player.name> flagged <%NationDefault%>%NationDefault% / %NationName%" to_flagged:DreamListener
        }
    - if <def[NationName]> != null {
      - define NationKing <nation@%NationName%.king>
      - if <player> == <def[NationKing]> || <player.town.assistants.contains[<player>]||false> {
        - flag <player> TeaOutpostKingPass:true
        - announce "<gray>Returning King! <player.name> is <%Colour%>King/Assistant of %NationName%" to_flagged:DreamListener
        }
        else {
          - flag <player> TeaOutpostKingPass:!
          - announce "<gray>Returning Player! <player.name> is not King" to_flagged:DreamListener
          }
      }
      else {
        - flag <player> TeaOutpostKingPass:!
        - announce "<gray>New Player! <player.name> is nationless" to_flagged:DreamListener
        }

    
    on player enters notable cuboid:
    - if <server.flag[TeaOutpostList].as_list.contains_any[<context.cuboids>]||false> == true {
      - foreach <context.cuboids> {
        - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
          - define CuboidName <def[value].replace[cu@].with[]>
        #  - announce "<dark_gray>This is an outpost! %value%"
          - foreach stop
          }
          else {
            - define CuboidName Next
            }
        }
      - if <def[CuboidName]||Next == Next {
        - queue clear
        }
      - if <server.flag[CTPPointList].contains[cu@%CuboidName%]||false> == true {
        - ^if <server.flag[%CuboidName%entryscriptlist].size||0> > 0 {
          - ^foreach <server.flag[%CuboidName%entryscriptlist].as_list> {
            - announce "<gray>Tea: Injecting entry script %value%" to_flagged:DreamListener
            - inject %value%
          }
        }
        - wait 1t
        - inject CTPInitializeTask
        }
      }

    on player exits notable cuboid:
    - if <server.flag[TeaOutpostList].as_list.contains_any[<context.cuboids>]||false> == true {
      - foreach <context.cuboids> {
        - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
          - define CuboidName <def[value].replace[cu@].with[]>
         # - announce "<dark_gray>This was an outpost! %value%"
          - foreach stop
          }
          else {
            - define CuboidName Next
            }
        }
      - if <server.flag[CTPPointList].contains[cu@%CuboidName%]||false> == true {
        - wait 1t
        - inject CTPFinalizeTask
        }
      }


    on player places obsidian:
   # - announce "broken! <context.location>"
   # - announce "<server.flag[TeaOutpostList].as_list.contains_any[<context.location.cuboids>]||false>"
    - foreach <context.location.cuboids> {
      - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
      #  - announce "%value%"
        - define CuboidName <def[value].replace[cu@].with[]>
        - foreach stop
        }
      }
    - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
   # - announce "<server.flag[%CuboidName%ObsidianLocations].as_list>"
    - if <%ObsidianList%.contains[<context.location>]||false> == true {
   #   - if <server.flag[CTPPointList].contains[cu@%CuboidName%]||false> == true {
      - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> Please allow this outpost to reset itself. <server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>

      - determine cancelled
    #    }
    #    else {
    #      - flag server %CuboidName%ObsidianCount:++
         # - announce "thats one! %CuboidName% <server.flag[%CuboidName%ObsidianCount].as_int||0>/5"
    #      - if <server.flag[%CuboidName%ObsidianCount]||0> > 4 {
    #        - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> <bold>All obsidian have been replaced.|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
    #        - flag server %CuboidName%ObsidianCount:5
           # - run TeaOutpost_Reset_Task def:%CuboidName%|<player.name>
    #        }
    #        else {
    #          - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> An obsidian has been replaced. <server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
    #          }
    #      }
      }
    on player breaks block priority:999 ignorecancelled:true:
    - foreach <context.location.cuboids> {
      - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
      #  - announce "%value%"
        - define CuboidName <def[value].replace[cu@].with[]>
        - foreach stop
        }
        else {
        - define CuboidName Cancel
        }
      }
    - if <def[CuboidName]||Cancel> == Cancel {
      - queue clear
      }
  #  - if <context.material> == m@obsidian {
   
   
    - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
   # - announce "<server.flag[%CuboidName%ObsidianLocations].as_list>"
    - if <%ObsidianList%.contains[<context.location>]||false> == true {
    #  - if <server.flag[Ownerof%CuboidName%]||Gray> == <player.flag[RaceColour]||Gray> {
    #    - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
    #    - determine cancelled
    #    }
    #
    #  - flag server %CuboidName%ObsidianCount:--
     # - announce "thats one! %CuboidName% <server.flag[%CuboidName%ObsidianCount].as_int||0>/5"
      - if <context.material> == m@obsidian {
        - if <server.flag[Ownerof%CuboidName%]||Gray> == <player.flag[RaceColour]||Gray> {
          - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
          - determine cancelled
          }
     
        - flag server %CuboidName%ObsidianCount:--
        - if <server.flag[%CuboidName%ObsidianCount]||0> < 1 {
          - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
        #  - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
        #  - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
          - define PointHealth <server.flag[CTPPointHealth%CuboidName%]||1000>
          - flag server CTPPointHealth%CuboidName%:<math:<def[PointHealth]>-<server.flag[OutpostObsidianDamage]||0>>

          - if <player.flag[TeaOutpostBypass]||false> != false {
            - flag server %CaptureCount%:<server.flag[CTPPointHealth%CuboidName%].sub[1]||0>
            }
          - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> <bold>All obsidian have been broken!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
        #  - flag server %CuboidName%ObsidianCount:5
        #  - run TeaOutpost_Reset_Task def:%CuboidName%|<player.name>
         # - flag server CTPPointList:->:cu@%CuboidName%
          - flag server %CuboidName%obbyactivation:true
          - inject CTPInitializeTask
     
          }
          else {
           # - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
            - define PointHealth <server.flag[CTPPointHealth%CuboidName%]||1000>
            - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
            - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
           # - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
            - flag server CTPPointHealth%CuboidName%:<math:<def[PointHealth]>-<server.flag[OutpostObsidianDamage]||0>>
            - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> An obsidian has been broken! <%Colour%><server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<%Colour%><server.flag[%CuboidName%DisplayName]||The<&sp>Outpost> (<server.flag[%CuboidName%TrainingFocus]||MCMMO>) <%ColourSecondary%>-<%Colour%> <server.flag[%Colour%DisplayName]||<def[Colour].to_titlecase>> <util.date.time>]>" targets:<player.location.find.players.within[70]>
            }
          }
          else {
          #  - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
            - determine cancelled
            }
      - wait 1t
      - modifyblock <context.location> white_wool
      }
      
      
      
      else {
        - wait 1t
        - modifyblock <context.location> air naturally
        }
   
   
   
   #   }
   #   else {
   #     - modifyblock <context.location> air naturally
   #     }
    - announce "<player.name> broke a <context.material> and was denied!" to_flagged:DreamListener
  #  - if <context.cancelled||false> && <player.flag[PvpBypass]||false> == true {
  #    - hurt <context.final_damage> <context.entity>
  #  }
 #   on player breaks block priority:998:
 #   - if <player.name> == shooshooshoo {
 #     - determine cancelled
 #     }
  #  on player breaks block priority:1000 cancelled:true:
  #  - announce "<player.name> broke a block and was denied!2" to_flagged:DreamListener2

 #   on player breaks obsidian:
 #  # - announce "broken! <context.location>"
 #  # - announce "<server.flag[TeaOutpostList].as_list.contains_any[<context.location.cuboids>]||false>"
 #   - foreach <context.location.cuboids> {
 #     - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
 #     #  - announce "%value%"
 #       - define CuboidName <def[value].replace[cu@].with[]>
 #       - foreach stop
 #       }
 #       else {
 #       - define CuboidName Cancel
 #       }
 #     }
 #   - if <def[CuboidName]||Cancel> == Cancel {
 #     - queue clear
 #     }
 #   - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
 #  # - announce "<server.flag[%CuboidName%ObsidianLocations].as_list>"
 #   - if <%ObsidianList%.contains[<context.location>]||false> == true {
 #     - if <server.flag[Ownerof%CuboidName%]||Gray> == <player.flag[RaceColour]||Gray> {
 #       - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
 #       - determine cancelled
 #       }
 #     - flag server %CuboidName%ObsidianCount:--
 #    # - announce "thats one! %CuboidName% <server.flag[%CuboidName%ObsidianCount].as_int||0>/5"
 #     - if <server.flag[%CuboidName%ObsidianCount]||0> < 1 {
 #       - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
 #       - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
 #       - if <player.flag[TeaOutpostBypass]||false> != false {
 #         - flag server %CaptureCount%:<server.flag[CTPPointHealth%CuboidName%].sub[1]||0>
 #         }
 #       - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> <bold>All obsidian have been broken!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
 #     #  - flag server %CuboidName%ObsidianCount:5
 #     #  - run TeaOutpost_Reset_Task def:%CuboidName%|<player.name>
 #      # - flag server CTPPointList:->:cu@%CuboidName%
 #       - flag server %CuboidName%obbyactivation:true
 #       - inject CTPInitializeTask
 #
 #       }
 #       else {
 #         - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
 #         - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
 #         - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
 #         - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
 #         - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> An obsidian has been broken! <%Colour%><server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<%Colour%><server.flag[%CuboidName%DisplayName]||The<&sp>Outpost> (<server.flag[%CuboidName%TrainingFocus]||MCMMO>) <%ColourSecondary%>-<%Colour%> <server.flag[%Colour%DisplayName]||<def[Colour].to_titlecase>> <util.date.time>]>" targets:<player.location.find.players.within[70]>
 #         }
 #     }

#MIDNIGHT
    on time 22 in world:
    - wait 30s
    - announce "<red>It's PreMidnight" to_flagged:DreamListener
    - flag server MidnightTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Midnight
      }
    on time 0 in world:
    - announce "<red>It's Midnight" to_flagged:DreamListener
    - flag server MidnightTraining:true
    on time 1 in world:
    - announce "<red>It's PostMidnight" to_flagged:DreamListener
    - flag server MidnightTraining:false
#DAWN
    on time 3 in world:
    - wait 40s
    - announce "<red>It's PreDawn" to_flagged:DreamListener
    - flag server DawnTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Dawn
      }
    on time 5 in world:
    - announce "<red>It's Dawn" to_flagged:DreamListener
    - flag server DawnTraining:true
    on time 6 in world:
    - wait 30s
    - announce "<red>It's PostDawn" to_flagged:DreamListener
    - flag server DawnTraining:false
#NOON
    on time 10 in world:
    - announce "<red>It's PreNoon" to_flagged:DreamListener
    - flag server NoonTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Noon
      }
    on time 12 in world:
    - announce "<red>It's Noon" to_flagged:DreamListener
    - flag server NoonTraining:true
    on time 14 in world:
    - announce "<red>It's PostNoon" to_flagged:DreamListener
    - flag server NoonTraining:false
#DUSK
    on time 17 in world:
    - wait 30s
    - announce "<red>It's PreDusk" to_flagged:DreamListener
    - flag server DuskTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Dusk
      }
    on time 19 in world:
    - announce "<red>It's Dusk" to_flagged:DreamListener
    - flag server DuskTraining:true
    on time 20 in world:
    - wait 30s
    - announce "<red>It's PostDusk" to_flagged:DreamListener
    - flag server DuskTraining:false
  #  - announce "<red>It's PreMidnight" to_flagged:DreamListener
  #  - flag server MidnightTraining:true
  #  - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
  #    - flag server TrainingCuboidCheckIsActive:true
  #    - run TeaOutpost_TrainingCuboidCheck def:Midnight
  #    }

TeaOutpost_SingleTrainingCuboidCheck:
  type: task
  debug: false
  script:
    - define CuboidName <def[2]>
    - foreach <cu@%CuboidName%.list_players> {
      - define PlayerName <%value%.name>
      - define Player <%value%>
      - if <%player%.flag[RaceColour]||Gray> == <server.flag[Ownerof%CuboidName%]||Gray> {
        - inject TeaOutpost_CuboidCheckTrainer
        }
      }

TeaOutpost_TrainingCuboidCheck:
  type: task
  debug: false
  script:
    - foreach <server.flag[TeaOutpostList].as_list> {
      - define CuboidName <%value%.replace[cu@].with[]>
     # - announce "%CuboidName%"
      - foreach <cu@%CuboidName%.list_players> {
        - define PlayerName <%value%.name>
        - define Player <%value%>
        - if <%player%.flag[RaceColour]||Gray> == <server.flag[Ownerof%CuboidName%]||Gray> {
          - inject TeaOutpost_CuboidCheckTrainer
          }
        }
      }
    - foreach <server.flag[TeaOutpostList].as_list> {
      - define CuboidName <%value%.replace[cu@].with[]>
      - if <server.flag[%CuboidName%TrainingTime]||Null> == <def[1]> {
        - inject TeaOutpost_TownInfluenceTask
        }
      }
    - foreach <server.flag[TeaOutpostList].as_list> {
      - define CuboidName <%value%.replace[cu@].with[]>
      - if <server.flag[%CuboidName%TrainingTime]||Null> == <def[1]> {
        - inject TeaOutpost_HighestInfluenceChooserTask
        }
      }
    - flag server TrainingCuboidCheckIsActive:false
  #  - announce "<server.flag[%CuboidName%TrainingTime]||Error> time"
  #  - define CuboidTime <server.flag[%CuboidName%TrainingTime]||Error>
  #  - if <server.flag[%CuboidTime%Training]||false> {
  #    - announce "you can train"
  #  }
TeaOutpost_TownInfluenceTask:
  type: task
  debug: false
  script:
    - if <server.flag[%Cuboidname%TownName]||null> != null {
      - define InfluenceID <server.flag[%CuboidName%TownName]>
      }
      else {
        - define InfluenceID %CuboidName%
     #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
        }
    - define OutpostID %CuboidName%
    - define CurrentOwner <server.flag[Ownerof%OutpostID%]||Gray>
    - announce "<gray><bold>Influence Task: <gray><def[1]> for %OutpostID%/%InfluenceID%" to_flagged:DreamListener
    - foreach <server.flag[%InfluenceID%InfluenceList].as_list||li@> {
      - if %CurrentOwner% == %value% {
       # - define CurrentIP <server.flag[%OutpostID%InfluencePoints%value%]||0>
        - define CurrentIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
        - define CurrentTime <util.date.time.hour><util.date.time.minute.replace[regex:^(?!..)].with[0]>
        - define CurrentDate <util.date.time.year><util.date.time.month.replace[regex:^(?!..)].with[0]><util.date.time.day.replace[regex:^(?!..)].with[0]>
        - flag server %InfluenceID%InfluencePoints%value%:<def[CurrentIP].add[1]>
        - if <def[CurrentDate]> != <server.flag[%OutpostID%LastCaptureDate]||0> && <def[CurrentTime]> >= <server.flag[%OutpostID%LastCaptureTime]||0> {
          - flag server %InfluenceID%InfluencePoints%value%:+:<server.flag[%value%OutpostList].as_list.size>
          - announce "establishment boost <server.flag[%value%OutpostList].as_list.size> %value% <def[CurrentDate]> != <server.flag[%OutpostID%LastCaptureDate]||0> <def[CurrentTime]> >= <server.flag[%OutpostID%LastCaptureTime]||0>" to_flagged:DreamListener
          }
        - if <server.flag[%InfluenceID%InfluencePoints%value%]||0> > 1000 {
          - flag server %InfluenceID%InfluencePoints%value%:1000
          }
        - announce "%value%Add<server.flag[%InfluenceID%InfluencePoints%value%]||00>" to_flagged:DreamListener
        
        }
        else {
          - define CurrentIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
          - flag server %InfluenceID%InfluencePoints%value%:<def[CurrentIP].sub[1]>
          - announce "%value%subtract<server.flag[%InfluenceID%InfluencePoints%value%]||00>" to_flagged:DreamListener
          - if <server.flag[%InfluenceID%InfluencePoints%value%]||0> < 0 {
            - flag server %InfluenceID%InfluencePoints%value%:0
            - flag server %InfluenceID%InfluenceList:<-:%value%
            }
          }
      }

TeaOutpost_HighestInfluenceChooserTask:
  type: task
  debug: false
  script:
    - if <server.flag[%Cuboidname%TownName]||null> != null {
      - define InfluenceID <server.flag[%CuboidName%TownName]>
      }
      else {
        - define InfluenceID %CuboidName%
     #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
        }
    - define OutpostID %CuboidName%
    - define CurrentTownOwner <server.flag[TownOwnerof%InfluenceID%]||Gray>
    - announce "<gray><bold>Influence Chooser: <gray><def[1]> for %OutpostID%/%InfluenceID%" to_flagged:DreamListener
    - define MaxIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
    - define MaxIPName %CurrentTownOwner%
    - foreach <server.flag[%InfluenceID%InfluenceList].as_list||li@> {
      - if <def[MaxIP]> < <server.flag[%InfluenceID%InfluencePoints%value%]||0> {
        - define MaxIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
        - define MaxIPName %value%
        }
      }
    - if <server.flag[TownOwnerof%InfluenceID%]||Gray> != <def[MaxIPName]> {
      - flag server TownOwnerof%InfluenceID%:<def[MaxIPName]>
      - flag server TownOwnerof%InfluenceID%Secondary:<def[MaxIPName]>
      - announce "<gray><bold>Influence Chooser:<gray> %OutpostID%/%InfluenceID% Town Owner is now <def[MaxIPName]>" to_flagged:DreamListener
      - inject TeaOutpost_UpdateOutpostTownTask

      }

  #  - announce "%OutpostID% Town Owner is <def[MaxIPName]> with <def[MaxIP]>"

TeaOutpost_CuboidCheckTrainer:
  type: task
  debug: false
  script:
   # - announce "<server.flag[%CuboidName%TrainingTime]||Error> time"
    - define CuboidTime <server.flag[%CuboidName%TrainingTime]||Error>
    - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
    - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
    - if <server.flag[%CuboidTime%Training]||false> && <%Player%.flag[HasTrainedAt%CuboidTime%]||false> != true {
      - flag %Player% HasTrainedAt%CuboidTime%:true duration:10m
      - narrate "<%ColourSecondary%>%CuboidTime% Training begins now." targets:%Player%
      - narrate "<%ColourSecondary%><server.flag[%CuboidName%TrainingMessage]||Error Please Talk to Tea>" targets:%Player%
      - run TeaOutpost_GiveXPTask def:%Player%|%Colour%|%ColourSecondary%|%CuboidName%
    }

TeaOutpost_TimeCheckTask:
  type: task
  debug: false
  script:
  #  - announce "<server.flag[%CuboidName%TrainingTime]||Error> time"
    - define CuboidTime <server.flag[%CuboidName%TrainingTime]||Error>
    - if <server.flag[%CuboidTime%Training]||false> && <player.flag[HasTrainedAt%CuboidTime%]||false> != true && <player.flag[RaceColour]||Gray> == <server.flag[Ownerof%CuboidName%]||Gray> {
      - flag <player> HasTrainedAt%CuboidTime%:true duration:10m
      - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
      - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
      - narrate "<%ColourSecondary%><italic><server.flag[%CuboidName%TrainingMessage]||Error Please Talk to Tea>" targets:<player>
      - define Player <player>
      - run TeaOutpost_GiveXPTask def:%Player%|%Colour%|%ColourSecondary%|%CuboidName%
    }

TeaOutpost_UpdateOutpostTownTask:
  type: task
  debug: false
  script:
    - define ManageName <def[OutpostID]>
    - define ManageNation <server.flag[%ManageName%NationName]||null>
    - define ManageNPC <server.flag[%ManageName%NPCName]||null>
    - define ManageTown <server.flag[%ManageName%TownName]||null>
    - define ManageOwner <server.flag[TownOwnerof%ManageTown%]||Gray>
    - define OwnerNation <server.flag[%ManageOwner%NationName]||Wild>
    - run TeaOutpost_Write_Data def:<def[ManageName]>|<def[ManageTown]>|<def[ManageNation]>|<def[ManageOwner]||Gray>|Influence<&sp>Takeover|<def[OwnerNation]>
    - ^log "<server.flag[TeaOutpost_TotalInfluenceTakeoverCount].round||0> %ManageNation% TAKEOVER <def[ManageOwner]> <def[OwnerNation]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_LOGS.yml
    - ^flag server TeaOutpost_TotalInfluenceTakeoverCount:++
    - if <def[ManageNation]||null> == null || <def[ManageNPC]||null> == null || <def[ManageTown]||null> == null {
      - announce "UpdatingOutpostTownERROR %ManageName%! <server.flag[%ManageName%NationName]||None> - <server.flag[%ManageName%TownName]||None> - <server.flag[%ManageName%NPCName]||None> - " to_flagged:DreamListener
      - queue clear
      }
    - if <def[OwnerNation]> != Wild {
      - if <nation@%ManageNation%.type||null> == null {
        - announce "%ManageNation% is not a Nation" to_flagged:DreamListener
        - queue clear
      }
      - if <server.flag[TeaOutpostRunTowny]||false> == true {
        - execute as_server "dc <def[ManageNPC]> t set perm outsider off"
        }
        else {
          - announce "execute as_server 'dc <def[ManageNPC]> t set perm outsider off' TeaOutpostRunTowny" to_flagged:DreamListener
          }
      - foreach <nation@%ManageNation%.allies||li@> {
        - define AllyName <def[value].replace[nation@].with[]>
        - if <def[AllyName]> != %OwnerNation% {
          - if <server.flag[TeaOutpostRunTowny]||false> == true {
            - execute as_server "dc <def[ManageNPC]> n ally remove %AllyName%"
            }
            else {
              - announce "execute as_server 'dc <def[ManageNPC]> n ally remove %AllyName%' TeaOutpostRunTowny" to_flagged:DreamListener
              }
          }
        - wait 10t
        }
      - if <server.flag[TeaOutpostRunTowny]||false> == true {
        - execute as_server "dc <def[ManageNPC]> n ally add %OwnerNation%"
        }
        else {
          - announce "execute as_server 'dc <def[ManageNPC]> n ally add %OwnerNation%' TeaOutpostRunTowny" to_flagged:DreamListener
          }

      - foreach <server.flag[%ManageName%AllyList].as_list||li@> {
        - define AllyNationName <server.flag[%value%NationName]>
        - if <nation@%AllyNationName%.type||null> == null {
          - announce "%AllyNationName% is not a Nation" to_flagged:DreamListener
          - foreach next
          }
        - if !<nation@%ManageNation%.allies.as_list.contains[nation@%value%]> {
          - if <server.flag[TeaOutpostRunTowny]||false> == true {
            - execute as_server "dc <def[ManageNPC]> n ally add %AllyNationName%"
            }
            else {
              - announce "execute as_server 'dc <def[ManageNPC]> n ally add %AllyNationName%' TeaOutpostRunTowny" to_flagged:DreamListener
              }
          }
        - wait 10t
        }
          
          
          
      }
      else {
        - if <nation@%ManageNation%.type||null> == null {
          - announce "%ManageNation% is not a Nation" to_flagged:DreamListener
          - queue clear
        }
        - foreach <nation@%ManageNation%.allies||li@> {
          - define AllyName <def[value].replace[nation@].with[]>
          - if <server.flag[TeaOutpostRunTowny]||false> == true {
            - execute as_server "dc <def[ManageNPC]> n ally remove %AllyName%"
            }
            else {
              - announce "execute as_server 'dc <def[ManageNPC]> n ally remove %AllyName%' TeaOutpostRunTowny" to_flagged:DreamListener
              }
          
          - wait 10t
          }
          
        - if <server.flag[TeaOutpostRunTowny]||false> == true {
          - execute as_server "dc <def[ManageNPC]> t set perm outsider on"
          }
          else {
            - announce "execute as_server 'dc <def[ManageNPC]> t set perm outsider on' TeaOutpostRunTowny" to_flagged:DreamListener
            }
        }

TeaOutpost_GiveXPTask:
  type: task
  debug: false
  script:
    - define Player <def[1]>
    - define Colour <def[2]>
    - define ColourSecondary <def[3]>
   # - announce "<%Player%.xp.to_next_level>"
    - define XPtonextlevel <%Player%.xp.to_next_level>
    - define XPpercent <%Player%.xp||0>
    - define XPthatplayerhas <el@%XPpercent%.as_int.mul[0.01].mul[%XPtonextlevel%]||0>
    - define XPtogive <el@%XPtonextlevel%.sub[%XPthatplayerhas%].add[1].as_int||%XPtonextlevel%>
   # - announce "%XPtogive%"
   # - define HalfXP <math:%XPqty%*0.5>

    
  #  - give xp quantity:%HalfXP% player:%Player%
    - wait 10t
   # - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
    - title subtitle:<green>+%XPtogive%<&sp>xp targets:%Player%
    - narrate "<%Colour%>Level Up! <%ColourSecondary%>+%XPtogive%<&sp>xp to Level <%Player%.xp.level.add[1]>" targets:%Player%
   # - title subtitle:<green>Lvl<&co><%player%.xp.level>+1 targets:%Player%
    - wait 10t
  #  - repeat %XPtogive% {
  #    - give xp quantity:1 player:%Player%
  #    - wait 5t
  #    }
    - give xp quantity:%XPtogive% player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[4]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
    - give xp quantity:1 player:%Player%
    - ^log "<server.flag[TeaOutpost_TotalTrainingCount].round||0> <def[Player].name> REGULAR <def[Colour]> <def[4]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_TRAINING_LOGS.yml
   # - ^flag server TeaOutpost_TotalTrainingCount:++
    - if <%Player%.xp.level||0> >= 30 {
      - narrate "<%Colour%>MCMMO! <%ColourSecondary%><%Player%.xp.level>+1" targets:%Player%
      - ^log "<server.flag[TeaOutpost_TotalTrainingCount].round||0> <def[Player].name> MCMMO <def[Colour]> <def[4]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_TRAINING_LOGS.yml
    }
    - if <%Player%.xp.level||0> >= 60 {
      - inject TeaOutpost_GiveSpellTask
      - ^log "<server.flag[TeaOutpost_TotalTrainingCount].round||0> <def[Player].name> SPELL <def[Colour]> <def[4]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_TRAINING_LOGS.yml
      }
    - ^flag server TeaOutpost_TotalTrainingCount:++

   # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
   # - run TeaOutpost_OngoingSpellTask def:%CuboidName% delay:1s

TeaOutpost_GiveSpellTask:
  type: task
  debug: false
  script:
    - define CuboidName <def[4]>
    - define Spell <server.flag[%CuboidName%SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck].first>
  #  - define Colour <def[2]>
  #  - define ColourSecondary <def[3]>
   # - announce "<%Player%.xp.to_next_level>"
  #  - define XPtonextlevel <%Player%.xp.to_next_level>
  #  - define XPpercent <%Player%.xp||0>
  #  - define XPthatplayerhas <el@%XPpercent%.as_int.mul[0.01].mul[%XPtonextlevel%]||0>
  #  - define XPtogive <el@%XPtonextlevel%.sub[%XPthatplayerhas%].add[1].as_int||%XPtonextlevel%>
   # - announce "%XPtogive%"
   # - define HalfXP <math:%XPqty%*0.5>

    
  #  - give xp quantity:%HalfXP% player:%Player%
  #  - wait 10t
   # - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
  #  - title subtitle:<green>+%XPtogive%<&sp>xp targets:%Player%
    - narrate "<%Colour%>Spell Up!! <%ColourSecondary%>%Spell%" targets:%Player%
    - flag %Player% %CuboidName%GaveSpell:true duration:19m
    - cast %Spell% <%Player%> duration:20m

   # - title subtitle:<green>Lvl<&co><%player%.xp.level>+1 targets:%Player%
  #  - wait 10t
  #  - repeat %XPtogive% {
  #    - give xp quantity:1 player:%Player%
  #    - wait 5t
  #    }
 #   - give xp quantity:%XPtogive% player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[4]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:1 player:%Player%
  #  - if <%Player%.xp.level||0> >= 30 {
  #    - narrate "<%Colour%>MCMMO! <%ColourSecondary%><%Player%.xp.level>+1" targets:%Player%
  #  }
  #  - if <%Player%.xp.level||0> >= 60 {
  #    - narrate "<%Colour%>Spells! <%ColourSecondary%><%Player%.xp.level>+1" targets:%Player%
  #  }
   # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
   # - run TeaOutpost_OngoingSpellTask def:%CuboidName% delay:1s

TeaOutpost_SpellTask:
  type: task
  debug: false
  script:
   # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
    - run TeaOutpost_OngoingSpellTask def:%CuboidName% delay:1s


TeaOutpost_OngoingSpellTask:
  type: task
  debug: false
  script:
    - while <player.location.cuboids.as_list.contains[cu@<def[1]>]||false> {
     # - announce "<def[1]>"
      - if <player.flag[<def[1]>GaveSpell]||false> != true {
        - inject TeaOutpost_SpellChooserTask
        }
      - wait 10s
      - if <player.is_online||false> != true {
        - while stop
        }
      - if <server.flag[<def[1]>SpellEffect]||None> == None {
        - queue clear
        }
      }
    - if <player.is_online||false> == true && <player.flag[<def[1]>GaveSpell]||false> != true  {
      - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      - define SpellToCast <%Spell%.first>
      - cast %SpellToCast% <player> duration:5s
      }

TeaOutpost_SpellChooserTask:
  type: task
  debug: false
  script:
   # - announce "SPELL CHOOSER"
    - choose <server.flag[<def[1]>SpellTargets]||ALL>:
      - case cancel:
        - wait 10s
      - case ALL:
        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
        - define SpellToCast <%Spell%.first>
        - cast %SpellToCast% <player> duration:60s
      - case TEAM:
        - if <player.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
          - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
          - define SpellToCast <%Spell%.first>
          - cast %SpellToCast% <player> duration:60s
          }
          else {
            - wait 10s
            }
      - case ENEMY:
        - if <player.flag[RaceColour]||Gray> != <server.flag[Ownerof<def[1]>]||Gray> {
          - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
          - define SpellToCast <%Spell%.first>
          - cast %SpellToCast% <player> duration:60s
          }
          else {
            - wait 10s
            }
      - case NONE:
        - wait 10s
      - case default:
        - wait 10s
        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
        - define SpellToCast <%Spell%.first>
        - cast %SpellToCast% <player> duration:60s
   #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
   #   - define SpellToCast <%Spell%.first>
      #  - choose <server.flag[<def[1]>SpellTargets]||ALL>:
     #   - choose <server.flag[<def[1]>SpellTargets]||ALL>:
      #    - case cancel:
      #      - wait 10s
#        - choose "1": 
#          - case "1": 
#            - debug LOG "Success!" 
      #    - case ALL:
      #      - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      #      - define SpellToCast <%Spell%.first>
      #      - cast %SpellToCast% <player> duration:15s
      #    - case TEAM:
      #      - if <player.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
      #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      #        - define SpellToCast <%Spell%.first>
      #        - cast %SpellToCast% <player> duration:15s
      #        }
      #        else {
      #          - wait 10s
      #          }
      #    - case ENEMY:
      #      - if <player.flag[RaceColour]||Gray> != <server.flag[Ownerof<def[1]>]||Gray> {
      #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      #        - define SpellToCast <%Spell%.first>
      #        - cast %SpellToCast% <player> duration:15s
      #        }
      #        else {
      #          - wait 10s
      #          }
      #    - case NONE:
      #      - wait 10s
        #  - case default:
        #    - wait 10s
         #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
         #   - define SpellToCast <%Spell%.first>
         #   - cast %SpellToCast% <player> duration:15s
      #  - narrate "<gray>Repplying %Spell%"
#        - wait 10s
#        - if <player.is_online||false> != true {
#          - while stop
#          }
#        }

    
    #####
 #   - if <server.flag[<def[1]>SpellEffect]||None> != None {
 #  #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #  #   - define SpellToCast <%Spell%.first>
 #     - while <player.location.cuboids.as_list.contains[cu@<def[1]>]||false> {
 #     #  - choose <server.flag[<def[1]>SpellTargets]||ALL>:
 #    #   - choose <server.flag[<def[1]>SpellTargets]||ALL>:
 #     #    - case cancel:
 #     #      - wait 10s
 #       - choose "1": 
 #         - case "1": 
 #           - debug LOG "Success!" 
 #     #    - case ALL:
 #     #      - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #     #      - define SpellToCast <%Spell%.first>
 #     #      - cast %SpellToCast% <player> duration:15s
 #     #    - case TEAM:
 #     #      - if <player.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
 #     #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #     #        - define SpellToCast <%Spell%.first>
 #     #        - cast %SpellToCast% <player> duration:15s
 #     #        }
 #     #        else {
 #     #          - wait 10s
 #     #          }
 #     #    - case ENEMY:
 #     #      - if <player.flag[RaceColour]||Gray> != <server.flag[Ownerof<def[1]>]||Gray> {
 #     #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #     #        - define SpellToCast <%Spell%.first>
 #     #        - cast %SpellToCast% <player> duration:15s
 #     #        }
 #     #        else {
 #     #          - wait 10s
 #     #          }
 #     #    - case NONE:
 #     #      - wait 10s
 #       #  - case default:
 #       #    - wait 10s
 #        #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #        #   - define SpellToCast <%Spell%.first>
 #        #   - cast %SpellToCast% <player> duration:15s
 #     #  - narrate "<gray>Repplying %Spell%"
 #       - wait 10s
 #       - if <player.is_online||false> != true {
 #         - while stop
 #         }
 #       }
 #   }

  # # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
  # # - run TeaOutpost_OngoingSpellTask def:%CuboidName%|<player.name>
  #       - define Spell Speed
  #    - define Spell Slowness
  #    #Slow
  #    - define Spell Haste
  #    #Fast_digging
  #    - define Spell Mining_Fatigue
  #    #Slow_digging
  #    - define Spell Strength
  #    #Increase_damage
  #    - define Spell Jump_Boost
  #    #Jump
  #    - define Spell Nausea
  #    #Confusion
  #    - define Spell Regeneration
  #    - define Spell Resistance
  #    #Damage_resistance
  #    - define Spell Fire_Resistance
  #    - define Spell Water_Breathing
  #    - define Spell Invisibility
  #    - define Spell Blindness
  #    - define Spell Night_Vision
  #    - define Spell Hunger
  #    - define Spell Weakness
  #    - define Spell Poison
  #    - define Spell Saturation
  #    - define Spell Glowing
  #    - define Spell Levitation
  #    - define Spell Luck
  #    - define Spell Bad_Luck
    
TeaOutpost_EntryAnnouncementTask:
  type: task
  debug: false
  script:
    - define AnnouncementColour <server.flag[Ownerof%CuboidName%]||Gray>
    - define AnnouncementColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
    - narrate "<proc[msgCommand].context[<%AnnouncementColour%><server.flag[%CuboidName%DisplayName]||The<&sp>Outpost> (<server.flag[%CuboidName%TrainingFocus]||->) <%AnnouncementColourSecondary%>-<%AnnouncementColour%> <server.flag[%AnnouncementColour%DisplayName]||Wild>|outpost here|<%AnnouncementColour%><server.flag[%CuboidName%SpellEffect]||No Spell> (<server.flag[%CuboidName%SpellTargets]||No Spell>) - <%AnnouncementColourSecondary%>Click for more info]>"


TeaOutpost_Cooldown_Task:
  type: task
  debug: false
  script:
    - while <cu@%CuboidName%.list_players.size.is[LESS].than[1]||false> {
      - wait 3s
     # - announce "<server.flag[<server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%]||0>"
      - if <server.flag[<server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%]||0> > 0 {
        - if <server.flag[<server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%]||0> < 1 {
          - flag server <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%:0
          }
          else {
            - flag server <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%:--
            }
        }
        else {
          - while stop
          }
      }

TeaOutpost_Autoreset_Task:
  type: task
  debug: false
  script:
    - flag server %CuboidName%ResetCountdown:4
    - wait 60s
    - while <cu@%CuboidName%.list_players.size.is[LESS].than[1]||false> {
      - if <server.flag[%CuboidName%ResetCountdown]||0> > 1 {
        - flag server %CuboidName%ResetCountdown:--
       # - announce "reset<server.flag[%CuboidName%ResetCountdown]||0>"
        }
        else {
        #  - announce "autoresetting"
        #  - flag server CTPPointList:<-:cu@%CuboidName%
          - run TeaOutpost_Reset_Task def:%CuboidName%
          - while stop
          }
      - wait 60s
      }
  #  - wait 10s
  #  - announce "<dark_gray>running reset! <def[1]> <def[2]>"
  #  - define CuboidName <def[1]>
  #  - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
  #  - modifyblock %ObsidianList% obsidian delayed


TeaOutpost_Reset_Task:
  type: task
  debug: false
  script:
    - wait 1s
  #  - announce "<dark_gray>running reset! <def[1]>"
    - define CuboidName <def[1]>
    - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
    - playeffect %ObsidianList% effect:HAPPY_VILLAGER quantity:10
    - modifyblock %ObsidianList% obsidian delayed
    - flag server %CuboidName%ObsidianCount:5
    - ^flag global <server.flag[CurrentCapturerof%1%]>Captureof<def[1]>:0
    - ^flag server CTPPointHealth<def[1]>:<server.flag[CTPPointResetHealth%1%]||1000>
    - flag server %CuboidName%IsRunningCaptureTask:false
    - announce "<gray><bold>Outpost:<gray> Reset Task Complete: <def[1]>" to_flagged:DreamListener

TeaOutpost_periodical_unload:
  type: task
  debug: false
  script:
    - foreach <yaml.list.filter[starts_with[TeaOutpost_]]> {
      - define OutpostID <def[value].replace[TeaOutpost_]>
    #  - if <def[chunk].is_loaded||false> {
     #   - if <def[chunk].players.size||0> < 1 {
      #    - if <yaml.list> contains securizen_%value% {
      - yaml "savefile:/Outpost/<def[OutpostID]>_CHANGES.yml" id:%value%
      - yaml unload id:%value%
      - announce to_ops "unloaded %value%"
     #       }
     #     }
     #   }
      - wait 10s
      }
    - run TeaOutpost_periodical_unload delay:30s
    
TeaOutpost_Write_Data:
  type: task
  debug: false
  speed: 0
  definitions: OutpostID|Player|PlayerName|TeamColour|Change|Result
  script:
    - wait 1t
    - if !<yaml.list.contains[TeaOutpost_<def[OutpostID]>]> {
      - if !<server.has_file[/Outpost/<def[OutpostID]>_CHANGES.yml]> {
        - yaml create id:TeaOutpost_<def[OutpostID]>
        } else {
        - yaml "load:/Outpost/<def[OutpostID]>_CHANGES.yml" id:TeaOutpost_<def[OutpostID]>
        }
      }
    - define timestamp "d@<server.current_time_millis.div[50].as_int>t"
    - define path "<def[OutpostID]>"
  #  - if <yaml[TeaOutpost_<def[OutpostID]>].contains[<def[location].simple.before_last[,].replace[,].with[.]>].not> {
  #    - yaml set "<def[path]>.d@0t.Change:WORLD_GEN" "id:TeaOutpost_<def[OutpostID]>"
  #    - yaml set "<def[path]>.d@0t.material:%old_material%" "id:TeaOutpost_<def[OutpostID]>"
  #    - yaml set "<def[path]>.d@0t.type:block_change" "id:TeaOutpost_<def[OutpostID]>"
  #    }
    - yaml set "<def[path]>.%timestamp%.Player:%Player%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.PlayerName:%PlayerName%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.TeamColour:%TeamColour%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.Change:%Change%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.Result:%Result%" "id:TeaOutpost_<def[OutpostID]>"
    
    
    
      #      - foreach <proc[securizen_location_get_edits].context[%OutpostID%|1|<context.args.get[2].as_int||3>]||li@> {

TeaOutpost_get_edits:
  type: procedure
  debug: false
  script:
#  - if <def[1].as_location||none> == none {
#    - debug error "Missing location for "securizen_location_get_edits!"
#    - determine null
#    }
  - define OutpostID %1%
  - define path "%OutpostID%"
  - if <def[2].as_int||none> != none {
    - define first <def[2].as_int>
    } else {
    - debug warning "Value for first entry is not a valid integer."
    - define first 1
    }
  - if <def[3].as_int||none> != none {
    - define last <def[3].as_int>
    } else {
    - debug warning "Value for last entry is not a valid integer."
    - define last 9999
    }
  - if !<yaml.list.contains[TeaOutpost_%OutpostID%]> {
    - if !<server.has_file[/Outpost/<def[OutpostID]>_CHANGES.yml]> {
      - determine li@
      - queue clear
      } else {
      - yaml "load:/Outpost/<def[OutpostID]>_CHANGES.yml" id:TeaOutpost_%OutpostID%
      }
    }
  - if <yaml[TeaOutpost_%OutpostID%].contains[<def[path]>].not> {
    - determine li@
    }
  - define entries li@
  - foreach <yaml[TeaOutpost_%OutpostID%].list_keys[<def[path]>].parse[in_ticks].numerical.reverse.get[%first%].to[%last%]||li@> {
    - define timestamp "d@%value%t"
    - define entries <def[entries].include[%timestamp%/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Player]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.PlayerName]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.TeamColour]||none>]>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Change]||none>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Result]||none>
    }
  - determine %entries%
  
TeaOutpost_InfluenceBars:
  type: procedure
  debug: false
  script:
  - define CurrentInfluence %1%
  - define MaxInfluence %2%
  - define CurrentInfluencePercentage <def[1].div[<def[2]>].mul[100].round_down>
  - define WorkingCIP %CurrentInfluencePercentage%
  - ^if <def[CurrentInfluence]> <= 0 {
    - determine <def[InfluenceCountBars]||->
    }
  - ^if <def[WorkingCIP]> >= 64 {
    - ^define InfluenceCountBars ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
    - ^define WorkingCIP <def[WorkingCIP].sub[64].round_down>
  }
  - ^if <def[WorkingCIP]> >= 32 {
    - ^if <def[CurrentInfluencePercentage]> >= 64 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||||||||||||||||||||||||||||||
      }
      else {
        - ^define InfluenceCountBars ||||||||||||||||||||||||||||||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[32].round_down>
  }
  - ^if <def[WorkingCIP]> >= 16 {
    - ^if <def[CurrentInfluencePercentage]> >= 32 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||||||||||||||
      }
      else {
        - ^define InfluenceCountBars ||||||||||||||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[16].round_down>
  }
  - ^if <def[WorkingCIP]> >= 8 {
    - ^if <def[CurrentInfluencePercentage]> >= 16 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||||||
      }
      else {
        - ^define InfluenceCountBars ||||||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[8].round_down>
  }
  - ^if <def[WorkingCIP]> >= 4 {
    - ^if <def[CurrentInfluencePercentage]> >= 8 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||
      }
      else {
        - ^define InfluenceCountBars ||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[4].round_down>
  }
  - ^if <def[WorkingCIP]> >= 2 {
    - ^if <def[CurrentInfluencePercentage]> >= 4 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||
      }
      else {
        - ^define InfluenceCountBars ||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[2].round_down>
  }
  - ^if <def[WorkingCIP]> >= 1 {
    - ^if <def[CurrentInfluencePercentage]> >= 2 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>|
      }
      else {
        - ^define InfluenceCountBars |
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[1].round_down>
  }
 # - if <def[WorkingCIP]> > 0 {
 #   - define ErrorReport Error
 # }

  - determine <def[InfluenceCountBars]||<&pipe>>
  
"CPCaptureTasktest":
  type: task
  debug: false
  script:
  - while <server.flag[<def[3]>]||false> {
    - if <server.flag[<def[1]>IsRunningCaptureTask]||false> == true {
      - queue clear
    }
    - flag global <def[1]>IsRunningCaptureTask:true
    - ^define AttackCount 0
    - ^define DefenseCount 0
    - ^define DenyCount 0
    # FIRST WE FIND OUT HOW MANY DEFENDING, DENYING AND ATTACKING PLAYERS THERE ARE
    # FOREACH PLAYER INSIDE THE CUBOID:
    - ^foreach <def[2].list_players> {
      # IF THIS PLAYERS COLOUR MATCHES THE CONTROL POINTS COLOUR (DEFENDER):
        # ADD +1 TO THE DEFENSE COUNT
      - ^if <%value%.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
        - ^define DefenseCount <math.as_int:<def[DefenseCount]||0>+1>
      }
      # ELSE IF THIS PLAYERS COLOUR DOES NOT MATCH THE CURRENTLY CAPTURING TEAMS COLOUR (DENIER = NOT ATTACKER & NOT DEFENDER):
        # ADD +1 TO THE DENY COUNT
      else if <%value%.flag[RaceColour]||Gray> != <server.flag[CurrentCapturerof<def[1]>]||<%value%.flag[RaceColour]||Gray>> && <server.flag[CurrentCapturerof<def[1]>]||Gray> != Gray {
        - ^define DenyCount <math.as_int:<def[DenyCount]||0>+1>
      }
      # ELSE (ATTACKER):
        # ADD +1 TO THE ATTACK COUNT
        # SAVE PLAYERS COLOUR AS ATTACKER
      else {
        - ^define AttackCount <math.as_int:<def[AttackCount]||0>+1>
        - ^flag global CurrentCapturerof<def[1]>:<%value%.flag[RaceColour]||Gray>
        - ^flag global CurrentCapturerof<def[1]>Secondary:<%value%.flag[RaceColourSecondary]||Dark_Gray>
      }
    }

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # QUICK MATH 'CAUSE DEFENDERS AND DENIERS HAVE SIMILAR MOTIVES
    # SAVE (DEFENSE COUNT)+(DENY COUNT) AS BLOCK COUNT
    - ^define BlockCount <math.as_int:<def[DefenseCount]||0>+<def[DenyCount]||0>>

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # NEXT WE DECIDE WHAT TO DO BASED ON ATTACKER AND DEFENDER COUNT
    # IF BLOCK COUNT IS GREATER THAN ATTACK COUNT (BLOCKERS ARE WINNING):
    - ^if <def[BlockCount]||0> > <def[AttackCount]||0> {
      # IF CP IS BEING CAPTURED:
      - ^if <server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>].as_int||0> > 1 {
        - ^define TotalBlockInt <math.as_int:<def[BlockCount]||0>-<def[AttackCount]||0>>
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||<def[OwnerColour]||Gray>>
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:<math.as_int:<server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>]>-<def[TotalBlockInt]||0>>
        - ^if <server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>]||0> > <server.flag[CTPPointHealth<def[1]>].as_int.sub[1]||0> {
          - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:0
          }
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - ^inject RevertingActionBarHandler
        }
      }
      # ELSE (CP IS FULLY DEFENDED):
      else {
        - ^define TotalBlockInt <math.as_int:<def[BlockCount]||0>-<def[AttackCount]||0>>
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:0
        - ^flag global CurrentCapturerof<def[1]>:Gray
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:0
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - ^inject DefendingActionBarHandler
        }
      }
    }

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # ELSE IF BLOCK COUNT IS EQUAL TO ATTACK COUNT (ITS A TIE):
    else if <def[BlockCount]||0> == <def[AttackCount]||0> {
      - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
      - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
      - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
      - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
      - ^if <server.flag[<def[1]>IsSilent]||false> == false {
        - ^inject NeutralActionBarHandler
      }
    }

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # ELSE (ATTACKERS ARE WINNING):
    else {
      # IF CP IS BEING CAPTURED:
      - ^if <server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>].as_int||0> < <server.flag[CTPPointHealth<def[1]>].as_int.sub[1]||0> {
        - ^define TotalAttackInt <math.as_int:<def[AttackCount]||0>-<def[BlockCount]||0>>
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:<math.as_int:<server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>]>+<def[TotalAttackInt]>>
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - ^inject CapturingActionBarHandler
        }
      }
      # ELSE (CP IS FULLY CAPTURED):
      else {
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - playsound <def[2].center> sound:VILLAGER_YES
        }
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:<server.flag[CTPPointHealth<def[1]>].as_int.sub[1]||0>
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
        - ^if <server.flag[<def[1]>scriptlist].size||0> > 0 {
          - ^announce "<gray><bold>NoonLight<gray>: Running <server.flag[<def[1]>scriptlist].as_list.replace[|].with[,<&sp>].replace[li@].with[]>: <def[1]>.script.list" to_flagged:NoonLightDiagnostic
          - ^foreach <server.flag[<def[1]>scriptlist].as_list.deduplicate> {
            - announce "<gray>Tea: Running %value% (<def[1]>.script.list)" to_flagged:DreamListener
            - run %value% def:<def[2]>|<def[1]>|<server.flag[CurrentCapturerof<def[1]>]>|<%AttackColour%>|<%AttackColourSecondary%>|<%OwnerColour%>
          }
        }
        else {
          - announce "<gray><bold>NoonLight<gray>: <yellow>Run task list is empty! <gray><def[1]>.script.list" to_flagged:NoonLightDiagnostic
        }
        - ^if <server.flag[<def[1]>injectlist].size||0> > 0 {
          - ^announce "<gray><bold>NoonLight<gray>: Injecting <server.flag[<def[1]>injectlist].as_list.replace[|].with[,<&sp>].replace[li@].with[]>: <def[1]>.inject.list" to_flagged:NoonLightDiagnostic
          - ^foreach <server.flag[<def[1]>injectlist].as_list> {
            - announce "<gray>Tea: Injecting %value%" to_flagged:DreamListener
            - inject %value%
          }
        }
        else {
          - announce "<gray><bold>NoonLight<gray>: <yellow>Inject task list is empty! <gray><def[1]>.inject.list" to_flagged:NoonLightDiagnostic
          - wait 1s
        }
      }
    }
    - wait 5t
    - flag global <def[1]>IsRunningCaptureTask:false
  }
  
"StandardCaptureTaskOutpost":
  type: task
  debug: false
  script:
  - ^if <math.as_int:<server.flag[<server.flag[CurrentCapturerof<def[2]>]>Captureof<def[2]>].as_int||0>/2> == <math:<server.flag[<server.flag[CurrentCapturerof<def[2]>]>Captureof<def[2]>].as_int||0>/2> {
    - title title:<def[5]>CAPTURED subtitle:<def[4]>-[<&sp><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[4]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
    - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
  }
  else {
    - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
    - title title:<def[5]>CAPTURED subtitle:<def[5]>-[<&sp><def[4]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
  }
  - wait 5t
  - ^define OldOwner <server.flag[Ownerof<def[2]>]>
  - ^define NewOwner <server.flag[CurrentCapturerof<def[2]>]>
  - ^flag server %OldOwner%OutpostList:<-:<def[2]>
  - ^flag server %NewOwner%OutpostList:->:<def[2]>
  - ^flag server <def[2]>LastCaptureTime:<util.date.time.hour><util.date.time.minute.replace[regex:^(?!..)].with[0]>
  - ^flag server <def[2]>LastCaptureDate:<util.date.time.year><util.date.time.month.replace[regex:^(?!..)].with[0]><util.date.time.day.replace[regex:^(?!..)].with[0]>
  - ^flag global Ownerof<def[2]>:<server.flag[CurrentCapturerof<def[2]>]>
  - ^flag global Ownerof<def[2]>Secondary:<server.flag[CurrentCapturerof<def[2]>Secondary]>
  - ^flag server CTPPointHealth<def[1]>:<server.flag[CTPPointResetHealth%1%]||1000>
  - ^flag global <server.flag[CurrentCapturerof<def[2]>]>Captureof<def[2]>:0
  - ^flag global CurrentCapturerof<def[2]>:Gray
  - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
  - title title:<def[4]>CAPTURED subtitle:<def[5]>-[<&sp><def[4]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
  - wait 5t
  - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
  - title title:<def[5]>CAPTURED subtitle:<def[5]>-[<&sp><def[4]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
 # - flag server CTPPointList:<-:cu@<def[2]>
  - ^flag global <server.flag[CurrentCapturerof<def[2]>]>Captureof<def[1]>:0
  - if <server.flag[%2%TownName]||null> != null {
    - define InfluenceID <server.flag[%2%TownName]>
    }
    else {
      - define InfluenceID %2%
   #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
      }
  - ^if !<server.flag[<def[InfluenceID]>InfluenceList].contains[%NewOwner%]||false> {
    - ^if <server.flag[<def[InfluenceID]>InfluenceList].is_empty||true> {
      - ^flag server TownOwnerof<def[InfluenceID]>:%NewOwner%
      - ^flag server TownOwnerof<def[InfluenceID]>Secondary:%NewOwner%
      }
    - ^flag server <def[InfluenceID]>InfluenceList:->:%NewOwner%
    - ^if <server.flag[<def[InfluenceID]>InfluencePoints%NewOwner%]||0> < 1 {
      - ^flag server <def[InfluenceID]>InfluencePoints%NewOwner%:1
      }
    }

  - run TeaOutpost_Reset_Task def:<def[2]>|<player.name>
  - run TeaOutpost_Write_Data def:<def[2]>|<player>|<player.name>|<def[NewOwner]||Gray>|Capture|<def[NewOwner]>
  - ^log "<server.flag[TeaOutpost_TotalCaptureCount].round||0> <def[2]> Capture <def[NewOwner]> <server.flag[TeaOutpost_%NewOwner%CaptureCount].round||0> <cu@%2%.list_players.parse[name]>" file:plugins/Denizen/outpost/<def[2].to_uppercase>_LOGS.yml
  - ^log "<server.flag[TeaOutpost_TotalCaptureCount].round||0> <def[2]> Capture <def[NewOwner]> <server.flag[TeaOutpost_%NewOwner%CaptureCount].round||0> <cu@%2%.list_players.parse[name]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_LOGS.yml
  - ^flag server TeaOutpost_TotalCaptureCount:++
  - ^flag server TeaOutpost_%NewOwner%CaptureCount:++

  #- ^flag global <def[2]>containsplayers:false
OutpostmcmmoProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Skill Acrobatics
      - define Skill Alchemy
      - define Skill Archery
      - define Skill Axes
      - define Skill Excavation
      - define Skill Fishing
      - define Skill Herbalism
      - define Skill Mining
      - define Skill Repair
      - define Skill Swords
      - define Skill Taming
      - define Skill Unarmed
      - define Skill Woodcutting
      }
    - determine %Skill%

OutpostSpellProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Spell Speed
      - define Spell Slowness
      #Slow
      - define Spell Haste
      #Fast_digging
      - define Spell Mining_Fatigue
      #Slow_digging
      - define Spell Strength
      #Increase_damage
      - define Spell Jump_Boost
      #Jump
      - define Spell Nausea
      #Confusion
      - define Spell Regeneration
      - define Spell Resistance
      #Damage_resistance
      - define Spell Fire_Resistance
      - define Spell Water_Breathing
      - define Spell Invisibility
      - define Spell Blindness
      - define Spell Night_Vision
      - define Spell Hunger
      - define Spell Weakness
      - define Spell Poison
      - define Spell Saturation
      - define Spell Glowing
     # - define Spell Levitation
      - define Spell Luck
      - define Spell Bad_Luck
      #Unluck
      }
    - determine %Spell%

OutpostAdjectiveProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Name The<&sp>Blood<&sp>
      - define Name A<&sp>Lovely<&sp>
      - define Name The<&sp>Golden<&sp>
      - define Name The<&sp>Iron<&sp>
      - define Name The<&sp>Shadow<&sp>
      - define Name The<&sp>Guarded<&sp>
      - define Name An<&sp>Ancient<&sp>
      - define Name The<&sp>Bone<&sp>
      - define Name The<&sp>Silver<&sp>
      - define Name A<&sp>Ruined<&sp>
      - define Name A<&sp>Holy<&sp>
      - define Name The<&sp>Lost<&sp>
      - define Name The<&sp>Half-
      - define Name The<&sp>Weeping<&sp>
      - define Name The<&sp>Mad<&sp>
      - define Name The<&sp>Cursed<&sp>
      - define Name The<&sp>Dancing<&sp>
      - define Name The<&sp>Hidden<&sp>
      - define Name The<&sp>Happy<&sp>
      - define Name A<&sp>
      - define Name The<&sp>
      }
    - determine %Name%

OutpostNameProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Name Tree
      - define Name Forge
      - define Name Temple
      - define Name Garden
      - define Name Swamp
      - define Name Island
      - define Name Tower
      - define Name Crater
      - define Name Hill
      - define Name College
      - define Name Sea
      - define Name Forest
      - define Name Ship
      - define Name Desert
      - define Name Mountain
      - define Name Crypt
      - define Name Pass
      - define Name Cottage
      }
    - determine %Name%