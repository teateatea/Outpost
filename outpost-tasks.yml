#16-11-30

TeaOutpost: 
  type: version 
  name: Outpost by Tea
  id: 117
  description: Outpost by Tea
  version: 16-12-20

TeaOutpost_CreationTask:
  type: task
  debug: false
  script:
    - flag <player> TeaOutpostCreationCount:++
    - define PlayerLocation l@<player.location.simple>
    - define PlayerFacing <player.location.direction>
    - define OutpostName outpost<player.name><player.flag[TeaOutpostCreationCount].as_int>
    - flag server TeaOutpostList:->:cu@outpost<player.name><player.flag[TeaOutpostCreationCount].as_int>
    - flag server CTPPointList:->:cu@%OutpostName%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Name<&co> cu@outpost<&dot><player.name><&dot><player.flag[TeaOutpostCreationCount].as_int>" target:<player>
    - flag server %OutpostName%DisplayName:<proc[OutpostAdjectiveProc]><proc[OutpostNameProc]>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Display Name<&co> <server.flag[%OutpostName%DisplayName]>" target:<player>
    - flag server "%OutpostName%TrainingMessage:You focus your mind and your body."
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Training Message<&co>" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> <italic><server.flag[%OutpostName%TrainingMessage]>" target:<player>
    - flag server %OutpostName%TrainingFocus:<proc[OutpostmcmmoProc]>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> McMMO Focus<&co> <server.flag[%OutpostName%TrainingFocus]>" target:<player>
    - flag server %OutpostName%SpellEffect:<proc[OutpostSpellProc]>
    - flag server %OutpostName%SpellTargets:ALL
    - flag server %OutpostName%SpellsAdded:->:<server.flag[%OutpostName%SpellEffect]>
    - define BonusSpell <proc[OutpostSpellProc]>
    - repeat 2 {
      - if %BonusSpell% == <server.flag[%OutpostName%SpellEffect]> {
        - define BonusSpell <proc[OutpostSpellProc]>
        }
        else {
          - repeat stop
          }
      }
    - flag server %OutpostName%SpellsAdded:->:%BonusSpell%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Spell Effect<&co> <server.flag[%OutpostName%SpellEffect]>" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Bonus Spell<&co> %BonusSpell%" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Spell Targets<&co> <server.flag[%OutpostName%SpellTargets]>" target:<player>
    - flag server %OutpostName%Location:%PlayerLocation%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Location<&co> <def[PlayerLocation].simple>" target:<player>
    - flag server %OutpostName%ObsidianLocations:<%PlayerLocation%.add[2,-1,2]>|<%PlayerLocation%.add[-2,-1,2]>|<%PlayerLocation%.add[2,-1,-2]>|<%PlayerLocation%.add[-2,-1,-2]>
    - flag server %OutpostName%Facing:%PlayerFacing%
    - choose "<player.location.direction>":
      - case "north":
        - flag server %OutpostName%Facing:north
        - flag server %OutpostName%TrainingTime:Noon
        - define FacingLocation <%PlayerLocation%.add[0,-1,-2]>
      - case "northeast":
        - flag server %OutpostName%Facing:north
        - flag server %OutpostName%TrainingTime:Noon
        - define FacingLocation <%PlayerLocation%.add[0,-1,-2]>
      - case "east":
        - flag server %OutpostName%Facing:east
        - flag server %OutpostName%TrainingTime:Dawn
        - define FacingLocation <%PlayerLocation%.add[2,-1,0]>
      - case "southeast":
        - flag server %OutpostName%Facing:east
        - flag server %OutpostName%TrainingTime:Dawn
        - define FacingLocation <%PlayerLocation%.add[0,-1,2]>
      - case "south":
        - flag server %OutpostName%Facing:south
        - flag server %OutpostName%TrainingTime:Midnight
        - define FacingLocation <%PlayerLocation%.add[0,-1,2]>
      - case "southwest":
        - flag server %OutpostName%Facing:south
        - flag server %OutpostName%TrainingTime:Midnight
        - define FacingLocation <%PlayerLocation%.add[0,-1,2]>
      - case "west":
        - flag server %OutpostName%Facing:west
        - flag server %OutpostName%TrainingTime:Dusk
        - define FacingLocation <%PlayerLocation%.add[-2,-1,0]>
      - case "northwest":z
        - flag server %OutpostName%Facing:west
        - flag server %OutpostName%TrainingTime:Dusk
        - define FacingLocation <%PlayerLocation%.add[2,-1,0]>
      - default:
        - flag server %OutpostName%Facing:north
        - define FacingLocation <%PlayerLocation%.add[0,-1,-2]>
    - flag server %OutpostName%ObsidianLocations:->:%FacingLocation%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Orientation<&co> <server.flag[%OutpostName%Facing]||Error>" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Training Time<&co> <server.flag[%OutpostName%TrainingTime]||Error>" target:<player>
    - modifyblock <server.flag[%OutpostName%ObsidianLocations].as_list> obsidian delayed
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Obsidian Locations<&co> saved" target:<player>
   # - note cu@<%PlayerLocation%.add[2,5,2]>|<%PlayerLocation%.add[-2,-5,-2]> as:%OutpostName%
   # - note cu@<%PlayerLocation%.add[10,10,10]>|<%PlayerLocation%.add[-10,-10,-10]> as:CTP%OutpostName%
    - note cu@<%PlayerLocation%.add[10,10,10]>|<%PlayerLocation%.add[-10,-10,-10]> as:%OutpostName%
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Cuboid Perimeters<&co> saved" target:<player>
    - flag server CTPPointHealth%OutpostName%:1000
    - flag server CTPPointResetHealth%OutpostName%:1000
    - flag server %OutpostName%scriptlist:->:StandardCaptureTaskOutpost
    - flag server %OutpostName%scriptlist:->:TeaOutpost_SingleTrainingCuboidCheck
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Capture Format<&co> Standard Outpost" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Health Points<&co> Standard (<server.flag[CTPPointHealth%OutpostName%]||0>)" target:<player>
    - flag server %OutpostName%leavingscriptlist:->:TeaOutpost_Cooldown_Task
    - flag server %OutpostName%leavingscriptlist:->:TeaOutpost_Autoreset_Task
    - flag server %OutpostName%entryscriptlist:->:TeaOutpost_EntryAnnouncementTask
   # - flag server %OutpostName%entryscriptlist:->:TeaOutpost_SpellTask
    - flag server %OutpostName%entryscriptlist:->:TeaOutpost_TimeCheckTask
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Heal Speed<&co> Standard (3)" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> AutoReset Countdown<&co> Standard (5)" target:<player>
  #  - flag server OutpostObsidianBypassDamage:900
    - flag server OutpostObsidianDamage:100
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Obsidian Damage<&co> Standard (<server.flag[OutpostObsidianDamage]||0>)" target:<player>
    - wait 1s
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Prep Complete" target:<player>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Ready for Activation" target:<player>
    - announce "<gray><bold>Outpost:<gray> Outpost Created: %OutpostName%" to_flagged:DreamListener

    - narrate "<dark_aqua><&lb>OUTPOST<&rb> MOVE <bold>FIRST<dark_aqua>, BREAK <bold>ONE<dark_aqua> OBBY, THEN LEAVE!" target:<player>
    - flag <player> OutpostCreationInProgress:false

TeaOutpost_DeletionTask:
  type: task
  debug: false
  script:
    - define OutpostName <def[1].replace[cu@].with[]>
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Removing Outpost from List" target:<player>

    - flag server TeaOutpostList:<-:cu@%OutpostName%
    - flag server CTPPointList:<-:cu@%OutpostName%

    - narrate "<dark_gray><&lb>OUTPOST<&rb> Stopping NoonLight" target:<player>
    - ^flag global %OutpostName%containsplayers:false

    - wait 5s
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Removing Obsidian" target:<player>
    - modifyblock <server.flag[%OutpostName%ObsidianLocations].as_list> air delayed
    
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Deleting Cuboid Perimeters" target:<player>
    - note remove as:%OutpostName%
    
    - narrate "<dark_gray><&lb>OUTPOST<&rb> Deleting All Flags" target:<player>
    - flag server %OutpostName%DisplayName:!
    - flag server %OutpostName%TrainingMessage:!
    - flag server %OutpostName%TrainingFocus:!
    - flag server %OutpostName%SpellEffect:!
    - flag server %OutpostName%SpellTargets:!
    - flag server %OutpostName%SpellsAdded:!

    - flag server %OutpostName%Location:!

    - flag server %OutpostName%Facing:!

    - flag server %OutpostName%ObsidianLocations:!
    - flag server %OutpostName%leavingscriptlist:!
    - flag server %OutpostName%entryscriptlist:!

    - flag server CTPPointHealth%OutpostName%:!
    - flag server CTPPointResetHealth%OutpostName%:!
    
    - ^flag global %OutpostName%containsplayers:!
    - flag server %OutpostName%obbyactivation:!
    
    - announce "<gray><bold>Outpost:<gray> Outpost Deleted: %OutpostName%" to_flagged:DreamListener

    - narrate "<dark_aqua><&lb>OUTPOST<&rb> Outpost Deletion Complete. <proc[msgCommand].context[<aqua>Reopen Outpost List?|toutpost list|toutpost list]>" target:<player>
   # - narrate "<dark_gray><&lb>OUTPOST<&rb> Outpost Deletion Complete" target:<player>

TeaOutpost_LocationCheckTask:
  type: task
  debug: false
  script:
    - if <player.location.cuboids.as_list.contains[cu@%ManageName%]||false> != true {
      - ^narrate "<proc[msgHover].context[<dark_red><&lb>OUTPOST<&rb> Stand inside this Outpost to make changes.|<gray>Outposts cannot be managed from a distance.]>" targets:<player>
      - queue clear
    }


TeaOutpost_Task:
  type: task
  debug: false
  script:
  #  - announce "yessir!"
    - while <player.flag[CreatingTeaOutpost]||false> :
      #- announce "nice!"
      - define GreenLocations <player.location.add[0,-10,0]>
      - define RedLocations <player.location.add[0,-10,0]>
      - choose "<player.location.direction>":
        - case "north":
          - define FacingTime Noon
          - define FacingLocation <player.location.add[0,-1,-2]>
        - case "northeast":
          - define FacingTime Noon
          - define FacingLocation <player.location.add[0,-1,-2]>
        - case "east":
          - define FacingTime Dawn
          - define FacingLocation <player.location.add[2,-1,0]>
        - case "southeast":
          - define FacingTime Dawn
          - define FacingLocation <player.location.add[0,-1,2]>
        - case "south":
          - define FacingTime Midnight
          - define FacingLocation <player.location.add[0,-1,2]>
        - case "southwest":
          - define FacingTime Midnight
          - define FacingLocation <player.location.add[0,-1,2]>
        - case "west":
          - define FacingTime Dusk
          - define FacingLocation <player.location.add[-2,-1,0]>
        - case "northwest":
          - define FacingTime Dusk
          - define FacingLocation <player.location.add[2,-1,0]>
        - default:
          - define FacingTime Noon
          - define FacingLocation <player.location.add[0,-1,-2]>
      
      ## ADD GREEN IF HIGHEST, RED IF NOT HIGHEST
      - if <player.location.add[0,-1,0].y> >= <player.location.add[0,-1,0].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-1,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-1,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-1,0]>
          }
      - if <player.location.add[2,-1,2].y> >= <player.location.add[2,-1,2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[2,-1,2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[2,-1,2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[2,-1,2]>
          }
      - if <player.location.add[-2,-1,2].y> >= <player.location.add[-2,-1,2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-2,-1,2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-2,-1,2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-2,-1,2]>
          }
      - if <player.location.add[2,-1,-2].y> >= <player.location.add[2,-1,-2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[2,-1,-2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[2,-1,-2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[2,-1,-2]>
          }
      - if <player.location.add[-2,-1,-2].y> >= <player.location.add[-2,-1,-2].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-2,-1,-2].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-2,-1,-2]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-2,-1,-2]>
          }
      - if <def[FacingLocation].y> >= <def[FacingLocation].highest.y> && <server.flag[TeaOutpostList].as_list.contains_any[<def[FacingLocation].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|%FacingLocation%
        }
        else {
          - define RedLocations %RedLocations%|%FacingLocation%
          }
      ## ALSO CHECK TOP
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,10,10]>
          }
      ## --
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,10,-10]>
          }
      ## ALSO CHECK MIDDLE
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-1,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-1,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-1,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-1,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-1,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-1,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-1,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-1,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-1,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-1,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-1,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-1,10]>
          }
      ## --
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-1,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-1,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-1,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-1,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-1,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-1,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-1,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-1,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-1,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-1,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-1,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-1,-10]>
          }
      ## ALSO CHECK MIDDLE
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-10,0].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-10,0]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-10,0]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[0,-10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[0,-10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[0,-10,10]>
          }
      ## --
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[10,-10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[10,-10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[10,-10,-10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-10,10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-10,10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-10,10]>
          }
      - if <server.flag[TeaOutpostList].as_list.contains_any[<player.location.add[-10,-10,-10].cuboids>]||false> == false {
        - define GreenLocations %GreenLocations%|<player.location.add[-10,-10,-10]>
        }
        else {
          - define RedLocations %RedLocations%|<player.location.add[-10,-10,-10]>
          }
      ## SHOW FAKE IF RELEVANT
      - title subtitle:%FacingTime%
      - showfake lime_stained_glass %GreenLocations% players:<player.location.find.players.within[25].as_list> d:2s
      - showfake red_stained_glass %RedLocations% players:<player.location.find.players.within[25].as_list> d:2s
      - if %RedLocations% == <player.location.add[0,-10,0]> {
        - title subtitle:<green>%FacingTime%
        - flag <player> TeaOutpostGoodSpotCheck:true
        }
        else {
          - title subtitle:<dark_red>%FacingTime%
          - flag <player> TeaOutpostGoodSpotCheck:false
          }
      - wait 2s

CTPInitializeTask:
  type: task
  debug: false
  script:
    - ^if <server.flag[%CuboidName%IsSilent]||false> == false {
      - playsound <player> sound:note_piano volume:0.5 pitch:<math:0.5+0.1*<cu@%CuboidName%.list_players.size>>
      }
    - ^if <cu@%CuboidName%.list_players.size> == 1 || <server.flag[%CuboidName%obbyactivation]||false> == true {
      - flag server %CuboidName%obbyactivation:false
      - ^define CaptureColour <server.flag[CurrentCapturerof%CuboidName%]||<server.flag[Ownerof%CuboidName%Secondary]||Gray>>
      - ^define AttackColour <server.flag[CurrentCapturerof%CuboidName%]||Gray>
      - ^define AttackColourSecondary <server.flag[CurrentCapturerof%CuboidName%Secondary]||Dark_Gray>
      - ^define OwnerColour <server.flag[Ownerof%CuboidName%]||Gray>
      - ^define OwnerColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
      - ^define ActiveColour <tern[<server.flag[CurrentCapturerof%CuboidName%].is[==].to[Gray]||true>]:<def[OwnerColour]>||<def[AttackColour]>>
      - ^if <server.flag[%CuboidName%IsSilent]||false> == false {
        - ^adjust <player> action_bar:<%ActiveColour%><bold><math.as_int:<server.flag[CTPPointHealth%CuboidName%]||0>-<server.flag[%AttackColour%Captureof%CuboidName%].as_int||0>>
      }
      - wait 1t
      - ^if <server.flag[%CuboidName%containsplayers]||false> == false {
        - ^flag global %CuboidName%containsplayers:true
        - run CPCaptureTasktest def:%CuboidName%|cu@%CuboidName%|%CuboidName%containsplayers
      }
   #   - ^if <server.flag[%CuboidName%entryscriptlist].size||0> > 0 {
   #     - ^foreach <server.flag[%CuboidName%entryscriptlist].as_list> {
   #       - announce "<gray>Tea: Injecting entry script %value%" to_flagged:DreamListener
   #       - inject %value%
   #     }
   #   }
      else {
        - announce "<gray><bold>NoonLight<gray>: <yellow>Entry task list is empty! <gray>%CuboidName%.entry.script.list" to_flagged:NoonLightDiagnostic
      }
    }

CTPFinalizeTask:
  type: task
  debug: false
  script:
    - ^if <cu@%CuboidName%.list_players.size> == 0 {
      - ^flag global %CuboidName%containsplayers:false
      - ^if <server.flag[%CuboidName%leavingscriptlist].size||0> > 0 {
        - ^announce "<gray><bold>NoonLight<gray>: Leave-injecting <server.flag[%CuboidName%leavingscriptlist].replace[|].with[,<&sp>].replace[li@].with[]>: %CuboidName%.leaving.script.list" to_flagged:NoonLightDiagnostic
        - ^foreach <server.flag[%CuboidName%leavingscriptlist].as_list> {
          - inject %value%
        }
      }
      else {
        - announce "<gray><bold>NoonLight<gray>: <yellow>Leave task list is empty! <gray>%CuboidName%.leaving.script.list" to_flagged:NoonLightDiagnostic
      }
    }
 


TeaOutpost_World: 
  type: world
  debug: false
  events: 
    on server start:
    - wait 1m
    - run TeaOutpost_periodical_unload
    on player login:
    - wait 4s
    - define Colour <player.flag[RaceColour]||null>
    - define NationName <player.nation.replace[nation@].with[]||Nationless>
    - if <def[Colour]> != null {
      - announce "<gray>Returning Player! <player.name> is <%Colour%>%Colour%" to_flagged:DreamListener
      }
      else {
        - define NationDefault <server.flag[TeaOutpost_%NationName%DefaultColour]||null>
        - if <def[NationDefault]||null> != null {
          - flag <player> RaceColour:%NationDefault%
          - flag <player> RaceColourSecondary:White
          }
          else {
            - flag <player> RaceColour:White
            - flag <player> RaceColourSecondary:White
            }
        - define Colour <player.flag[RaceColour]||null>
        - announce "<gray>New Player! <player.name> flagged <%NationDefault%>%NationDefault% / %NationName%" to_flagged:DreamListener
        }
    - if <def[NationName]> != null {
      - define NationKing <nation@%NationName%.king>
      - if <player> == <def[NationKing]> || <player.town.assistants.contains[<player>]||false> {
        - flag <player> TeaOutpostKingPass:true
        - announce "<gray>Returning King! <player.name> is <%Colour%>King/Assistant of %NationName%" to_flagged:DreamListener
        }
        else {
          - flag <player> TeaOutpostKingPass:!
          - announce "<gray>Returning Player! <player.name> is not King" to_flagged:DreamListener
          }
      }
      else {
        - flag <player> TeaOutpostKingPass:!
        - announce "<gray>New Player! <player.name> is nationless" to_flagged:DreamListener
        }

    
    on player enters notable cuboid:
    - if <server.flag[TeaOutpostList].as_list.contains_any[<context.cuboids>]||false> == true {
      - foreach <context.cuboids> {
        - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
          - define CuboidName <def[value].replace[cu@].with[]>
        #  - announce "<dark_gray>This is an outpost! %value%"
          - foreach stop
          }
          else {
            - define CuboidName Next
            }
        }
      - if <def[CuboidName]||Next == Next {
        - queue clear
        }
      - if <server.flag[CTPPointList].contains[cu@%CuboidName%]||false> == true {
        - ^if <server.flag[%CuboidName%entryscriptlist].size||0> > 0 {
          - ^foreach <server.flag[%CuboidName%entryscriptlist].as_list> {
            - announce "<gray>Tea: Injecting entry script %value%" to_flagged:DreamListener
            - inject %value%
          }
        }
        - wait 1t
        - inject CTPInitializeTask
        }
      }

    on player exits notable cuboid:
    - if <server.flag[TeaOutpostList].as_list.contains_any[<context.cuboids>]||false> == true {
      - foreach <context.cuboids> {
        - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
          - define CuboidName <def[value].replace[cu@].with[]>
         # - announce "<dark_gray>This was an outpost! %value%"
          - foreach stop
          }
          else {
            - define CuboidName Next
            }
        }
      - if <server.flag[CTPPointList].contains[cu@%CuboidName%]||false> == true {
        - wait 1t
        - inject CTPFinalizeTask
        }
      }


    on player places obsidian:
   # - announce "broken! <context.location>"
   # - announce "<server.flag[TeaOutpostList].as_list.contains_any[<context.location.cuboids>]||false>"
    - foreach <context.location.cuboids> {
      - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
      #  - announce "%value%"
        - define CuboidName <def[value].replace[cu@].with[]>
        - foreach stop
        }
      }
    - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
   # - announce "<server.flag[%CuboidName%ObsidianLocations].as_list>"
    - if <%ObsidianList%.contains[<context.location>]||false> == true {
   #   - if <server.flag[CTPPointList].contains[cu@%CuboidName%]||false> == true {
      - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> Please allow this outpost to reset itself. <server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>

      - determine cancelled
    #    }
    #    else {
    #      - flag server %CuboidName%ObsidianCount:++
         # - announce "thats one! %CuboidName% <server.flag[%CuboidName%ObsidianCount].as_int||0>/5"
    #      - if <server.flag[%CuboidName%ObsidianCount]||0> > 4 {
    #        - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> <bold>All obsidian have been replaced.|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
    #        - flag server %CuboidName%ObsidianCount:5
           # - run TeaOutpost_Reset_Task def:%CuboidName%|<player.name>
    #        }
    #        else {
    #          - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> An obsidian has been replaced. <server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
    #          }
    #      }
      }
    on player breaks block priority:999 ignorecancelled:true:
    - foreach <context.location.cuboids> {
      - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
      #  - announce "%value%"
        - define CuboidName <def[value].replace[cu@].with[]>
        - foreach stop
        }
        else {
        - define CuboidName Cancel
        }
      }
    - if <def[CuboidName]||Cancel> == Cancel {
      - queue clear
      }
  #  - if <context.material> == m@obsidian {
   
   
    - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
   # - announce "<server.flag[%CuboidName%ObsidianLocations].as_list>"
    - if <%ObsidianList%.contains[<context.location>]||false> == true {
    #  - if <server.flag[Ownerof%CuboidName%]||Gray> == <player.flag[RaceColour]||Gray> {
    #    - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
    #    - determine cancelled
    #    }
    #
    #  - flag server %CuboidName%ObsidianCount:--
     # - announce "thats one! %CuboidName% <server.flag[%CuboidName%ObsidianCount].as_int||0>/5"
      - if <context.material> == m@obsidian {
        - if <server.flag[Ownerof%CuboidName%]||Gray> == <player.flag[RaceColour]||Gray> {
          - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
          - determine cancelled
          }
     
        - flag server %CuboidName%ObsidianCount:--
        - if <server.flag[%CuboidName%ObsidianCount]||0> < 1 {
          - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
        #  - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
        #  - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
          - define PointHealth <server.flag[CTPPointHealth%CuboidName%]||1000>
          - flag server CTPPointHealth%CuboidName%:<math:<def[PointHealth]>-<server.flag[OutpostObsidianDamage]||0>>

          - if <player.flag[TeaOutpostBypass]||false> != false {
            - flag server %CaptureCount%:<server.flag[CTPPointHealth%CuboidName%].sub[1]||0>
            }
          - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> <bold>All obsidian have been broken!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
        #  - flag server %CuboidName%ObsidianCount:5
        #  - run TeaOutpost_Reset_Task def:%CuboidName%|<player.name>
         # - flag server CTPPointList:->:cu@%CuboidName%
          - flag server %CuboidName%obbyactivation:true
          - inject CTPInitializeTask
     
          }
          else {
           # - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
            - define PointHealth <server.flag[CTPPointHealth%CuboidName%]||1000>
            - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
            - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
           # - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
            - flag server CTPPointHealth%CuboidName%:<math:<def[PointHealth]>-<server.flag[OutpostObsidianDamage]||0>>
            - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> An obsidian has been broken! <%Colour%><server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<%Colour%><server.flag[%CuboidName%DisplayName]||The<&sp>Outpost> (<server.flag[%CuboidName%TrainingFocus]||MCMMO>) <%ColourSecondary%>-<%Colour%> <server.flag[%Colour%DisplayName]||<def[Colour].to_titlecase>> <util.date.time>]>" targets:<player.location.find.players.within[70]>
            }
          }
          else {
          #  - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
            - determine cancelled
            }
      - wait 1t
      - modifyblock <context.location> white_wool
      }
      
      
      
      else {
        - wait 1t
        - modifyblock <context.location> air naturally
        }
   
   
   
   #   }
   #   else {
   #     - modifyblock <context.location> air naturally
   #     }
    - announce "<player.name> broke a <context.material> and was denied!" to_flagged:DreamListener
  #  - if <context.cancelled||false> && <player.flag[PvpBypass]||false> == true {
  #    - hurt <context.final_damage> <context.entity>
  #  }
 #   on player breaks block priority:998:
 #   - if <player.name> == shooshooshoo {
 #     - determine cancelled
 #     }
  #  on player breaks block priority:1000 cancelled:true:
  #  - announce "<player.name> broke a block and was denied!2" to_flagged:DreamListener2

 #   on player breaks obsidian:
 #  # - announce "broken! <context.location>"
 #  # - announce "<server.flag[TeaOutpostList].as_list.contains_any[<context.location.cuboids>]||false>"
 #   - foreach <context.location.cuboids> {
 #     - if <server.flag[TeaOutpostList].as_list.contains_any[%value%]||false> == true {
 #     #  - announce "%value%"
 #       - define CuboidName <def[value].replace[cu@].with[]>
 #       - foreach stop
 #       }
 #       else {
 #       - define CuboidName Cancel
 #       }
 #     }
 #   - if <def[CuboidName]||Cancel> == Cancel {
 #     - queue clear
 #     }
 #   - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
 #  # - announce "<server.flag[%CuboidName%ObsidianLocations].as_list>"
 #   - if <%ObsidianList%.contains[<context.location>]||false> == true {
 #     - if <server.flag[Ownerof%CuboidName%]||Gray> == <player.flag[RaceColour]||Gray> {
 #       - narrate "<dark_red><&lb>OUTPOST<&rb> This Outpost already belongs to your team!" targets:<player>
 #       - determine cancelled
 #       }
 #     - flag server %CuboidName%ObsidianCount:--
 #    # - announce "thats one! %CuboidName% <server.flag[%CuboidName%ObsidianCount].as_int||0>/5"
 #     - if <server.flag[%CuboidName%ObsidianCount]||0> < 1 {
 #       - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
 #       - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
 #       - if <player.flag[TeaOutpostBypass]||false> != false {
 #         - flag server %CaptureCount%:<server.flag[CTPPointHealth%CuboidName%].sub[1]||0>
 #         }
 #       - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> <bold>All obsidian have been broken!|<gray>%CuboidName% <util.date.time.twentyfour_hour>]>" targets:<player.location.find.players.within[70]>
 #     #  - flag server %CuboidName%ObsidianCount:5
 #     #  - run TeaOutpost_Reset_Task def:%CuboidName%|<player.name>
 #      # - flag server CTPPointList:->:cu@%CuboidName%
 #       - flag server %CuboidName%obbyactivation:true
 #       - inject CTPInitializeTask
 #
 #       }
 #       else {
 #         - define CaptureCount <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%
 #         - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
 #         - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
 #         - flag server %CaptureCount%:<math:<server.flag[%CaptureCount%]||0>+<server.flag[OutpostObsidianDamage]||0>>
 #         - ^narrate "<proc[msghover].context[<dark_aqua><&lb>OUTPOST<&rb> An obsidian has been broken! <%Colour%><server.flag[%CuboidName%ObsidianCount].as_int||0> remain!|<%Colour%><server.flag[%CuboidName%DisplayName]||The<&sp>Outpost> (<server.flag[%CuboidName%TrainingFocus]||MCMMO>) <%ColourSecondary%>-<%Colour%> <server.flag[%Colour%DisplayName]||<def[Colour].to_titlecase>> <util.date.time>]>" targets:<player.location.find.players.within[70]>
 #         }
 #     }

#MIDNIGHT
    on time 22 in world:
    - wait 30s
    - announce "<red>It's PreMidnight" to_flagged:DreamListener
    - flag server MidnightTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Midnight
      }
    on time 0 in world:
    - announce "<red>It's Midnight" to_flagged:DreamListener
    - flag server MidnightTraining:true
    on time 1 in world:
    - announce "<red>It's PostMidnight" to_flagged:DreamListener
    - flag server MidnightTraining:false
#DAWN
    on time 3 in world:
    - wait 40s
    - announce "<red>It's PreDawn" to_flagged:DreamListener
    - flag server DawnTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Dawn
      }
    on time 5 in world:
    - announce "<red>It's Dawn" to_flagged:DreamListener
    - flag server DawnTraining:true
    on time 6 in world:
    - wait 30s
    - announce "<red>It's PostDawn" to_flagged:DreamListener
    - flag server DawnTraining:false
#NOON
    on time 10 in world:
    - announce "<red>It's PreNoon" to_flagged:DreamListener
    - flag server NoonTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Noon
      }
    on time 12 in world:
    - announce "<red>It's Noon" to_flagged:DreamListener
    - flag server NoonTraining:true
    on time 14 in world:
    - announce "<red>It's PostNoon" to_flagged:DreamListener
    - flag server NoonTraining:false
#DUSK
    on time 17 in world:
    - wait 30s
    - announce "<red>It's PreDusk" to_flagged:DreamListener
    - flag server DuskTraining:true
    - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
      - flag server TrainingCuboidCheckIsActive:true
      - run TeaOutpost_TrainingCuboidCheck def:Dusk
      }
    on time 19 in world:
    - announce "<red>It's Dusk" to_flagged:DreamListener
    - flag server DuskTraining:true
    on time 20 in world:
    - wait 30s
    - announce "<red>It's PostDusk" to_flagged:DreamListener
    - flag server DuskTraining:false
  #  - announce "<red>It's PreMidnight" to_flagged:DreamListener
  #  - flag server MidnightTraining:true
  #  - if <server.flag[TrainingCuboidCheckIsActive]||false> != true {
  #    - flag server TrainingCuboidCheckIsActive:true
  #    - run TeaOutpost_TrainingCuboidCheck def:Midnight
  #    }

TeaOutpost_SingleTrainingCuboidCheck:
  type: task
  debug: false
  script:
    - define CuboidName <def[2]>
    - foreach <cu@%CuboidName%.list_players> {
      - define PlayerName <%value%.name>
      - define Player <%value%>
      - if <%player%.flag[RaceColour]||Gray> == <server.flag[Ownerof%CuboidName%]||Gray> {
        - inject TeaOutpost_CuboidCheckTrainer
        }
      }

TeaOutpost_TrainingCuboidCheck:
  type: task
  debug: false
  script:
    - foreach <server.flag[TeaOutpostList].as_list> {
      - define CuboidName <%value%.replace[cu@].with[]>
     # - announce "%CuboidName%"
      - foreach <cu@%CuboidName%.list_players> {
        - define PlayerName <%value%.name>
        - define Player <%value%>
        - if <%player%.flag[RaceColour]||Gray> == <server.flag[Ownerof%CuboidName%]||Gray> {
          - inject TeaOutpost_CuboidCheckTrainer
          }
        }
      }
    - foreach <server.flag[TeaOutpostList].as_list> {
      - define CuboidName <%value%.replace[cu@].with[]>
      - if <server.flag[%CuboidName%TrainingTime]||Null> == <def[1]> {
        - inject TeaOutpost_TownInfluenceTask
        }
      }
    - foreach <server.flag[TeaOutpostList].as_list> {
      - define CuboidName <%value%.replace[cu@].with[]>
      - if <server.flag[%CuboidName%TrainingTime]||Null> == <def[1]> {
        - inject TeaOutpost_HighestInfluenceChooserTask
        }
      }
    - flag server TrainingCuboidCheckIsActive:false
  #  - announce "<server.flag[%CuboidName%TrainingTime]||Error> time"
  #  - define CuboidTime <server.flag[%CuboidName%TrainingTime]||Error>
  #  - if <server.flag[%CuboidTime%Training]||false> {
  #    - announce "you can train"
  #  }
TeaOutpost_TownInfluenceTask:
  type: task
  debug: false
  script:
    - if <server.flag[%Cuboidname%TownName]||null> != null {
      - define InfluenceID <server.flag[%CuboidName%TownName]>
      }
      else {
        - define InfluenceID %CuboidName%
     #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
        }
    - define OutpostID %CuboidName%
    - define CurrentOwner <server.flag[Ownerof%OutpostID%]||Gray>
    - announce "<gray><bold>Influence Task: <gray><def[1]> for %OutpostID%/%InfluenceID%" to_flagged:DreamListener
    - foreach <server.flag[%InfluenceID%InfluenceList].as_list||li@> {
      - if %CurrentOwner% == %value% {
       # - define CurrentIP <server.flag[%OutpostID%InfluencePoints%value%]||0>
        - define CurrentIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
        - define CurrentTime <util.date.time.hour><util.date.time.minute.replace[regex:^(?!..)].with[0]>
        - define CurrentDate <util.date.time.year><util.date.time.month.replace[regex:^(?!..)].with[0]><util.date.time.day.replace[regex:^(?!..)].with[0]>
        - flag server %InfluenceID%InfluencePoints%value%:<def[CurrentIP].add[1]>
        - if <def[CurrentDate]> != <server.flag[%OutpostID%LastCaptureDate]||0> && <def[CurrentTime]> >= <server.flag[%OutpostID%LastCaptureTime]||0> {
          - flag server %InfluenceID%InfluencePoints%value%:+:<server.flag[%value%OutpostList].as_list.size>
          - announce "establishment boost <server.flag[%value%OutpostList].as_list.size> %value% <def[CurrentDate]> != <server.flag[%OutpostID%LastCaptureDate]||0> <def[CurrentTime]> >= <server.flag[%OutpostID%LastCaptureTime]||0>" to_flagged:DreamListener
          }
        - if <server.flag[%InfluenceID%InfluencePoints%value%]||0> > 1000 {
          - flag server %InfluenceID%InfluencePoints%value%:1000
          }
        - announce "%value%Add<server.flag[%InfluenceID%InfluencePoints%value%]||00>" to_flagged:DreamListener
        
        }
        else {
          - define CurrentIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
          - flag server %InfluenceID%InfluencePoints%value%:<def[CurrentIP].sub[1]>
          - announce "%value%subtract<server.flag[%InfluenceID%InfluencePoints%value%]||00>" to_flagged:DreamListener
          - if <server.flag[%InfluenceID%InfluencePoints%value%]||0> < 0 {
            - flag server %InfluenceID%InfluencePoints%value%:0
            - flag server %InfluenceID%InfluenceList:<-:%value%
            }
          }
      }

TeaOutpost_HighestInfluenceChooserTask:
  type: task
  debug: false
  script:
    - if <server.flag[%Cuboidname%TownName]||null> != null {
      - define InfluenceID <server.flag[%CuboidName%TownName]>
      }
      else {
        - define InfluenceID %CuboidName%
     #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
        }
    - define OutpostID %CuboidName%
    - define CurrentTownOwner <server.flag[TownOwnerof%InfluenceID%]||Gray>
    - announce "<gray><bold>Influence Chooser: <gray><def[1]> for %OutpostID%/%InfluenceID%" to_flagged:DreamListener
    - define MaxIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
    - define MaxIPName %CurrentTownOwner%
    - foreach <server.flag[%InfluenceID%InfluenceList].as_list||li@> {
      - if <def[MaxIP]> < <server.flag[%InfluenceID%InfluencePoints%value%]||0> {
        - define MaxIP <server.flag[%InfluenceID%InfluencePoints%value%]||0>
        - define MaxIPName %value%
        }
      }
    - if <server.flag[TownOwnerof%InfluenceID%]||Gray> != <def[MaxIPName]> {
      - flag server TownOwnerof%InfluenceID%:<def[MaxIPName]>
      - flag server TownOwnerof%InfluenceID%Secondary:<def[MaxIPName]>
      - announce "<gray><bold>Influence Chooser:<gray> %OutpostID%/%InfluenceID% Town Owner is now <def[MaxIPName]>" to_flagged:DreamListener
      - inject TeaOutpost_UpdateOutpostTownTask

      }

  #  - announce "%OutpostID% Town Owner is <def[MaxIPName]> with <def[MaxIP]>"

TeaOutpost_CuboidCheckTrainer:
  type: task
  debug: false
  script:
   # - announce "<server.flag[%CuboidName%TrainingTime]||Error> time"
    - define CuboidTime <server.flag[%CuboidName%TrainingTime]||Error>
    - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
    - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
    - if <server.flag[%CuboidTime%Training]||false> && <%Player%.flag[HasTrainedAt%CuboidTime%]||false> != true {
      - flag %Player% HasTrainedAt%CuboidTime%:true duration:10m
      - narrate "<%ColourSecondary%>%CuboidTime% Training begins now." targets:%Player%
      - narrate "<%ColourSecondary%><server.flag[%CuboidName%TrainingMessage]||Error Please Talk to Tea>" targets:%Player%
      - run TeaOutpost_GiveXPTask def:%Player%|%Colour%|%ColourSecondary%|%CuboidName%
    }

TeaOutpost_TimeCheckTask:
  type: task
  debug: false
  script:
  #  - announce "<server.flag[%CuboidName%TrainingTime]||Error> time"
    - define CuboidTime <server.flag[%CuboidName%TrainingTime]||Error>
    - if <server.flag[%CuboidTime%Training]||false> && <player.flag[HasTrainedAt%CuboidTime%]||false> != true && <player.flag[RaceColour]||Gray> == <server.flag[Ownerof%CuboidName%]||Gray> {
      - flag <player> HasTrainedAt%CuboidTime%:true duration:10m
      - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
      - define ColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
      - narrate "<%ColourSecondary%><italic><server.flag[%CuboidName%TrainingMessage]||Error Please Talk to Tea>" targets:<player>
      - define Player <player>
      - run TeaOutpost_GiveXPTask def:%Player%|%Colour%|%ColourSecondary%|%CuboidName%
    }

TeaOutpost_UpdateOutpostTownTask:
  type: task
  debug: false
  script:
    - define ManageName <def[OutpostID]>
    - define ManageNation <server.flag[%ManageName%NationName]||null>
    - define ManageNPC <server.flag[%ManageName%NPCName]||null>
    - define ManageTown <server.flag[%ManageName%TownName]||null>
    - define ManageOwner <server.flag[TownOwnerof%ManageTown%]||Gray>
    - define OwnerNation <server.flag[%ManageOwner%NationName]||Wild>
    - run TeaOutpost_Write_Data def:<def[ManageName]>|<def[ManageTown]>|<def[ManageNation]>|<def[ManageOwner]||Gray>|Influence<&sp>Takeover|<def[OwnerNation]>
    - ^log "<server.flag[TeaOutpost_TotalInfluenceTakeoverCount].round||0> %ManageNation% TAKEOVER <def[ManageOwner]> <def[OwnerNation]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_LOGS.yml
    - ^flag server TeaOutpost_TotalInfluenceTakeoverCount:++
    - if <def[ManageNation]||null> == null || <def[ManageNPC]||null> == null || <def[ManageTown]||null> == null {
      - announce "UpdatingOutpostTownERROR %ManageName%! <server.flag[%ManageName%NationName]||None> - <server.flag[%ManageName%TownName]||None> - <server.flag[%ManageName%NPCName]||None> - " to_flagged:DreamListener
      - queue clear
      }
    - if <def[OwnerNation]> != Wild {
      - if <nation@%ManageNation%.type||null> == null {
        - announce "%ManageNation% is not a Nation" to_flagged:DreamListener
        - queue clear
      }
      - if <server.flag[TeaOutpostRunTowny]||false> == true {
        - execute as_server "dc <def[ManageNPC]> t set perm outsider off"
        }
        else {
          - announce "execute as_server 'dc <def[ManageNPC]> t set perm outsider off' TeaOutpostRunTowny" to_flagged:DreamListener
          }
      - foreach <nation@%ManageNation%.allies||li@> {
        - define AllyName <def[value].replace[nation@].with[]>
        - if <def[AllyName]> != %OwnerNation% {
          - if <server.flag[TeaOutpostRunTowny]||false> == true {
            - execute as_server "dc <def[ManageNPC]> n ally remove %AllyName%"
            }
            else {
              - announce "execute as_server 'dc <def[ManageNPC]> n ally remove %AllyName%' TeaOutpostRunTowny" to_flagged:DreamListener
              }
          }
        - wait 10t
        }
      - if <server.flag[TeaOutpostRunTowny]||false> == true {
        - execute as_server "dc <def[ManageNPC]> n ally add %OwnerNation%"
        }
        else {
          - announce "execute as_server 'dc <def[ManageNPC]> n ally add %OwnerNation%' TeaOutpostRunTowny" to_flagged:DreamListener
          }

      - foreach <server.flag[%ManageName%AllyList].as_list||li@> {
        - define AllyNationName <server.flag[%value%NationName]>
        - if <nation@%AllyNationName%.type||null> == null {
          - announce "%AllyNationName% is not a Nation" to_flagged:DreamListener
          - foreach next
          }
        - if !<nation@%ManageNation%.allies.as_list.contains[nation@%value%]> {
          - if <server.flag[TeaOutpostRunTowny]||false> == true {
            - execute as_server "dc <def[ManageNPC]> n ally add %AllyNationName%"
            }
            else {
              - announce "execute as_server 'dc <def[ManageNPC]> n ally add %AllyNationName%' TeaOutpostRunTowny" to_flagged:DreamListener
              }
          }
        - wait 10t
        }
          
          
          
      }
      else {
        - if <nation@%ManageNation%.type||null> == null {
          - announce "%ManageNation% is not a Nation" to_flagged:DreamListener
          - queue clear
        }
        - foreach <nation@%ManageNation%.allies||li@> {
          - define AllyName <def[value].replace[nation@].with[]>
          - if <server.flag[TeaOutpostRunTowny]||false> == true {
            - execute as_server "dc <def[ManageNPC]> n ally remove %AllyName%"
            }
            else {
              - announce "execute as_server 'dc <def[ManageNPC]> n ally remove %AllyName%' TeaOutpostRunTowny" to_flagged:DreamListener
              }
          
          - wait 10t
          }
          
        - if <server.flag[TeaOutpostRunTowny]||false> == true {
          - execute as_server "dc <def[ManageNPC]> t set perm outsider on"
          }
          else {
            - announce "execute as_server 'dc <def[ManageNPC]> t set perm outsider on' TeaOutpostRunTowny" to_flagged:DreamListener
            }
        }

TeaOutpost_GiveXPTask:
  type: task
  debug: false
  script:
    - define Player <def[1]>
    - define Colour <def[2]>
    - define ColourSecondary <def[3]>
   # - announce "<%Player%.xp.to_next_level>"
    - define XPtonextlevel <%Player%.xp.to_next_level>
    - define XPpercent <%Player%.xp||0>
    - define XPthatplayerhas <el@%XPpercent%.as_int.mul[0.01].mul[%XPtonextlevel%]||0>
    - define XPtogive <el@%XPtonextlevel%.sub[%XPthatplayerhas%].add[1].as_int||%XPtonextlevel%>
   # - announce "%XPtogive%"
   # - define HalfXP <math:%XPqty%*0.5>

    
  #  - give xp quantity:%HalfXP% player:%Player%
    - wait 10t
   # - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
    - title subtitle:<green>+%XPtogive%<&sp>xp targets:%Player%
    - narrate "<%Colour%>Level Up! <%ColourSecondary%>+%XPtogive%<&sp>xp to Level <%Player%.xp.level.add[1]>" targets:%Player%
   # - title subtitle:<green>Lvl<&co><%player%.xp.level>+1 targets:%Player%
    - wait 10t
  #  - repeat %XPtogive% {
  #    - give xp quantity:1 player:%Player%
  #    - wait 5t
  #    }
    - give xp quantity:%XPtogive% player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[4]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
    - give xp quantity:1 player:%Player%
    - ^log "<server.flag[TeaOutpost_TotalTrainingCount].round||0> <def[Player].name> REGULAR <def[Colour]> <def[4]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_TRAINING_LOGS.yml
   # - ^flag server TeaOutpost_TotalTrainingCount:++
    - if <%Player%.xp.level||0> >= 30 {
      - narrate "<%Colour%>MCMMO! <%ColourSecondary%><%Player%.xp.level>+1" targets:%Player%
      - ^log "<server.flag[TeaOutpost_TotalTrainingCount].round||0> <def[Player].name> MCMMO <def[Colour]> <def[4]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_TRAINING_LOGS.yml
    }
    - if <%Player%.xp.level||0> >= 60 {
      - inject TeaOutpost_GiveSpellTask
      - ^log "<server.flag[TeaOutpost_TotalTrainingCount].round||0> <def[Player].name> SPELL <def[Colour]> <def[4]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_TRAINING_LOGS.yml
      }
    - ^flag server TeaOutpost_TotalTrainingCount:++

   # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
   # - run TeaOutpost_OngoingSpellTask def:%CuboidName% delay:1s

TeaOutpost_GiveSpellTask:
  type: task
  debug: false
  script:
    - define CuboidName <def[4]>
    - define Spell <server.flag[%CuboidName%SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck].first>
  #  - define Colour <def[2]>
  #  - define ColourSecondary <def[3]>
   # - announce "<%Player%.xp.to_next_level>"
  #  - define XPtonextlevel <%Player%.xp.to_next_level>
  #  - define XPpercent <%Player%.xp||0>
  #  - define XPthatplayerhas <el@%XPpercent%.as_int.mul[0.01].mul[%XPtonextlevel%]||0>
  #  - define XPtogive <el@%XPtonextlevel%.sub[%XPthatplayerhas%].add[1].as_int||%XPtonextlevel%>
   # - announce "%XPtogive%"
   # - define HalfXP <math:%XPqty%*0.5>

    
  #  - give xp quantity:%HalfXP% player:%Player%
  #  - wait 10t
   # - define Colour <server.flag[Ownerof%CuboidName%]||Gray>
  #  - title subtitle:<green>+%XPtogive%<&sp>xp targets:%Player%
    - narrate "<%Colour%>Spell Up!! <%ColourSecondary%>%Spell%" targets:%Player%
    - flag %Player% %CuboidName%GaveSpell:true duration:19m
    - cast %Spell% <%Player%> duration:20m

   # - title subtitle:<green>Lvl<&co><%player%.xp.level>+1 targets:%Player%
  #  - wait 10t
  #  - repeat %XPtogive% {
  #    - give xp quantity:1 player:%Player%
  #    - wait 5t
  #    }
 #   - give xp quantity:%XPtogive% player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[4]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:<el@%XPtogive%.div[8]> player:%Player%
  #  - wait 2t
  #  - give xp quantity:1 player:%Player%
  #  - if <%Player%.xp.level||0> >= 30 {
  #    - narrate "<%Colour%>MCMMO! <%ColourSecondary%><%Player%.xp.level>+1" targets:%Player%
  #  }
  #  - if <%Player%.xp.level||0> >= 60 {
  #    - narrate "<%Colour%>Spells! <%ColourSecondary%><%Player%.xp.level>+1" targets:%Player%
  #  }
   # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
   # - run TeaOutpost_OngoingSpellTask def:%CuboidName% delay:1s

TeaOutpost_SpellTask:
  type: task
  debug: false
  script:
   # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
    - run TeaOutpost_OngoingSpellTask def:%CuboidName% delay:1s


TeaOutpost_OngoingSpellTask:
  type: task
  debug: false
  script:
    - while <player.location.cuboids.as_list.contains[cu@<def[1]>]||false> {
     # - announce "<def[1]>"
      - if <player.flag[<def[1]>GaveSpell]||false> != true {
        - inject TeaOutpost_SpellChooserTask
        }
      - wait 10s
      - if <player.is_online||false> != true {
        - while stop
        }
      - if <server.flag[<def[1]>SpellEffect]||None> == None {
        - queue clear
        }
      }
    - if <player.is_online||false> == true && <player.flag[<def[1]>GaveSpell]||false> != true  {
      - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      - define SpellToCast <%Spell%.first>
      - cast %SpellToCast% <player> duration:5s
      }

TeaOutpost_SpellChooserTask:
  type: task
  debug: false
  script:
   # - announce "SPELL CHOOSER"
    - choose <server.flag[<def[1]>SpellTargets]||ALL>:
      - case cancel:
        - wait 10s
      - case ALL:
        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
        - define SpellToCast <%Spell%.first>
        - cast %SpellToCast% <player> duration:60s
      - case TEAM:
        - if <player.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
          - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
          - define SpellToCast <%Spell%.first>
          - cast %SpellToCast% <player> duration:60s
          }
          else {
            - wait 10s
            }
      - case ENEMY:
        - if <player.flag[RaceColour]||Gray> != <server.flag[Ownerof<def[1]>]||Gray> {
          - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
          - define SpellToCast <%Spell%.first>
          - cast %SpellToCast% <player> duration:60s
          }
          else {
            - wait 10s
            }
      - case NONE:
        - wait 10s
      - case default:
        - wait 10s
        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
        - define SpellToCast <%Spell%.first>
        - cast %SpellToCast% <player> duration:60s
   #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
   #   - define SpellToCast <%Spell%.first>
      #  - choose <server.flag[<def[1]>SpellTargets]||ALL>:
     #   - choose <server.flag[<def[1]>SpellTargets]||ALL>:
      #    - case cancel:
      #      - wait 10s
#        - choose "1": 
#          - case "1": 
#            - debug LOG "Success!" 
      #    - case ALL:
      #      - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      #      - define SpellToCast <%Spell%.first>
      #      - cast %SpellToCast% <player> duration:15s
      #    - case TEAM:
      #      - if <player.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
      #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      #        - define SpellToCast <%Spell%.first>
      #        - cast %SpellToCast% <player> duration:15s
      #        }
      #        else {
      #          - wait 10s
      #          }
      #    - case ENEMY:
      #      - if <player.flag[RaceColour]||Gray> != <server.flag[Ownerof<def[1]>]||Gray> {
      #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
      #        - define SpellToCast <%Spell%.first>
      #        - cast %SpellToCast% <player> duration:15s
      #        }
      #        else {
      #          - wait 10s
      #          }
      #    - case NONE:
      #      - wait 10s
        #  - case default:
        #    - wait 10s
         #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
         #   - define SpellToCast <%Spell%.first>
         #   - cast %SpellToCast% <player> duration:15s
      #  - narrate "<gray>Repplying %Spell%"
#        - wait 10s
#        - if <player.is_online||false> != true {
#          - while stop
#          }
#        }

    
    #####
 #   - if <server.flag[<def[1]>SpellEffect]||None> != None {
 #  #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #  #   - define SpellToCast <%Spell%.first>
 #     - while <player.location.cuboids.as_list.contains[cu@<def[1]>]||false> {
 #     #  - choose <server.flag[<def[1]>SpellTargets]||ALL>:
 #    #   - choose <server.flag[<def[1]>SpellTargets]||ALL>:
 #     #    - case cancel:
 #     #      - wait 10s
 #       - choose "1": 
 #         - case "1": 
 #           - debug LOG "Success!" 
 #     #    - case ALL:
 #     #      - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #     #      - define SpellToCast <%Spell%.first>
 #     #      - cast %SpellToCast% <player> duration:15s
 #     #    - case TEAM:
 #     #      - if <player.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
 #     #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #     #        - define SpellToCast <%Spell%.first>
 #     #        - cast %SpellToCast% <player> duration:15s
 #     #        }
 #     #        else {
 #     #          - wait 10s
 #     #          }
 #     #    - case ENEMY:
 #     #      - if <player.flag[RaceColour]||Gray> != <server.flag[Ownerof<def[1]>]||Gray> {
 #     #        - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #     #        - define SpellToCast <%Spell%.first>
 #     #        - cast %SpellToCast% <player> duration:15s
 #     #        }
 #     #        else {
 #     #          - wait 10s
 #     #          }
 #     #    - case NONE:
 #     #      - wait 10s
 #       #  - case default:
 #       #    - wait 10s
 #        #   - define Spell <server.flag[<def[1]>SpellEffect].replace[Slowness].with[Slow].replace[Haste].with[Fast_digging].replace[Mining_Fatigue].with[Slow_digging].replace[Strength].with[Increase_damage].replace[Jump_Boost].with[Jump].replace[Nausea].with[Confusion].replace[Resistance].with[Damage_resistance].replace[Bad_Luck].with[Unluck]>
 #        #   - define SpellToCast <%Spell%.first>
 #        #   - cast %SpellToCast% <player> duration:15s
 #     #  - narrate "<gray>Repplying %Spell%"
 #       - wait 10s
 #       - if <player.is_online||false> != true {
 #         - while stop
 #         }
 #       }
 #   }

  # # - narrate "<gray>Applying <server.flag[%CuboidName%SpellEffect]>"
  # # - run TeaOutpost_OngoingSpellTask def:%CuboidName%|<player.name>
  #       - define Spell Speed
  #    - define Spell Slowness
  #    #Slow
  #    - define Spell Haste
  #    #Fast_digging
  #    - define Spell Mining_Fatigue
  #    #Slow_digging
  #    - define Spell Strength
  #    #Increase_damage
  #    - define Spell Jump_Boost
  #    #Jump
  #    - define Spell Nausea
  #    #Confusion
  #    - define Spell Regeneration
  #    - define Spell Resistance
  #    #Damage_resistance
  #    - define Spell Fire_Resistance
  #    - define Spell Water_Breathing
  #    - define Spell Invisibility
  #    - define Spell Blindness
  #    - define Spell Night_Vision
  #    - define Spell Hunger
  #    - define Spell Weakness
  #    - define Spell Poison
  #    - define Spell Saturation
  #    - define Spell Glowing
  #    - define Spell Levitation
  #    - define Spell Luck
  #    - define Spell Bad_Luck
    
TeaOutpost_EntryAnnouncementTask:
  type: task
  debug: false
  script:
    - define AnnouncementColour <server.flag[Ownerof%CuboidName%]||Gray>
    - define AnnouncementColourSecondary <server.flag[Ownerof%CuboidName%Secondary]||Gray>
    - narrate "<proc[msgCommand].context[<%AnnouncementColour%><server.flag[%CuboidName%DisplayName]||The<&sp>Outpost> (<server.flag[%CuboidName%TrainingFocus]||->) <%AnnouncementColourSecondary%>-<%AnnouncementColour%> <server.flag[%AnnouncementColour%DisplayName]||Wild>|outpost here|<%AnnouncementColour%><server.flag[%CuboidName%SpellEffect]||No Spell> (<server.flag[%CuboidName%SpellTargets]||No Spell>) - <%AnnouncementColourSecondary%>Click for more info]>"


TeaOutpost_Cooldown_Task:
  type: task
  debug: false
  script:
    - while <cu@%CuboidName%.list_players.size.is[LESS].than[1]||false> {
      - wait 3s
     # - announce "<server.flag[<server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%]||0>"
      - if <server.flag[<server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%]||0> > 0 {
        - if <server.flag[<server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%]||0> < 1 {
          - flag server <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%:0
          }
          else {
            - flag server <server.flag[CurrentCapturerof%CuboidName%]||Gray>Captureof%CuboidName%:--
            }
        }
        else {
          - while stop
          }
      }

TeaOutpost_Autoreset_Task:
  type: task
  debug: false
  script:
    - flag server %CuboidName%ResetCountdown:4
    - wait 60s
    - while <cu@%CuboidName%.list_players.size.is[LESS].than[1]||false> {
      - if <server.flag[%CuboidName%ResetCountdown]||0> > 1 {
        - flag server %CuboidName%ResetCountdown:--
       # - announce "reset<server.flag[%CuboidName%ResetCountdown]||0>"
        }
        else {
        #  - announce "autoresetting"
        #  - flag server CTPPointList:<-:cu@%CuboidName%
          - run TeaOutpost_Reset_Task def:%CuboidName%
          - while stop
          }
      - wait 60s
      }
  #  - wait 10s
  #  - announce "<dark_gray>running reset! <def[1]> <def[2]>"
  #  - define CuboidName <def[1]>
  #  - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
  #  - modifyblock %ObsidianList% obsidian delayed


TeaOutpost_Reset_Task:
  type: task
  debug: false
  script:
    - wait 1s
  #  - announce "<dark_gray>running reset! <def[1]>"
    - define CuboidName <def[1]>
    - define ObsidianList <server.flag[%CuboidName%ObsidianLocations].as_list>
    - playeffect %ObsidianList% effect:HAPPY_VILLAGER quantity:10
    - modifyblock %ObsidianList% obsidian delayed
    - flag server %CuboidName%ObsidianCount:5
    - ^flag global <server.flag[CurrentCapturerof%1%]>Captureof<def[1]>:0
    - ^flag server CTPPointHealth<def[1]>:<server.flag[CTPPointResetHealth%1%]||1000>
    - flag server %CuboidName%IsRunningCaptureTask:false
    - announce "<gray><bold>Outpost:<gray> Reset Task Complete: <def[1]>" to_flagged:DreamListener

TeaOutpost_periodical_unload:
  type: task
  debug: false
  script:
    - foreach <yaml.list.filter[starts_with[TeaOutpost_]]> {
      - define OutpostID <def[value].replace[TeaOutpost_]>
    #  - if <def[chunk].is_loaded||false> {
     #   - if <def[chunk].players.size||0> < 1 {
      #    - if <yaml.list> contains securizen_%value% {
      - yaml "savefile:/Outpost/<def[OutpostID]>_CHANGES.yml" id:%value%
      - yaml unload id:%value%
      - announce to_ops "unloaded %value%"
     #       }
     #     }
     #   }
      - wait 10s
      }
    - run TeaOutpost_periodical_unload delay:30s
    
TeaOutpost_Write_Data:
  type: task
  debug: false
  speed: 0
  definitions: OutpostID|Player|PlayerName|TeamColour|Change|Result
  script:
    - wait 1t
    - if !<yaml.list.contains[TeaOutpost_<def[OutpostID]>]> {
      - if !<server.has_file[/Outpost/<def[OutpostID]>_CHANGES.yml]> {
        - yaml create id:TeaOutpost_<def[OutpostID]>
        } else {
        - yaml "load:/Outpost/<def[OutpostID]>_CHANGES.yml" id:TeaOutpost_<def[OutpostID]>
        }
      }
    - define timestamp "d@<server.current_time_millis.div[50].as_int>t"
    - define path "<def[OutpostID]>"
  #  - if <yaml[TeaOutpost_<def[OutpostID]>].contains[<def[location].simple.before_last[,].replace[,].with[.]>].not> {
  #    - yaml set "<def[path]>.d@0t.Change:WORLD_GEN" "id:TeaOutpost_<def[OutpostID]>"
  #    - yaml set "<def[path]>.d@0t.material:%old_material%" "id:TeaOutpost_<def[OutpostID]>"
  #    - yaml set "<def[path]>.d@0t.type:block_change" "id:TeaOutpost_<def[OutpostID]>"
  #    }
    - yaml set "<def[path]>.%timestamp%.Player:%Player%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.PlayerName:%PlayerName%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.TeamColour:%TeamColour%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.Change:%Change%" "id:TeaOutpost_<def[OutpostID]>"
    - yaml set "<def[path]>.%timestamp%.Result:%Result%" "id:TeaOutpost_<def[OutpostID]>"
    
    
    
      #      - foreach <proc[securizen_location_get_edits].context[%OutpostID%|1|<context.args.get[2].as_int||3>]||li@> {

TeaOutpost_get_edits:
  type: procedure
  debug: false
  script:
#  - if <def[1].as_location||none> == none {
#    - debug error "Missing location for "securizen_location_get_edits!"
#    - determine null
#    }
  - define OutpostID %1%
  - define path "%OutpostID%"
  - if <def[2].as_int||none> != none {
    - define first <def[2].as_int>
    } else {
    - debug warning "Value for first entry is not a valid integer."
    - define first 1
    }
  - if <def[3].as_int||none> != none {
    - define last <def[3].as_int>
    } else {
    - debug warning "Value for last entry is not a valid integer."
    - define last 9999
    }
  - if !<yaml.list.contains[TeaOutpost_%OutpostID%]> {
    - if !<server.has_file[/Outpost/<def[OutpostID]>_CHANGES.yml]> {
      - determine li@
      - queue clear
      } else {
      - yaml "load:/Outpost/<def[OutpostID]>_CHANGES.yml" id:TeaOutpost_%OutpostID%
      }
    }
  - if <yaml[TeaOutpost_%OutpostID%].contains[<def[path]>].not> {
    - determine li@
    }
  - define entries li@
  - foreach <yaml[TeaOutpost_%OutpostID%].list_keys[<def[path]>].parse[in_ticks].numerical.reverse.get[%first%].to[%last%]||li@> {
    - define timestamp "d@%value%t"
    - define entries <def[entries].include[%timestamp%/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Player]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.PlayerName]||nobody>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.TeamColour]||none>]>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Change]||none>/<yaml[TeaOutpost_%OutpostID%].read[<def[path]>.%timestamp%.Result]||none>
    }
  - determine %entries%
  
TeaOutpost_InfluenceBars:
  type: procedure
  debug: false
  script:
  - define CurrentInfluence %1%
  - define MaxInfluence %2%
  - define CurrentInfluencePercentage <def[1].div[<def[2]>].mul[100].round_down>
  - define WorkingCIP %CurrentInfluencePercentage%
  - ^if <def[CurrentInfluence]> <= 0 {
    - determine <def[InfluenceCountBars]||->
    }
  - ^if <def[WorkingCIP]> >= 64 {
    - ^define InfluenceCountBars ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
    - ^define WorkingCIP <def[WorkingCIP].sub[64].round_down>
  }
  - ^if <def[WorkingCIP]> >= 32 {
    - ^if <def[CurrentInfluencePercentage]> >= 64 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||||||||||||||||||||||||||||||
      }
      else {
        - ^define InfluenceCountBars ||||||||||||||||||||||||||||||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[32].round_down>
  }
  - ^if <def[WorkingCIP]> >= 16 {
    - ^if <def[CurrentInfluencePercentage]> >= 32 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||||||||||||||
      }
      else {
        - ^define InfluenceCountBars ||||||||||||||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[16].round_down>
  }
  - ^if <def[WorkingCIP]> >= 8 {
    - ^if <def[CurrentInfluencePercentage]> >= 16 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||||||
      }
      else {
        - ^define InfluenceCountBars ||||||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[8].round_down>
  }
  - ^if <def[WorkingCIP]> >= 4 {
    - ^if <def[CurrentInfluencePercentage]> >= 8 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||||
      }
      else {
        - ^define InfluenceCountBars ||||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[4].round_down>
  }
  - ^if <def[WorkingCIP]> >= 2 {
    - ^if <def[CurrentInfluencePercentage]> >= 4 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>||
      }
      else {
        - ^define InfluenceCountBars ||
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[2].round_down>
  }
  - ^if <def[WorkingCIP]> >= 1 {
    - ^if <def[CurrentInfluencePercentage]> >= 2 {
      - ^define InfluenceCountBars <def[InfluenceCountBars]||>|
      }
      else {
        - ^define InfluenceCountBars |
        }      
    - ^define WorkingCIP <def[WorkingCIP].sub[1].round_down>
  }
 # - if <def[WorkingCIP]> > 0 {
 #   - define ErrorReport Error
 # }

  - determine <def[InfluenceCountBars]||<&pipe>>
  
"CPCaptureTasktest":
  type: task
  debug: false
  script:
  - while <server.flag[<def[3]>]||false> {
    - if <server.flag[<def[1]>IsRunningCaptureTask]||false> == true {
      - queue clear
    }
    - flag global <def[1]>IsRunningCaptureTask:true
    - ^define AttackCount 0
    - ^define DefenseCount 0
    - ^define DenyCount 0
    # FIRST WE FIND OUT HOW MANY DEFENDING, DENYING AND ATTACKING PLAYERS THERE ARE
    # FOREACH PLAYER INSIDE THE CUBOID:
    - ^foreach <def[2].list_players> {
      # IF THIS PLAYERS COLOUR MATCHES THE CONTROL POINTS COLOUR (DEFENDER):
        # ADD +1 TO THE DEFENSE COUNT
      - ^if <%value%.flag[RaceColour]||Gray> == <server.flag[Ownerof<def[1]>]||Gray> {
        - ^define DefenseCount <math.as_int:<def[DefenseCount]||0>+1>
      }
      # ELSE IF THIS PLAYERS COLOUR DOES NOT MATCH THE CURRENTLY CAPTURING TEAMS COLOUR (DENIER = NOT ATTACKER & NOT DEFENDER):
        # ADD +1 TO THE DENY COUNT
      else if <%value%.flag[RaceColour]||Gray> != <server.flag[CurrentCapturerof<def[1]>]||<%value%.flag[RaceColour]||Gray>> && <server.flag[CurrentCapturerof<def[1]>]||Gray> != Gray {
        - ^define DenyCount <math.as_int:<def[DenyCount]||0>+1>
      }
      # ELSE (ATTACKER):
        # ADD +1 TO THE ATTACK COUNT
        # SAVE PLAYERS COLOUR AS ATTACKER
      else {
        - ^define AttackCount <math.as_int:<def[AttackCount]||0>+1>
        - ^flag global CurrentCapturerof<def[1]>:<%value%.flag[RaceColour]||Gray>
        - ^flag global CurrentCapturerof<def[1]>Secondary:<%value%.flag[RaceColourSecondary]||Dark_Gray>
      }
    }

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # QUICK MATH 'CAUSE DEFENDERS AND DENIERS HAVE SIMILAR MOTIVES
    # SAVE (DEFENSE COUNT)+(DENY COUNT) AS BLOCK COUNT
    - ^define BlockCount <math.as_int:<def[DefenseCount]||0>+<def[DenyCount]||0>>

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # NEXT WE DECIDE WHAT TO DO BASED ON ATTACKER AND DEFENDER COUNT
    # IF BLOCK COUNT IS GREATER THAN ATTACK COUNT (BLOCKERS ARE WINNING):
    - ^if <def[BlockCount]||0> > <def[AttackCount]||0> {
      # IF CP IS BEING CAPTURED:
      - ^if <server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>].as_int||0> > 1 {
        - ^define TotalBlockInt <math.as_int:<def[BlockCount]||0>-<def[AttackCount]||0>>
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||<def[OwnerColour]||Gray>>
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:<math.as_int:<server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>]>-<def[TotalBlockInt]||0>>
        - ^if <server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>]||0> > <server.flag[CTPPointHealth<def[1]>].as_int.sub[1]||0> {
          - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:0
          }
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - ^inject RevertingActionBarHandler
        }
      }
      # ELSE (CP IS FULLY DEFENDED):
      else {
        - ^define TotalBlockInt <math.as_int:<def[BlockCount]||0>-<def[AttackCount]||0>>
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:0
        - ^flag global CurrentCapturerof<def[1]>:Gray
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:0
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - ^inject DefendingActionBarHandler
        }
      }
    }

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # ELSE IF BLOCK COUNT IS EQUAL TO ATTACK COUNT (ITS A TIE):
    else if <def[BlockCount]||0> == <def[AttackCount]||0> {
      - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
      - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
      - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
      - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
      - ^if <server.flag[<def[1]>IsSilent]||false> == false {
        - ^inject NeutralActionBarHandler
      }
    }

    # ---------- ---------- ---------- ---------- ---------- ---------- 
    # ELSE (ATTACKERS ARE WINNING):
    else {
      # IF CP IS BEING CAPTURED:
      - ^if <server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>].as_int||0> < <server.flag[CTPPointHealth<def[1]>].as_int.sub[1]||0> {
        - ^define TotalAttackInt <math.as_int:<def[AttackCount]||0>-<def[BlockCount]||0>>
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:<math.as_int:<server.flag[<server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>]>+<def[TotalAttackInt]>>
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - ^inject CapturingActionBarHandler
        }
      }
      # ELSE (CP IS FULLY CAPTURED):
      else {
        - ^if <server.flag[<def[1]>IsSilent]||false> == false {
          - playsound <def[2].center> sound:VILLAGER_YES
        }
        - ^flag global <server.flag[CurrentCapturerof<def[1]>]>Captureof<def[1]>:<server.flag[CTPPointHealth<def[1]>].as_int.sub[1]||0>
        - ^define AttackColour <server.flag[CurrentCapturerof<def[1]>]||Gray>
        - ^define AttackColourSecondary <server.flag[CurrentCapturerof<def[1]>Secondary]||Dark_Gray>
        - ^define OwnerColour <server.flag[Ownerof<def[1]>]||Gray>
        - ^define OwnerColourSecondary <server.flag[Ownerof<def[1]>Secondary]||Gray>
        - ^if <server.flag[<def[1]>scriptlist].size||0> > 0 {
          - ^announce "<gray><bold>NoonLight<gray>: Running <server.flag[<def[1]>scriptlist].as_list.replace[|].with[,<&sp>].replace[li@].with[]>: <def[1]>.script.list" to_flagged:NoonLightDiagnostic
          - ^foreach <server.flag[<def[1]>scriptlist].as_list.deduplicate> {
            - announce "<gray>Tea: Running %value% (<def[1]>.script.list)" to_flagged:DreamListener
            - run %value% def:<def[2]>|<def[1]>|<server.flag[CurrentCapturerof<def[1]>]>|<%AttackColour%>|<%AttackColourSecondary%>|<%OwnerColour%>
          }
        }
        else {
          - announce "<gray><bold>NoonLight<gray>: <yellow>Run task list is empty! <gray><def[1]>.script.list" to_flagged:NoonLightDiagnostic
        }
        - ^if <server.flag[<def[1]>injectlist].size||0> > 0 {
          - ^announce "<gray><bold>NoonLight<gray>: Injecting <server.flag[<def[1]>injectlist].as_list.replace[|].with[,<&sp>].replace[li@].with[]>: <def[1]>.inject.list" to_flagged:NoonLightDiagnostic
          - ^foreach <server.flag[<def[1]>injectlist].as_list> {
            - announce "<gray>Tea: Injecting %value%" to_flagged:DreamListener
            - inject %value%
          }
        }
        else {
          - announce "<gray><bold>NoonLight<gray>: <yellow>Inject task list is empty! <gray><def[1]>.inject.list" to_flagged:NoonLightDiagnostic
          - wait 1s
        }
      }
    }
    - wait 5t
    - flag global <def[1]>IsRunningCaptureTask:false
  }
  
"StandardCaptureTaskOutpost":
  type: task
  debug: false
  script:
  - ^if <math.as_int:<server.flag[<server.flag[CurrentCapturerof<def[2]>]>Captureof<def[2]>].as_int||0>/2> == <math:<server.flag[<server.flag[CurrentCapturerof<def[2]>]>Captureof<def[2]>].as_int||0>/2> {
    - title title:<def[5]>CAPTURED subtitle:<def[4]>-[<&sp><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[4]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
    - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
  }
  else {
    - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
    - title title:<def[5]>CAPTURED subtitle:<def[5]>-[<&sp><def[4]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
  }
  - wait 5t
  - ^define OldOwner <server.flag[Ownerof<def[2]>]>
  - ^define NewOwner <server.flag[CurrentCapturerof<def[2]>]>
  - ^flag server %OldOwner%OutpostList:<-:<def[2]>
  - ^flag server %NewOwner%OutpostList:->:<def[2]>
  - ^flag server <def[2]>LastCaptureTime:<util.date.time.hour><util.date.time.minute.replace[regex:^(?!..)].with[0]>
  - ^flag server <def[2]>LastCaptureDate:<util.date.time.year><util.date.time.month.replace[regex:^(?!..)].with[0]><util.date.time.day.replace[regex:^(?!..)].with[0]>
  - ^flag global Ownerof<def[2]>:<server.flag[CurrentCapturerof<def[2]>]>
  - ^flag global Ownerof<def[2]>Secondary:<server.flag[CurrentCapturerof<def[2]>Secondary]>
  - ^flag server CTPPointHealth<def[1]>:<server.flag[CTPPointResetHealth%1%]||1000>
  - ^flag global <server.flag[CurrentCapturerof<def[2]>]>Captureof<def[2]>:0
  - ^flag global CurrentCapturerof<def[2]>:Gray
  - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
  - title title:<def[4]>CAPTURED subtitle:<def[5]>-[<&sp><def[4]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
  - wait 5t
  - playsound <def[1].center> sound:note_bass volume:0.5 pitch:2
  - title title:<def[5]>CAPTURED subtitle:<def[5]>-[<&sp><def[4]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]>/<def[6]><server.flag[CTPPointResetHealth<def[2]>].round||0><def[5]><&sp>]- fade_in:1t stay:30t fade_out:15t targets:<def[1].list_players>
 # - flag server CTPPointList:<-:cu@<def[2]>
  - ^flag global <server.flag[CurrentCapturerof<def[2]>]>Captureof<def[1]>:0
  - if <server.flag[%2%TownName]||null> != null {
    - define InfluenceID <server.flag[%2%TownName]>
    }
    else {
      - define InfluenceID %2%
   #   - announce "<player.name> found ManageName %ManageName%" to_flagged:DreamListener
      }
  - ^if !<server.flag[<def[InfluenceID]>InfluenceList].contains[%NewOwner%]||false> {
    - ^if <server.flag[<def[InfluenceID]>InfluenceList].is_empty||true> {
      - ^flag server TownOwnerof<def[InfluenceID]>:%NewOwner%
      - ^flag server TownOwnerof<def[InfluenceID]>Secondary:%NewOwner%
      }
    - ^flag server <def[InfluenceID]>InfluenceList:->:%NewOwner%
    - ^if <server.flag[<def[InfluenceID]>InfluencePoints%NewOwner%]||0> < 1 {
      - ^flag server <def[InfluenceID]>InfluencePoints%NewOwner%:1
      }
    }

  - run TeaOutpost_Reset_Task def:<def[2]>|<player.name>
  - run TeaOutpost_Write_Data def:<def[2]>|<player>|<player.name>|<def[NewOwner]||Gray>|Capture|<def[NewOwner]>
  - ^log "<server.flag[TeaOutpost_TotalCaptureCount].round||0> <def[2]> Capture <def[NewOwner]> <server.flag[TeaOutpost_%NewOwner%CaptureCount].round||0> <cu@%2%.list_players.parse[name]>" file:plugins/Denizen/outpost/<def[2].to_uppercase>_LOGS.yml
  - ^log "<server.flag[TeaOutpost_TotalCaptureCount].round||0> <def[2]> Capture <def[NewOwner]> <server.flag[TeaOutpost_%NewOwner%CaptureCount].round||0> <cu@%2%.list_players.parse[name]>" file:plugins/Denizen/outpost/OUTPOST_GLOBAL_LOGS.yml
  - ^flag server TeaOutpost_TotalCaptureCount:++
  - ^flag server TeaOutpost_%NewOwner%CaptureCount:++

  #- ^flag global <def[2]>containsplayers:false
OutpostmcmmoProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Skill Acrobatics
      - define Skill Alchemy
      - define Skill Archery
      - define Skill Axes
      - define Skill Excavation
      - define Skill Fishing
      - define Skill Herbalism
      - define Skill Mining
      - define Skill Repair
      - define Skill Swords
      - define Skill Taming
      - define Skill Unarmed
      - define Skill Woodcutting
      }
    - determine %Skill%

OutpostSpellProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Spell Speed
      - define Spell Slowness
      #Slow
      - define Spell Haste
      #Fast_digging
      - define Spell Mining_Fatigue
      #Slow_digging
      - define Spell Strength
      #Increase_damage
      - define Spell Jump_Boost
      #Jump
      - define Spell Nausea
      #Confusion
      - define Spell Regeneration
      - define Spell Resistance
      #Damage_resistance
      - define Spell Fire_Resistance
      - define Spell Water_Breathing
      - define Spell Invisibility
      - define Spell Blindness
      - define Spell Night_Vision
      - define Spell Hunger
      - define Spell Weakness
      - define Spell Poison
      - define Spell Saturation
      - define Spell Glowing
     # - define Spell Levitation
      - define Spell Luck
      - define Spell Bad_Luck
      #Unluck
      }
    - determine %Spell%

OutpostAdjectiveProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Name The<&sp>Blood<&sp>
      - define Name A<&sp>Lovely<&sp>
      - define Name The<&sp>Golden<&sp>
      - define Name The<&sp>Iron<&sp>
      - define Name The<&sp>Shadow<&sp>
      - define Name The<&sp>Guarded<&sp>
      - define Name An<&sp>Ancient<&sp>
      - define Name The<&sp>Bone<&sp>
      - define Name The<&sp>Silver<&sp>
      - define Name A<&sp>Ruined<&sp>
      - define Name A<&sp>Holy<&sp>
      - define Name The<&sp>Lost<&sp>
      - define Name The<&sp>Half-
      - define Name The<&sp>Weeping<&sp>
      - define Name The<&sp>Mad<&sp>
      - define Name The<&sp>Cursed<&sp>
      - define Name The<&sp>Dancing<&sp>
      - define Name The<&sp>Hidden<&sp>
      - define Name The<&sp>Happy<&sp>
      - define Name A<&sp>
      - define Name The<&sp>
      }
    - determine %Name%

OutpostNameProc:
  type: procedure
  definitions: lineLen|string
  debug: false

  script:
    - random {
      - define Name Tree
      - define Name Forge
      - define Name Temple
      - define Name Garden
      - define Name Swamp
      - define Name Island
      - define Name Tower
      - define Name Crater
      - define Name Hill
      - define Name College
      - define Name Sea
      - define Name Forest
      - define Name Ship
      - define Name Desert
      - define Name Mountain
      - define Name Crypt
      - define Name Pass
      - define Name Cottage
      }
    - determine %Name%